<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | Leonardo Borges]]></title>
  <link href="http://www.leonardoborges.com/writings/tags/architecture/atom.xml" rel="self"/>
  <link href="http://www.leonardoborges.com/writings/"/>
  <updated>2018-02-19T20:38:30+11:00</updated>
  <id>http://www.leonardoborges.com/writings/</id>
  <author>
    <name><![CDATA[Leonardo Borges]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A few more thoughts on final classes]]></title>
    <link href="http://www.leonardoborges.com/writings/2009/10/07/a-few-more-thoughts-on-final-classes/"/>
    <updated>2009-10-07T00:00:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2009/10/07/a-few-more-thoughts-on-final-classes</id>
    <content type="html"><![CDATA[<p>
I <a href="http://www.leonardoborges.com/writings/2009/03/17/final-classes-are-evil/" target="_blank">said final classes are evil</a> and that post got some attention with interesting comments. Maybe because of the title and the tone I wrote it, a few comments didn't get my real intention and perhaps I should have been more explicit about it. Go ahead and <a href="http://www.leonardoborges.com/writings/2009/03/17/final-classes-are-evil/" target="_blank">read it</a>. I'll wait. :)<br><br>Anyway, I thought I'd expand a little more on that subject, explaining my motivation to write that post and going through the topics I think were raised by my dear readers.<br><br>First off, final classes <strong>are evil for testing</strong>. And that's what it was all about in my previous post.<br><br>If you depend on a final class, your code will be harder to test. Unless the final class provides an interface that captures its intent - or you wrap that dependency.<br><br>But this affirmation has some implications that were pointed out by a few comments, some of which I agree with - others, not so much. So let's start!<br><br><strong>- Immutability </strong><br><br><span style="background-color: #ffffff;">Someone said "Why make a class final ? To make it immutable". This is not entirely true. Only by marking it final you do not ensure immutability. There is no point in doing that if you provide mutators - e.g. setters. - and don't declare your members private and final.</span><br><br>I think it's important to make this clear and understand that the immutability part you achieve by marking a class final is the one of preventing inheritance. Subclasses could possibly contain malicious/careless code and change the internal state of the class.<br><br><span style="background-color: #ffffff;">But there is another way of preventing subclassing without marking the parent final: declare its constructor private and provide a <a href="http://www.javapractices.com/topic/TopicAction.do?Id=21" target="_blank">static factory</a>.</span><br><br><strong>- Designing for extensibility</strong><br><br>This is hard. It basically means that if you don't mark a class final, you should document it for inheritance.<br><br>And this is why inheritance is, in general, a bad OO practice. By documenting the class you basically break encapsulation since you tell the world about your internals.<br><br>Therefore, the recommendation is to mark a class final if you're not sure if it's safe to subclass it - or if you just don't wanna bother writing documentation and thinking too much about your "client" subclasses.<br><br><strong>- Coding against interfaces</strong><br><br>This one is simple but yet often forgotten. Do not code to concrete classes. Always choose interfaces where possible.<br>It roughly means to do this:<br><pre lang="java">  List args = new ArrayList();</pre><br>instead of this:<br><pre lang="java">  ArrayList args = new ArrayList();</pre><br>By doing so you have the flexibility to not care about the implementation you're working with, as long as it obeys the interface. That way, the implementations can be swapped at any time without breaking any client's code.<br><br><strong>- The problem with testing</strong><br><br><strong></strong>All items listed here so far are widely regarded as best practices and the bullet I raised about hard testing usually happens when you "violate" some of them.<br><br>Specifically, if you decide not to design a class for inheritance and mark it as final, it's wise - in my opinion - to try and capture the class's intent through an interface.<br><br>That way you can safely mark your class final and users of your class can easily use the interface to extend it - by favoring <a href="http://www.artima.com/lejava/articles/designprinciples4.html" target="_blank">composition over inheritance</a> - or by providing it to mocking frameworks for easy testing.<br><br><strong>- Conclusion</strong><br><br>I don't really think there is a rule of thumb here. Java's standard library shows many examples of both approaches and some of them are now considered bad practices but yet are there for backward compatibility. Nevertheless, these are points to consider when designing your classes.<br><br>As pointed out by Josua Bloch in his awesome book <a href="http://www.shelfari.com/books/purchase?EditionId=1523265&amp;AssociateId=leonaborge-20&amp;WidgetId=111594" target="_blank">Effective Java</a>, "If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance".<br><br>As usual, comments are more than welcome :)
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Final classes are evil]]></title>
    <link href="http://www.leonardoborges.com/writings/2009/03/17/final-classes-are-evil/"/>
    <updated>2009-03-17T00:00:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2009/03/17/final-classes-are-evil</id>
    <content type="html"><![CDATA[<p>
<strong>Update:</strong> Go ahead and read this post in its entirety - including the comments. Then, read my other <a href="http://www.leonardoborges.com/writings/2009/10/07/a-few-more-thoughts-on-final-classes/">post where I expand the subject a little more</a>. <br><br>--<br><br>Every now and then I still do some Java coding. And I actually like it. I spent several years of my career developing primarily in Java and am very keen about the language.<br><br>I've been a fierce defender of it these days, specially with the wave of popularity of other languages such as Ruby and Groovy. But I must say that for the 1st time - actually the 2nd - I got pissed off at Java.<br><br>The reason? Final classes!<br><br>How arrogant of someone to say: "And from now on you shall not subclass my classes!"<br><br>Er.... Why?!?! I'm yet to find a good reason in favor of it. But I can share 2 that made me be completely against it. - I never actually liked it but it just didn't bother me that much in the past.<br><br>The first one happened while I was adding PostgreSQL XML support to <a href="http://hibernate.org/">Hibernate</a>. The basic idea is that the XML data type should behave mostly as a string, with the exception of the saving and loading operations.<br><br>The thing is, the String data type in Hibernate is declared final. So you cannot share behavior unless you copy and paste it. How smart.<br><br>And the second is in the testing area. We all love testing. And we all love mocking external dependencies so we can test our code in isolation and fast. Well, I hope your code doesn't depend on the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/net/URL.html">URL</a> class then.<br><br>It is declared final so you just can't mock it. Mocking frameworks like <a href="http://www.easymock.org/">easyMock</a> use subclassing to create your dependencies mock objects and obviously it doesn't work here.<br><br>Yeah yeah, of course you can refactor your code so it depends on an interface/class that wraps your URL class and then you can switch implementations. But just how stupid is that? Programming to interfaces makes sense, but not everywhere. Specially not when you're using a low level class like this one.<br><br>So please, software developers, architects and the like, design your systems for extensibility and stop being presumptuous.<br><br>P.S.: There is a testing framework called <a href="https://jmockit.dev.java.net/">jMockit</a> which uses instrumentation (Java 5+) to redefine methods in runtime so you can mock final classes. It works, but should we really be playing that much with the java class loader just so we can "easily" test our code?
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring 2.5: Dependency Injection that doesn't hurt]]></title>
    <link href="http://www.leonardoborges.com/writings/2007/12/07/spring-25-dependency-injection-that-doesnt-hurt/"/>
    <updated>2007-12-07T00:00:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2007/12/07/spring-25-dependency-injection-that-doesnt-hurt</id>
    <content type="html"><![CDATA[<p>
<a href="http://martinfowler.com/articles/injection.html">Dependency injection</a> - <a href="http://martinfowler.com/articles/injection.html">DI</a>Â - Â is a great thing. Really. The hability to tweak implementations without touching your code is awesome and the DI frameworks, like spring, saves you a lot of coding. No more service locators stuff.<br><br>But, and there is always a but, you're left with a bunch of XML configuration. And I hate it. Not that XML files are bad... the thing is that everything nowadays has its own set of XML configurarion files. And <a href="http://www.springframework.org">Spring</a> is not different.<br><br><!--more--><br><br>Let's take a look at a simple example on how dependency injection is handled in Spring.<br><br>Imagine you have a domain object called Invoice that, among other things, is somewhat defined like this:<br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>You have a method to send a certain Invoice through e-mail, probably to some customer. This method would basically do some processing, maybe formatting strings, and then, ideally, delegate the send e-mail task to someone else. Probably a infrastructure service or something similar, that I will call EmailService. This object knows how to do the low level stuff like connecting to the SMTP server and so on. So we need this object, we <em>depend</em> on it.Â  To express this dependency, the Invoice code would change to this:<br><br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br>private EmailService emailService;<br>public void setEmailService(EmailService service) {<br>emailService = service;<br>}<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>This way the Invoice class is prepared to be injected with its only dependency using Spring. Now, what you would have to do is to declaratively express this dependency to the Spring container, so it can settle things for you. This is done through its XML configuration file, often called <em>applicationContext</em>. Below is the snippet of the file relevant to this example:<br><br>[xml]<br><br><bean id="invoice" class="com.leonardoborges.Invoice"><br><property name="emailService">Â  <ref bean="emailService"></ref></property><br></bean><br><br><bean id="emailService" class="com.leonardoborges.EmailService"></bean><br><br>[/xml]And that's it. Upon initialization Spring will use this XML file to discover that the Invoice object depends on the EMailService object and inject it using the setter method we created before.<br><br>The problem is: If we have 50 domain objects that depends on 10 service objects that depends on anything else, we would end up in a XML forrest with at least 60 bean definitions.<br>Of course you can break this creating smaller XML files, but they are stillÂ XML files with bean definitions. Well, with Spring 2.5 we have a better option: We can use annotations!<br>In this new release, Spring use its own set of annotations to resolve object dependencies without XML. Let's see how this thing works.<br><br>Our previous Invoice object would change to this:<br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br>@AutoWired<br>@Qualifier("myEmailService")<br>private EmailService emailService;<br>public void setEmailService(EmailService service) {<br>emailService = service;<br>}<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>Let's explain this change. The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Autowired.html">@AutoWired</a> annotation tells spring that it should automatically wire dependencies based on its type, in our case, EmailService. But we take it a step further and choose which object to inject based not only on its type, but based on its name, with the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Qualifier.html">@Qualifier</a> annotation.<br><br>Â Hmm... you may be asking now - But where did we say theÂ objectÂ name is myEmailService?<br><br>Â Okay, the other leg of the magic is on the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/stereotype/Component.html">@Component</a> annotation:<br><br>[java]<br>@Component("myEmailService")<br>public class EmailService {<br>//methods<br>}<br>[/java]<br><br>With this annotation, you register a new component available for injection within the Spring container. This way, you don't need to put neither the Invoice objects, nor its dependencies in the xml files. Pretty, huh?<br><br>But one question remains: How the hell spring knows about this annotated classes?<br>This is the one-million question and the answer is simple. You <em>do</em> need an XML file, but just to tell spring where to look for annotated classes, this way:<br><br>[xml]<br><annotation-config></annotation-config><br><component-scan base-package="br.com"></component-scan><br>[/xml]<br><br>The first clause sets the container to support annotation based configuration. The second one, component-scan, defines the base package where Spring should look for anotated classes within your project. That's how it will be able to discover who needs who and who is a eligible component for injection.<br><br>You are really left with a small, tiny, piece of XML. Much more clean, elegant and much less XML to type.
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SCEA 5 Beta]]></title>
    <link href="http://www.leonardoborges.com/writings/2007/10/15/scea-5-beta/"/>
    <updated>2007-10-15T00:00:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2007/10/15/scea-5-beta</id>
    <content type="html"><![CDATA[<p>
Hoje fiz a versÃ£o beta da nova prova de arquiteto da Sun e eis algumas impressÃµes:<br><br>- Ã‰ longa e cansativa... fato justificÃ¡vel se levar-mos em consideraÃ§Ã£o o fato de ser uma prova em estado beta. Ela possui mais questÃµes que a versÃ£o final. SÃ£o 153 questÃµes no total, em 4h e 30min. <!--more--><br><br>- AlÃ©m de um considerÃ¡vel conhecimento de toda a plataforma JEE (EJB, JMS, Web Services e todas as outras siglas) algumas Ã¡reas foram mais exploradas que outras e acho que merecem atenÃ§Ã£o especia:<br><ul><br>  <li>SeguranÃ§a - Ã‰ uma preocupaÃ§Ã£o constante na prova e sÃ£o abordadas desde de policies de applets atÃ© tipos de ataques (SQL Injection, DDoS, Cross-site Scripting)</li><br>  <li>Web Services - AlÃ©m do conhecimento geral da nova versÃ£o, Ã© cobrado algum entendimento sobre a compatibilidade com versÃµes antigas da API</li><br>  <li>PadrÃµes de Projeto - Acho que isso nÃ£o mudou muito com relaÃ§Ã£o a versÃ£o antiga. SÃ£o apresentadas diversas situaÃ§Ãµes onde deve-se escolher qual o melhor padrÃ£o a ser aplicado. Assim como dado um padrÃ£o, Ã© perguntado quais suas vantagens e desvantagens</li><br></ul><br>No mais, uma prova padrÃ£o, com questÃµes de mÃºltipla seleÃ§Ã£o e drag'n drop. NÃ£o cheguei a estudar a fundo para essa prova e portanto nÃ£o espero um bom resultado. Mas a experiÃªncia serÃ¡ extremamente Ãºtil para quando eu for fazer a prova pra valer ;)
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Como o Spring me ajudou a manter o Active Record]]></title>
    <link href="http://www.leonardoborges.com/writings/2007/10/13/como-o-spring-me-ajudou-a-manter-o-active-record/"/>
    <updated>2007-10-13T00:00:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2007/10/13/como-o-spring-me-ajudou-a-manter-o-active-record</id>
    <content type="html"><![CDATA[<p>
Nesse primeiro post vou falar um pouco sobre meu novo trabalho. Na verdade, sobre um problema que encontramos lÃ¡.<br><br>Dentre diversas coisas que estamos fazendo, como migraÃ§Ãµes por exemplo, estou ajudando na elaboraÃ§Ã£o da arquitetura que irÃ¡ abrigar as novas aplicaÃ§Ãµes desenvolvidas na empresa. <!--more-->Ã‰ uma tarefa desgastante e cada decisÃ£o Ã© crÃ­tica, indo de discussÃµes sobre qual tecnologia usar para MVC atÃ© como organizar o <em>layering</em> da aplicaÃ§Ã£o. Essa arquitetura compreende tambÃ©m o desenvolvimento de um <em>framework </em>para facilitar a vida dos novos desenvolvedores que integrarÃ£o a equipe.<br><br>Pois bem, uma das decisÃµes que tomei foi a de evitar o <a target="_blank" href="http://martinfowler.com/bliki/AnemicDomainModel.html" title="Anemic Domain Model"><em>Anemic Domain Model</em></a><em> </em>e usar o Spring<em> </em>como framework de <a target="_blank" href="http://martinfowler.com/bliki/InversionOfControl.html" title="IoC">IoC</a>.<em> </em>Os benefÃ­cios disso sÃ£o assunto para outro post. ;) E um outro padrÃ£o que ajuda nisso se chama <em><a target="_blank" href="http://martinfowler.com/eaaCatalog/activeRecord.html" title="Active Record">Active Record</a></em>. AÃ­ comeÃ§aram os problemas! Essa divisÃ£o de responsabilidades sempre agrega uma nova (nem tÃ£o nova assim) forma de pensar. Vou mostrar um exemplo para ilustrar isso.<br><br>[java]<br>public class Usuario {<br>private String login;<br>private String senha;<br>//normal getters e setters<br>}<br>[/java]<br>Nada de novo certo? Mais uma classe burra sem lÃ³gica de negÃ³cio alguma! Pois bem, seguindo o padrÃ£o Active Record, essa classe deveria "saber" como se persistir, delegando a real lÃ³gica para um <em>Repository</em>, que nada mais Ã© que uma espÃ©cie de DAO. Desta forma, a classe que acabei de mostrar ficaria parecida com isso:<br><br>[java]<br>public class Usuario {<br>private String login;<br>private String senha;<br>// getters e setters<br><br>private Repository repo;<br><br>public void setRepository(Repository repo) {<br>this.repo = repo;<br>}<br><br>public void save();<br>public void update();<br>public void delete();<br><br>}<br>[/java]<br><br>A variÃ¡vel repo seria injetada pelo Spring, evitando assim qualquer cÃ³digo de lookup na classe UsuÃ¡rio. PorÃ©m, como vocÃª espera carregar um usuÃ¡rio previamente cadastrado no banco de dados? Recorrendo a um DAO padrÃ£o no cÃ³digo cliente - um faÃ§ade por exemplo ?<br><br>AÃ­ tudo que foi feito teria sido em vÃ£o! Se a classe sabe como se persistir, deve prover meios de se carregar objetos do seu repositÃ³rio da mesma forma, isolando totalmente detalhes de implementaÃ§Ã£o do cÃ³digo cliente. E aÃ­ comeÃ§am os problemas.<br><br>Vamos Ã  terceira versÃ£o de nossa classe:<br><br>[java]<br>public class Usuario {<br>private String login;<br>private String senha;<br>// getters e setters<br><br>private Repository repo;<br><br>public void setRepository(Repository repo) {<br>this.repo = repo;<br>}<br><br>public void save();<br>public void update();<br>public void delete();<br><br>public static Collection<usuario></usuario> findByLogin(String login) {<br>return this.repo.findByLogin(login);<br>}<br>[/java]<br><br>Ora ora ora! Espera aÃ­! Um mÃ©todo estÃ¡tico acessando uma variÃ¡vel de instÃ¢ncia?!? NÃ£o pode! E isso me tirou o sono! Como Ã© que eu vou injetar uma dependÃªncia num objeto se eu preciso dela antes mesmo de ter uma instÃ¢ncia do mesmo?<br><br>Uma maneira, porca, de se resolver isso seria alterando a variÃ¡vel repo para static e inicializando-a num bloco static, assim:<br><br>[java]<br>static {<br>repo = new Usuario().getRepo();<br>}<br>[/java]<br><br>Dois problemas com isso: Eu exponho meu dao para o mundo - tÃ¡, posso resolver alterando o modificador de acesso do mÃ©todo - e instancio um novo objeto Ãºnica e exclusivamente para pegar o DAO que o Spring injetou e joga-lo fora.<br><br>Soa estranho nÃ£o? E Ã©! NÃ£o queria ter que fazer isso. Funciona, mas Ã© feio e tosco! E agora vem mais um motivo da minha lista de coisas que eu amo no Spring! A classe <em>MethodInvokingFactoryBean</em>!<br><br>SÃ£o poucas linhas de configuraÃ§Ã£o no arquivo do contexto da aplicaÃ§Ã£o:<br><br>[xml]<br><bean id="userConfigurer" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"></bean><br><br><property value="Usuario.setRepository" name="staticMethod"></property><br><property ref="userRepo" name="arguments"></property><!-- userRepo Ã© apenas um bean comum configurado em algum ponto do arquivo, que representa o repositÃ³rio de usuÃ¡rios--><br><!-- bean-->[/xml]Dessa forma, na inicializaÃ§Ã£o do container de InversÃ£o de controle, a classe usuÃ¡rio jÃ¡ teria sua variÃ¡vel estÃ¡tica inicializada e, como nÃ£o Ã© proibido usar uma variÃ¡vel estÃ¡tica a partir de um mÃ©todo de instÃ¢ncia, os mÃ©todos save(), update() e delete() jÃ¡ estariam com suas vidas resolvidas tambÃ©m, usando o mesmo repositÃ³rio que foi inicializado no carregamento do container!Acho que fica uma soluÃ§Ã£o limpa, elegante e nÃ£o te faz abrir mÃ£o dos benefÃ­cios da inversÃ£o de controle e do padrÃ£o Active Record.Desculpem o primeiro post! Ficou meio grande nÃ©? Mas espero que tenha ficado legal! Um grande abraÃ§o e atÃ© a prÃ³xima!
</p>



]]></content>
  </entry>
  
</feed>
