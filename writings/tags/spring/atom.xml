<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | Leonardo Borges]]></title>
  <link href="http://www.leonardoborges.com/writings/tags/spring/atom.xml" rel="self"/>
  <link href="http://www.leonardoborges.com/writings/"/>
  <updated>2018-02-19T20:38:30+11:00</updated>
  <id>http://www.leonardoborges.com/writings/</id>
  <author>
    <name><![CDATA[Leonardo Borges]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring 2.5: Dependency Injection that doesn't hurt]]></title>
    <link href="http://www.leonardoborges.com/writings/2007/12/07/spring-25-dependency-injection-that-doesnt-hurt/"/>
    <updated>2007-12-07T00:00:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2007/12/07/spring-25-dependency-injection-that-doesnt-hurt</id>
    <content type="html"><![CDATA[<p>
<a href="http://martinfowler.com/articles/injection.html">Dependency injection</a> - <a href="http://martinfowler.com/articles/injection.html">DI</a>Â - Â is a great thing. Really. The hability to tweak implementations without touching your code is awesome and the DI frameworks, like spring, saves you a lot of coding. No more service locators stuff.<br><br>But, and there is always a but, you're left with a bunch of XML configuration. And I hate it. Not that XML files are bad... the thing is that everything nowadays has its own set of XML configurarion files. And <a href="http://www.springframework.org">Spring</a> is not different.<br><br><!--more--><br><br>Let's take a look at a simple example on how dependency injection is handled in Spring.<br><br>Imagine you have a domain object called Invoice that, among other things, is somewhat defined like this:<br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>You have a method to send a certain Invoice through e-mail, probably to some customer. This method would basically do some processing, maybe formatting strings, and then, ideally, delegate the send e-mail task to someone else. Probably a infrastructure service or something similar, that I will call EmailService. This object knows how to do the low level stuff like connecting to the SMTP server and so on. So we need this object, we <em>depend</em> on it.Â  To express this dependency, the Invoice code would change to this:<br><br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br>private EmailService emailService;<br>public void setEmailService(EmailService service) {<br>emailService = service;<br>}<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>This way the Invoice class is prepared to be injected with its only dependency using Spring. Now, what you would have to do is to declaratively express this dependency to the Spring container, so it can settle things for you. This is done through its XML configuration file, often called <em>applicationContext</em>. Below is the snippet of the file relevant to this example:<br><br>[xml]<br><br><bean id="invoice" class="com.leonardoborges.Invoice"><br><property name="emailService">Â  <ref bean="emailService"></ref></property><br></bean><br><br><bean id="emailService" class="com.leonardoborges.EmailService"></bean><br><br>[/xml]And that's it. Upon initialization Spring will use this XML file to discover that the Invoice object depends on the EMailService object and inject it using the setter method we created before.<br><br>The problem is: If we have 50 domain objects that depends on 10 service objects that depends on anything else, we would end up in a XML forrest with at least 60 bean definitions.<br>Of course you can break this creating smaller XML files, but they are stillÂ XML files with bean definitions. Well, with Spring 2.5 we have a better option: We can use annotations!<br>In this new release, Spring use its own set of annotations to resolve object dependencies without XML. Let's see how this thing works.<br><br>Our previous Invoice object would change to this:<br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br>@AutoWired<br>@Qualifier("myEmailService")<br>private EmailService emailService;<br>public void setEmailService(EmailService service) {<br>emailService = service;<br>}<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>Let's explain this change. The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Autowired.html">@AutoWired</a> annotation tells spring that it should automatically wire dependencies based on its type, in our case, EmailService. But we take it a step further and choose which object to inject based not only on its type, but based on its name, with the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Qualifier.html">@Qualifier</a> annotation.<br><br>Â Hmm... you may be asking now - But where did we say theÂ objectÂ name is myEmailService?<br><br>Â Okay, the other leg of the magic is on the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/stereotype/Component.html">@Component</a> annotation:<br><br>[java]<br>@Component("myEmailService")<br>public class EmailService {<br>//methods<br>}<br>[/java]<br><br>With this annotation, you register a new component available for injection within the Spring container. This way, you don't need to put neither the Invoice objects, nor its dependencies in the xml files. Pretty, huh?<br><br>But one question remains: How the hell spring knows about this annotated classes?<br>This is the one-million question and the answer is simple. You <em>do</em> need an XML file, but just to tell spring where to look for annotated classes, this way:<br><br>[xml]<br><annotation-config></annotation-config><br><component-scan base-package="br.com"></component-scan><br>[/xml]<br><br>The first clause sets the container to support annotation based configuration. The second one, component-scan, defines the base package where Spring should look for anotated classes within your project. That's how it will be able to discover who needs who and who is a eligible component for injection.<br><br>You are really left with a small, tiny, piece of XML. Much more clean, elegant and much less XML to type.
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eu odeio XML]]></title>
    <link href="http://www.leonardoborges.com/writings/2007/10/29/eu-odeio-xml/"/>
    <updated>2007-10-29T00:00:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2007/10/29/eu-odeio-xml</id>
    <content type="html"><![CDATA[<p>
Isso Ã© um fato. Cada linha de XML que eu escrevo me faz pensar em formas de evita-las. E isso nÃ£o Ã© simples.<br><br>Ultimamente, desde o Java 5, tem se trocado o XML pelas <a href="http://http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html" title="Java Annotations">annotations</a>. TÃ¡ bom, fica bonitinho nÃ©? AtÃ© que fica. Em alguns casos, atÃ© mais organizado. O <a href="http://www.hibernate.org/hib_docs/annotations/reference/en/html_single/" title="Hibernate Annotations">Hibernate</a> desde a versÃ£o 3 faz uso das <a href="http://java.sun.com/javaee/overview/faq/persistence.jsp" title="Java Persistence API">annotaions da JPA</a> como alernativa ao seu XML de configuraÃ§Ã£o. E esse sim Ã© um belo caso de sucesso!<br><br>SÃ£o apenas algumas anotaÃ§Ãµes na classe para mapea-la e pronto, adeus xml! Mas como sempre, as anotaÃ§Ãµes jÃ¡ estÃ£o sendo exageradas por aÃ­. Basta decidir configurar uns 3 frameworks - e provavelmente dois deles sÃ£o descenessÃ¡rios no seu projeto - usando anotaÃ§Ãµes e as suas classes ficarÃ£o uma zona! E muito mais ilegÃ­veis que um arquivo XML!<br><br>As anotaÃ§Ãµes sÃ£o recursos muito poderosos e devem ser usadas de forma consciente. Use as que realmente valem a pena, como as que vou falar agora, que fazem parte da nova release do Spring framework, a <a href="http://www.springframework.org/node/548" title="Spring 2.5 rc1">2.5 RC1</a>. <!--more--><br><br>O Spring Ã© - dentre outras coisas - um dos mais falados containeres de injeÃ§Ã£o de dependÃªncia nos dias de hoje. Esse mecanismo sempre funcionou da seguinte forma:<br><br>Imagine uma classe que atua como um <em>faÃ§ade</em>, digamos LocadoraFacade, que declara dependencia de um objeto DAO:<br><br>[java]<br>public class LocadoraFacade {<br>private DAO dao;<br>public void setDao(){}<br><br>public void incluirDvd(Dvd dvd){}<br>}<br>}<br>[/java]<br><br>No xml de configuraÃ§Ã£o do Spring, eu teria 2 beans registrados:<br>[xml]<br><bean id="locadoraFacade" class="com.leonardoborges.LocadoraFacade"></bean><br><br><property name="dao"><ref bean="dao"></ref></property><bean id="dao" class="com.leonardoborges.BaseDao"></bean><br>[/xml]Lindo nÃ£o? Agora multiplique essas entradas pelo nÃºmero de beans que vocÃª normalmente tem numa aplicaÃ§Ã£o. E nÃ£o esqueÃ§a das dependÃªncias de cada um desses beans. Imaginou?<br><br>Isso mesmo! Eca!<br><br>Existem formas de dar uma simplificada nesse XML, mas vou focar na forma que mais gosto, as novas anotaÃ§Ãµes @Component, @Autowired e @Qualifier. Com essas anotaÃ§Ãµes, seu arquivo de configuraÃ§Ã£o cai de centenas para apenas algumas linhas de XML! Vale a pena dar uma pesquisada, ou aguardar meu prÃ³ximo post, onde darei mais detalhes de como essas anotaÃ§Ãµes funcionam no contexto Spring.
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Como o Spring me ajudou a manter o Active Record]]></title>
    <link href="http://www.leonardoborges.com/writings/2007/10/13/como-o-spring-me-ajudou-a-manter-o-active-record/"/>
    <updated>2007-10-13T00:00:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2007/10/13/como-o-spring-me-ajudou-a-manter-o-active-record</id>
    <content type="html"><![CDATA[<p>
Nesse primeiro post vou falar um pouco sobre meu novo trabalho. Na verdade, sobre um problema que encontramos lÃ¡.<br><br>Dentre diversas coisas que estamos fazendo, como migraÃ§Ãµes por exemplo, estou ajudando na elaboraÃ§Ã£o da arquitetura que irÃ¡ abrigar as novas aplicaÃ§Ãµes desenvolvidas na empresa. <!--more-->Ã‰ uma tarefa desgastante e cada decisÃ£o Ã© crÃ­tica, indo de discussÃµes sobre qual tecnologia usar para MVC atÃ© como organizar o <em>layering</em> da aplicaÃ§Ã£o. Essa arquitetura compreende tambÃ©m o desenvolvimento de um <em>framework </em>para facilitar a vida dos novos desenvolvedores que integrarÃ£o a equipe.<br><br>Pois bem, uma das decisÃµes que tomei foi a de evitar o <a target="_blank" href="http://martinfowler.com/bliki/AnemicDomainModel.html" title="Anemic Domain Model"><em>Anemic Domain Model</em></a><em> </em>e usar o Spring<em> </em>como framework de <a target="_blank" href="http://martinfowler.com/bliki/InversionOfControl.html" title="IoC">IoC</a>.<em> </em>Os benefÃ­cios disso sÃ£o assunto para outro post. ;) E um outro padrÃ£o que ajuda nisso se chama <em><a target="_blank" href="http://martinfowler.com/eaaCatalog/activeRecord.html" title="Active Record">Active Record</a></em>. AÃ­ comeÃ§aram os problemas! Essa divisÃ£o de responsabilidades sempre agrega uma nova (nem tÃ£o nova assim) forma de pensar. Vou mostrar um exemplo para ilustrar isso.<br><br>[java]<br>public class Usuario {<br>private String login;<br>private String senha;<br>//normal getters e setters<br>}<br>[/java]<br>Nada de novo certo? Mais uma classe burra sem lÃ³gica de negÃ³cio alguma! Pois bem, seguindo o padrÃ£o Active Record, essa classe deveria "saber" como se persistir, delegando a real lÃ³gica para um <em>Repository</em>, que nada mais Ã© que uma espÃ©cie de DAO. Desta forma, a classe que acabei de mostrar ficaria parecida com isso:<br><br>[java]<br>public class Usuario {<br>private String login;<br>private String senha;<br>// getters e setters<br><br>private Repository repo;<br><br>public void setRepository(Repository repo) {<br>this.repo = repo;<br>}<br><br>public void save();<br>public void update();<br>public void delete();<br><br>}<br>[/java]<br><br>A variÃ¡vel repo seria injetada pelo Spring, evitando assim qualquer cÃ³digo de lookup na classe UsuÃ¡rio. PorÃ©m, como vocÃª espera carregar um usuÃ¡rio previamente cadastrado no banco de dados? Recorrendo a um DAO padrÃ£o no cÃ³digo cliente - um faÃ§ade por exemplo ?<br><br>AÃ­ tudo que foi feito teria sido em vÃ£o! Se a classe sabe como se persistir, deve prover meios de se carregar objetos do seu repositÃ³rio da mesma forma, isolando totalmente detalhes de implementaÃ§Ã£o do cÃ³digo cliente. E aÃ­ comeÃ§am os problemas.<br><br>Vamos Ã  terceira versÃ£o de nossa classe:<br><br>[java]<br>public class Usuario {<br>private String login;<br>private String senha;<br>// getters e setters<br><br>private Repository repo;<br><br>public void setRepository(Repository repo) {<br>this.repo = repo;<br>}<br><br>public void save();<br>public void update();<br>public void delete();<br><br>public static Collection<usuario></usuario> findByLogin(String login) {<br>return this.repo.findByLogin(login);<br>}<br>[/java]<br><br>Ora ora ora! Espera aÃ­! Um mÃ©todo estÃ¡tico acessando uma variÃ¡vel de instÃ¢ncia?!? NÃ£o pode! E isso me tirou o sono! Como Ã© que eu vou injetar uma dependÃªncia num objeto se eu preciso dela antes mesmo de ter uma instÃ¢ncia do mesmo?<br><br>Uma maneira, porca, de se resolver isso seria alterando a variÃ¡vel repo para static e inicializando-a num bloco static, assim:<br><br>[java]<br>static {<br>repo = new Usuario().getRepo();<br>}<br>[/java]<br><br>Dois problemas com isso: Eu exponho meu dao para o mundo - tÃ¡, posso resolver alterando o modificador de acesso do mÃ©todo - e instancio um novo objeto Ãºnica e exclusivamente para pegar o DAO que o Spring injetou e joga-lo fora.<br><br>Soa estranho nÃ£o? E Ã©! NÃ£o queria ter que fazer isso. Funciona, mas Ã© feio e tosco! E agora vem mais um motivo da minha lista de coisas que eu amo no Spring! A classe <em>MethodInvokingFactoryBean</em>!<br><br>SÃ£o poucas linhas de configuraÃ§Ã£o no arquivo do contexto da aplicaÃ§Ã£o:<br><br>[xml]<br><bean id="userConfigurer" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"></bean><br><br><property value="Usuario.setRepository" name="staticMethod"></property><br><property ref="userRepo" name="arguments"></property><!-- userRepo Ã© apenas um bean comum configurado em algum ponto do arquivo, que representa o repositÃ³rio de usuÃ¡rios--><br><!-- bean-->[/xml]Dessa forma, na inicializaÃ§Ã£o do container de InversÃ£o de controle, a classe usuÃ¡rio jÃ¡ teria sua variÃ¡vel estÃ¡tica inicializada e, como nÃ£o Ã© proibido usar uma variÃ¡vel estÃ¡tica a partir de um mÃ©todo de instÃ¢ncia, os mÃ©todos save(), update() e delete() jÃ¡ estariam com suas vidas resolvidas tambÃ©m, usando o mesmo repositÃ³rio que foi inicializado no carregamento do container!Acho que fica uma soluÃ§Ã£o limpa, elegante e nÃ£o te faz abrir mÃ£o dos benefÃ­cios da inversÃ£o de controle e do padrÃ£o Active Record.Desculpem o primeiro post! Ficou meio grande nÃ©? Mas espero que tenha ficado legal! Um grande abraÃ§o e atÃ© a prÃ³xima!
</p>



]]></content>
  </entry>
  
</feed>
