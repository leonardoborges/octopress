
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Leonardo Borges</title>
	<meta name="author" content="Leonardo Borges">

	
	<meta name="description" content="I&#8217;ve been learning Scala for my current client project and I find writing to be a great tool to test my understanding of any given topic. This &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="http://feeds.feedburner.com/leonardoborges" rel="alternate" title="Leonardo Borges" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/writings/favicon.png" rel="shortcut icon">
	<link href="/writings/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/writings/">Leonardo Borges</a></h1>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/writings/">Blog</a></li>
  <li><a href="/writings/about">About</a></li>
  <li><a href="/writings/projects">Projects</a></li>
  <li><a href="/writings/presentations">Talks</a></li>
  <li><a href="/writings/books">Books</a></li>
  <li><a href="/writings/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main-navigation">
  <li><a href="/writings/">Blog</a></li>
  <li><a href="/writings/about">About</a></li>
  <li><a href="/writings/projects">Projects</a></li>
  <li><a href="/writings/presentations">Talks</a></li>
  <li><a href="/writings/books">Books</a></li>
  <li><a href="/writings/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.leonardoborges.com/writings">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/leonardo_borges" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/leonardoborges" title="GitHub">GitHub</a>
		
		
		
		
		
		<a class="rss" href="http://feeds.feedburner.com/leonardoborges" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:www.leonardoborges.com/writings">
	</form>
</nav>

</header>
	
		
<!-- <div id="banner" class="inner"> -->
<!--     <div class="container"> -->
<!--         <ul class="feed"></ul> -->
<!--     </div> -->
<!--     <small><a href="http://twitter.com/leonardo_borges">leonardo_borges</a> @ <a href="http://twitter.com">Twitter</a></small> -->
<!--     <div class="loading">Loading...</div> -->
<!-- </div> -->
<!-- <script src="/writings/javascripts/twitter.js"></script> -->
<!-- <script type="text/javascript"> -->
<!--     (function($){ -->
<!--         $('#banner').getTwitterFeed('leonardo_borges', 4, false); -->
<!--     })(jQuery); -->
<!-- </script> -->


	
	<div id="content" class="inner">


    <article class="post">
	<h1 class="title"><a href="/writings/2014/06/17/functional-composition-with-monads-kleisli-functors/">Functional Composition With Monads, Kleislis and Functors</a></h1>
	<div class="entry-content">
		<p>I&#8217;ve been learning Scala for my current client project and I find writing to be a great tool to test my understanding of any given topic. This means there might be a few Scala posts coming up soon as I keep learning interesting things.</p>

<p>Today I&#8217;ll be exploring a few different ways in which you can compose programs. I&#8217;ll be using <a href="https://github.com/scalaz/scalaz">Scalaz</a> in this post.</p>

<p>The examples that follow all deal with Vehicles - more specifically makes and parts:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">import</span> <span class="nn">scalaz._</span><span class="o">,</span> <span class="nc">Scalaz</span><span class="o">.</span><span class="k">_</span>
</span><span class='line'>  <span class="k">import</span> <span class="nn">scalaz.Kleisli._</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">Make</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">Part</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Next we have a couple of functions which interact with these case classes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">val</span> <span class="n">make</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nc">Make</span> <span class="k">=</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Make</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Suzuki&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">parts</span><span class="k">:</span> <span class="kt">Make</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Part</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Make</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Part</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Gear Box&quot;</span><span class="o">),</span> <span class="nc">Part</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;Clutch cable&quot;</span><span class="o">))</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we have a function from <code>Int</code> to <code>Make</code> and then a function from <code>Make</code> to <code>List[Part]</code>. From set theory we know this implies we must have a function from <code>Int</code> to <code>List[Part]</code>. This is nothing more than simple function composition:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="n">parts</span> <span class="n">compose</span> <span class="n">make</span>
</span><span class='line'>  <span class="n">f</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="c1">// List[Part] = List(Part(1,Gear Box), Part(2,Clutch cable))</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">// alternatively you can use &#39;andThen&#39; which works like compose, but with the arguments flipped:</span>
</span><span class='line'> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">make</span> <span class="n">andThen</span> <span class="n">parts</span>
</span><span class='line'> <span class="n">g</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'> <span class="c1">// List[Part] = List(Part(1,Gear Box), Part(2,Clutch cable))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Pretty boring stuff.</p>

<p>A more realistic example accounts for failure in our functions. One way we can encode this is using the <code>Option</code> data type:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">make</span>  <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">).</span><span class="n">option</span><span class="o">(</span><span class="nc">Make</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Suzuki&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Make</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>  <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span><span class="o">).</span><span class="n">option</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="nc">Part</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Gear Box&quot;</span><span class="o">),</span> <span class="nc">Part</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;Clutch cable&quot;</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now we have a function <code>make: Int =&gt; Option[Make]</code> and a function <code>parts: Make =&gt; Option[NonEmptyList[Part]]</code>. Based on our first example we should have a way to create a function from <code>Int</code> to <code>Option[NonEmptyList[Part]]</code>. This isn&#8217;t immediately obvious however.</p>

<p>While <code>make</code> does return a <code>Make</code>, it is wrapped inside an <code>Option</code> so we need to account for a possible failure. This leads to our first attempt:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Make</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Part</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">parts</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">f</span> <span class="n">compose</span> <span class="n">make</span>
</span><span class='line'>  <span class="n">g</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// Some(NonEmptyList(Part(1,Gear Box), Part(2,Clutch cable)))  </span>
</span></code></pre></td></tr></table></div></figure>


<p>While this works, we had to manually create the plumbing between the two functions.  You can imagine that with different return and input types, this plubming would have to be rewritten over and over.</p>

<p>All the function <code>f</code> above is doing is serving as an <em>adapter</em> for <code>parts</code>. It turns out there is a couple of ways in which this pattern can be generalised.</p>

<h2>Monadic bind</h2>

<p><code>Option</code> is a <a href="http://www.leonardoborges.com/writings/2012/12/08/monads-in-small-bites-part-iv-monads/">monad</a> so we can define <em>f</em> using a for comprehension:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">m</span> <span class="k">&lt;-</span> <span class="n">make</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class='line'>    <span class="n">p</span> <span class="k">&lt;-</span> <span class="n">parts</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="n">p</span>
</span><span class='line'>  <span class="n">f</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// Some(NonEmptyList(Part(1,Gear Box), Part(2,Clutch cable)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Which is simply syntactic sugar for:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="n">_:</span><span class="nc">Int</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="n">parts</span><span class="o">(</span><span class="n">m</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">))</span>
</span><span class='line'><span class="n">g</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="c1">// Some(NonEmptyList(Part(1,Gear Box), Part(2,Clutch cable)))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// you can also use the symbolic alias for &#39;bind&#39;, which makes it a lot nicer</span>
</span><span class='line'><span class="k">val</span> <span class="n">h</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="n">_:</span><span class="nc">Int</span><span class="o">)</span> <span class="o">&gt;&gt;=</span> <span class="n">parts</span>
</span><span class='line'><span class="n">h</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="c1">// Some(NonEmptyList(Part(1,Gear Box), Part(2,Clutch cable)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The reason this is better is that <code>make</code> and <code>parts</code> could operate under a different monad but the client code would not need to change. In the example below, we&#8217;re operating under the <code>List</code> monad:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">words</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">_</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;&quot;&quot;\s&quot;&quot;&quot;</span><span class="o">).</span><span class="n">toList</span>
</span><span class='line'><span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">_</span><span class="o">.</span><span class="n">toList</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">phrase</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">m</span> <span class="k">&lt;-</span> <span class="n">words</span><span class="o">(</span><span class="n">phrase</span><span class="o">)</span>
</span><span class='line'>  <span class="n">p</span> <span class="k">&lt;-</span> <span class="n">chars</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="n">p</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="o">(</span><span class="s">&quot;Motorcycles are fun to ride!&quot;</span><span class="o">)</span>
</span><span class='line'><span class="c1">// List(M, o, t, o, r, c, y, c, l, e, s, a, r, e, f, u, n, t, o, r, i, d, e, !)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// or even:</span>
</span><span class='line'><span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">words</span><span class="o">(</span><span class="n">_:</span><span class="nc">String</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">w</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="n">chars</span><span class="o">(</span><span class="n">w</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="o">))</span>
</span><span class='line'><span class="n">g</span><span class="o">(</span><span class="s">&quot;Motorcycles are fun to ride!&quot;</span><span class="o">)</span>
</span><span class='line'><span class="c1">// List(M, o, t, o, r, c, y, c, l, e, s, a, r, e, f, u, n, t, o, r, i, d, e, !)</span>
</span></code></pre></td></tr></table></div></figure>


<p>We used the exact same <em>for</em> comprehension syntax to compose these operations. This works because both <code>Option</code> and <code>List</code> are monads.</p>

<p>Notwithstanding, this still feels like unnecessary plumbing. All we are doing with the <em>for</em> comprehenstion / <code>flatMap</code> is extracting the values from their respective monads to simply put them back in. It would be nice if we could simply do something like <code>make compose parts</code> as we did in our first example.</p>

<h2>Kleisli Arrows</h2>

<p>A <a href="http://www.haskell.org/haskellwiki/Arrow_tutorial#Kleisli_Arrows">Kleisli arrow</a> is simply a <em>wrapper</em> for a function of type <code>A =&gt; F[B]</code>. This is the same type of the second argument to the monadic <em>bind</em> as <a href="https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Bind.scala#L16">defined</a> in Scalaz:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">bind</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>By creating a Kleisli arrow from a function, we are given a function that knows how to extract the value from a Monad <code>F</code> and feed it into the underlying function, much like bind does, but without actually having to do any binding yourself.</p>

<p>To use a concrete example, let&#8217;s create a kleisli arrow from our <code>parts</code> function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">kleisli</span><span class="o">(</span><span class="n">parts</span><span class="o">)</span>
</span><span class='line'><span class="c1">// scalaz.Kleisli[Option,Make,scalaz.NonEmptyList[Part]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>You can read this type as being a function which knows how to get a value of type <code>Make</code> from the <code>Option</code> monad and will ultimately return an <code>Option[NonEmptyList[Part]]</code>. Now you might be asking, why would we want to wrap our functions in a kleisli arrow?</p>

<p>By doing so, you have access to a number of useful functions defined in the Kleisli trait, one of which is <code>&lt;==&lt;</code> (aliased as <code>composeK</code>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="n">kleisli</span><span class="o">(</span><span class="n">parts</span><span class="o">)</span> <span class="o">&lt;==&lt;</span> <span class="n">make</span>
</span><span class='line'>  <span class="c1">// same as   kleisli(parts) composeK make</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">f</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// Some(NonEmptyList(Part(1,Gear Box), Part(2,Clutch cable)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This gives us the same result as the version using the <em>for</em> comprehension but with less work and with code that looks similar to simple function composition.</p>

<h2>Not there yet</h2>

<p>One thing that was bugging me is the return type for <code>parts</code> above:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Make</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Part</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Sure this works but since lists already represent non-deterministic results, one can make the point that the Option type there is reduntant since, for this example, we can treat both <code>None</code> and the empty List as the <em>absence of result</em>. Let&#8217;s update the code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">make</span>  <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">).</span><span class="n">option</span><span class="o">(</span><span class="nc">Make</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Suzuki&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">parts</span><span class="k">:</span> <span class="kt">Make</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Part</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Make</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Part</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Gear Box&quot;</span><span class="o">),</span> <span class="nc">Part</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;Clutch cable&quot;</span><span class="o">))</span>
</span><span class='line'>  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>It seems we&#8217;re in worse shape now! As before, <code>parts</code>&#8217;s input type doesn&#8217;t line up with <code>make</code>&#8217;s return type. Not only that, they aren&#8217;t even in the same monad anymore!</p>

<p>This clearly breaks our previous approach using a kleisli arrow to perform the composition. On the other hand it makes room for another approach: <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Functor</a> <em>lifting</em>.</p>

<h2>Lifting</h2>

<p>In Scala - and category theory - monads are <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">functors</a>. As such both <code>Option</code> and <code>List</code> have access to a set of useful functor combinators. The one we&#8217;re interested in is called <a href="https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Functor.scala#L31">lift</a>.</p>

<p>Say you have a function <code>A =&gt; B</code> and you have a functor <code>F[A]</code>. Lifting is the name of the operation that transforms the function  <code>A =&gt; B</code> into a function of type <code>F[A] =&gt; F[B]</code>.</p>

<p>This sounds useful. Here are our function types again:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">make</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Make</span><span class="o">]</span>
</span><span class='line'><span class="n">parts</span><span class="k">:</span> <span class="kt">Make</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Part</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can&#8217;t get a function <code>Int =&gt; List[Part]</code> because <code>make</code> returns an <code>Option[Make]</code> meaning it can fail. We need to propagate this possibility in the composition. We can however <em>lift</em> <code>parts</code> into the <code>Option</code> monad, effectively changing its type from <code>Make =&gt; List[Part]</code> to <code>Option[Make] =&gt; Option[List[Part]]</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">].</span><span class="n">lift</span><span class="o">(</span><span class="n">parts</span><span class="o">)</span> <span class="n">compose</span> <span class="n">make</span>
</span><span class='line'><span class="n">f</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="c1">// Some(List(Part(1,Gear Box), Part(2,Clutch cable)))</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>f</code> now has the type <code>Int =&gt; Option[List[Part]]</code> and we have once again successfully composed both functions without writing any plumbing code ourselves.</p>

<p><a href="https://twitter.com/markhibberd">Mark</a> pointed out to me that <code>lift</code> is pretty much the same as <code>map</code> but with the arguments reversed. So the example above can be more succintly expressed as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="n">_:</span><span class="nc">Int</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">parts</span><span class="o">)</span>
</span><span class='line'><span class="n">g</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="c1">// Some(List(Part(1,Gear Box), Part(2,Clutch cable)))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Summary</h2>

<p>If you are only now getting to this whole Functor/Monad/Kleisli <em>thing</em> this was probably quite heavy to get through. The point I am trying to make here is that learning at least <em>some</em> of the abstractions provided by Scalaz is certainly worthwhile. They encode common patterns which we would otherwise keep re-writing a lot of the time.</p>

<p>Special Thanks to <a href="https://twitter.com/markhibberd">Mark Hibberd</a> who kindly reviewed an early draft of this post.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-06-17T11:00:00+10:00" pubdate data-updated="true">Jun 17<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>, <a class='category' href='/writings/tags/scala/'>scala</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2014/01/04/validation-and-internationalization-in-clojure-with-bouncer-and-tower/">Validation and Internationalization in Clojure With Bouncer &amp; Tower</a></h1>
	<div class="entry-content">
		<p>I released <a href="https://github.com/leonardoborges/bouncer">bouncer</a> in April last year and since then it has had a small but steady growth in usage.</p>

<p>So much so that I received some community feedback in the form of emails and pull requests which is simply <em>great</em>!</p>

<p>The latest and most substantial pull request, submitted by <a href="https://github.com/dm3">Vadim Platonov</a>, added the ability to customise validation messages in anyway you like, as you can see in the section <a href="https://github.com/leonardoborges/bouncer#internationalization-and-customised-error-messages">Internationalization and customised error messages</a> of the <a href="https://github.com/leonardoborges/bouncer/blob/master/README.md">README</a>.</p>

<p>However the documentation only gives a simple example and while I believe it should show users how this opens up several different usage patterns, I thought I&#8217;d expand that in this post and integrate <a href="https://github.com/leonardoborges/bouncer">bouncer</a> with the excellent Internationalization library <a href="https://github.com/ptaoussanis/tower">tower</a> to show how validation and I18n could work together in this configuration.</p>

<blockquote><p>If you&#8217;ve never used bouncer before, I&#8217;d recommend you have a quick look at the <a href="https://github.com/leonardoborges/bouncer#basic-validations">Basic Validations</a> section of the <a href="https://github.com/leonardoborges/bouncer/blob/master/README.md">README</a> before continuing.</p></blockquote>

<h2>Setup</h2>

<p>The first thing you&#8217;ll need to do is create a new leiningen project and add both <a href="https://github.com/leonardoborges/bouncer">bouncer</a> and <a href="https://github.com/ptaoussanis/tower">tower</a> as dependencies in your <code>project.clj</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">[</span><span class="nv">bouncer</span> <span class="s">&quot;0.3.1-beta1&quot;</span><span class="p">]</span>
</span><span class='line'><span class="p">[</span><span class="nv">com</span><span class="o">.</span><span class="nv">taoensso/tower</span> <span class="s">&quot;2.0.1&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Next, in your <code>core</code> namespace - or wherever, really - require both libs and set up a dictionary to be used in the examples:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">ns</span> <span class="nv">bouncer+tower</span><span class="o">.</span><span class="nv">core</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">:require</span> <span class="p">[</span><span class="nv">taoensso</span><span class="o">.</span><span class="nv">tower</span> <span class="nv">:as</span> <span class="nv">tower</span>
</span><span class='line'>             <span class="nv">:refer</span> <span class="p">(</span><span class="nf">with-locale</span> <span class="nv">with-tscope</span> <span class="nv">t</span> <span class="nv">*locale*</span><span class="p">)]</span>
</span><span class='line'>            <span class="p">[</span><span class="nv">bouncer</span><span class="o">.</span><span class="nv">core</span> <span class="nv">:refer</span> <span class="p">[</span><span class="nv">validate</span><span class="p">]]</span>
</span><span class='line'>            <span class="p">[</span><span class="nv">bouncer</span><span class="o">.</span><span class="nv">validators</span> <span class="nv">:as</span> <span class="nv">v</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">my-tconfig</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:dev-mode?</span> <span class="nv">true</span>
</span><span class='line'>   <span class="nv">:fallback-locale</span> <span class="nv">:en</span>
</span><span class='line'>   <span class="nv">:dictionary</span>
</span><span class='line'>   <span class="p">{</span><span class="nv">:en</span>
</span><span class='line'>    <span class="p">{</span><span class="nv">:person</span>  <span class="p">{</span><span class="nv">:name</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;A person must have a name&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:age</span>  <span class="p">{</span><span class="nv">:number</span>   <span class="s">&quot;A person&#39;s age must be a number. You provided &#39;%s&#39;&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:address</span> <span class="p">{</span><span class="nv">:postcode</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;Missing postcode in address&quot;</span><span class="p">}}}</span>
</span><span class='line'>     <span class="nv">:missing</span>  <span class="s">&quot;&lt;Missing translation: [%1$s %2$s %3$s]&gt;&quot;</span><span class="p">}</span>
</span><span class='line'>    <span class="nv">:pt-BR</span>
</span><span class='line'>    <span class="p">{</span><span class="nv">:person</span>  <span class="p">{</span><span class="nv">:name</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;Atributo Nome para Pessoa é obrigatório.&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:age</span>  <span class="p">{</span><span class="nv">:number</span>   <span class="s">&quot;Atributo Idade para Pessoa deve ser um número. Valor recebido foi &#39;%s&#39;&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:address</span> <span class="p">{</span><span class="nv">:postcode</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;Endereço deve ter um código postal&quot;</span><span class="p">}}}</span>
</span><span class='line'>     <span class="nv">:missing</span>  <span class="s">&quot;&lt;Tradução ausente: [%1$s %2$s %3$s]&gt;&quot;</span><span class="p">}}})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Also, we need someting to validate so go ahead and create a map representing a person:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">person</span> <span class="p">{</span><span class="nv">:age</span> <span class="s">&quot;NaN&quot;</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Customising bouncer</h2>

<p>Since <code>0.3.1-beta1</code>, <a href="https://github.com/leonardoborges/bouncer">bouncer</a>&#8217;s <code>validate</code> function receives an optional first argument called <em>message-fn</em>. As the name implies, it is a function from <em>error metadata</em> to, most likely, a string. This is our opportunity to use tower&#8217;s features to translate our error messages.</p>

<p>In order to accomplish that, we&#8217;ll be using this message function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">message-fn</span>
</span><span class='line'>  <span class="s">&quot;Receives a locale, tscope and a map containing error metadata.</span>
</span><span class='line'>
</span><span class='line'><span class="s">  Uses this information to return a I18n&#39;ed string&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">locale</span> <span class="nv">tscope</span> <span class="p">{</span><span class="nv">:keys</span> <span class="p">[</span><span class="nv">path</span> <span class="nv">value</span><span class="p">]</span>
</span><span class='line'>                  <span class="p">{</span><span class="nv">validator</span> <span class="nv">:validator</span><span class="p">}</span> <span class="nv">:metadata</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">tr-key</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">flatten</span> <span class="p">[</span><span class="nv">path</span> <span class="nv">validator</span><span class="p">])</span>
</span><span class='line'>                    <span class="p">(</span><span class="nb">map </span><span class="nv">name</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">clojure</span><span class="o">.</span><span class="nv">string/join</span> <span class="s">&quot;/&quot;</span><span class="p">)</span>
</span><span class='line'>                    <span class="nv">keyword</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">with-tscope</span> <span class="nv">tscope</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">t</span> <span class="nv">locale</span> <span class="nv">my-tconfig</span> <span class="nv">tr-key</span> <span class="nv">value</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In order to understand the function above, let&#8217;s validate the person map using <code>identity</code> so we can inspect the error metadata that will be the third argument to this function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="nv">identity</span>
</span><span class='line'>          <span class="nv">person</span>
</span><span class='line'>          <span class="nv">:name</span> <span class="nv">v/required</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [{:name</span>
</span><span class='line'><span class="c1">;;   ({:path [:name],</span>
</span><span class='line'><span class="c1">;;     :value nil,</span>
</span><span class='line'><span class="c1">;;     :args nil,</span>
</span><span class='line'><span class="c1">;;     :metadata</span>
</span><span class='line'><span class="c1">;;     {:optional false,</span>
</span><span class='line'><span class="c1">;;      :default-message-format &quot;%s must be present&quot;,</span>
</span><span class='line'><span class="c1">;;      :validator :bouncer.validators/required},</span>
</span><span class='line'><span class="c1">;;     :message nil})}</span>
</span><span class='line'><span class="c1">;;  {:age &quot;NaN&quot;,</span>
</span><span class='line'><span class="c1">;;   :bouncer.core/errors</span>
</span><span class='line'><span class="c1">;;   {:name</span>
</span><span class='line'><span class="c1">;;    ({:path [:name],</span>
</span><span class='line'><span class="c1">;;      :value nil,</span>
</span><span class='line'><span class="c1">;;      :args nil,</span>
</span><span class='line'><span class="c1">;;      :metadata</span>
</span><span class='line'><span class="c1">;;      {:optional false,</span>
</span><span class='line'><span class="c1">;;       :default-message-format &quot;%s must be present&quot;,</span>
</span><span class='line'><span class="c1">;;       :validator :bouncer.validators/required},</span>
</span><span class='line'><span class="c1">;;      :message nil})}}]</span>
</span></code></pre></td></tr></table></div></figure>


<p>As we&#8217;re only validating the name in this case, that&#8217;s all we get in the return value of <code>validate</code>. However you can see how we have all sorts of useful information now - hopefully this makes the <code>message-fn</code> code above easier to understand.</p>

<h2>Take it for a spin</h2>

<p>We&#8217;re now ready for a couple of examples, using two different locales. Let&#8217;s get on with it:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">message-fn</span> <span class="nv">:en</span> <span class="nv">:person</span><span class="p">)</span>
</span><span class='line'>          <span class="nv">person</span>
</span><span class='line'>          <span class="nv">:name</span> <span class="nv">v/required</span>
</span><span class='line'>          <span class="nv">:age</span>  <span class="nv">v/number</span>
</span><span class='line'>          <span class="p">[</span><span class="nv">:address</span> <span class="nv">:postcode</span><span class="p">]</span> <span class="nv">v/required</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [{:address {:postcode (&quot;Missing postcode in address&quot;)},</span>
</span><span class='line'><span class="c1">;;   :age (&quot;A person&#39;s age must be a number. You provided &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;   :name (&quot;A person must have a name&quot;)}</span>
</span><span class='line'><span class="c1">;;  {:age &quot;NaN&quot;,</span>
</span><span class='line'><span class="c1">;;   :bouncer.core/errors</span>
</span><span class='line'><span class="c1">;;   {:address {:postcode (&quot;Missing postcode in address&quot;)},</span>
</span><span class='line'><span class="c1">;;    :age (&quot;A person&#39;s age must be a number. You provided &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;    :name (&quot;A person must have a name&quot;)}}]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now let&#8217;s get some messages in portuguese, shall we?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">message-fn</span> <span class="nv">:pt-BR</span> <span class="nv">:person</span><span class="p">)</span>
</span><span class='line'>          <span class="nv">person</span>
</span><span class='line'>          <span class="nv">:name</span> <span class="nv">v/required</span>
</span><span class='line'>          <span class="nv">:age</span>  <span class="nv">v/number</span>
</span><span class='line'>          <span class="p">[</span><span class="nv">:address</span> <span class="nv">:postcode</span><span class="p">]</span> <span class="nv">v/required</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [{:address {:postcode (&quot;Endereço deve ter um código postal&quot;)},</span>
</span><span class='line'><span class="c1">;;   :age</span>
</span><span class='line'><span class="c1">;;   (&quot;Atributo Idade para Pessoa deve ser um número. Valor recebido foi &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;   :name (&quot;Atributo Nome para Pessoa é obrigatório.&quot;)}</span>
</span><span class='line'><span class="c1">;;  {:age &quot;NaN&quot;,</span>
</span><span class='line'><span class="c1">;;   :bouncer.core/errors</span>
</span><span class='line'><span class="c1">;;   {:address {:postcode (&quot;Endereço deve ter um código postal&quot;)},</span>
</span><span class='line'><span class="c1">;;    :age</span>
</span><span class='line'><span class="c1">;;    (&quot;Atributo Idade para Pessoa deve ser um número. Valor recebido foi &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;    :name (&quot;Atributo Nome para Pessoa é obrigatório.&quot;)}}]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In case you&#8217;re too lazy to do this all from scratch, I created a github repo containing this example ready for you to play with. <a href="https://github.com/leonardoborges/bouncer-tower">Go get it</a>.</p>

<h2>Conclusion</h2>

<p>Hopefully this gives you a little taste of what you can do with the latest version of <a href="https://github.com/leonardoborges/bouncer">bouncer</a>. Remember this is but one of many ways you could integrate the library so get creative :)</p>

<p>Once again, thanks to <a href="https://github.com/dm3">Vadim Platonov</a> for submitting this pull request.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-01-04T19:00:00+11:00" pubdate data-updated="true">Jan 4<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2014/01/01/so-long-2013-year-highlights/">So Long 2013: Year Highlights</a></h1>
	<div class="entry-content">
		<p>I finally got some free time so sit down and write this post. I was travelling with my girlfriend around the state of
Victoria, Australia - mostly around the <a href="http://www.visitvictoria.com/Regions/great-ocean-road">Great Ocean Road</a>. I had an amazing time and it&#8217;s a trip
I highly recommend anyone do.</p>

<p>As for this year&#8217;s highlights, let&#8217;s get started:</p>

<h2>Clojure</h2>

<p><a href="http://www.meetup.com/clj-syd/">clj-syd</a> - the Sydney Clojure User Group - continues going strong and this is in great part thanks to the amazing community behind it.
You can have a look at our <a href="https://github.com/clj-syd/clj-syd/wiki/2013">wiki page for 2013</a> to see what we&#8217;ve been up to.</p>

<p>A major highlight is the fact that we brought <a href="https://twitter.com/ambrosebs">Ambrose Bonnaire-Sergeant</a> - creator of <a href="https://github.com/clojure/core.typed">core.typed</a> - to Sydney to give a talk on his creation. You can read a summary of the talk on <a href="https://mail.google.com/mail/u/0/#search/to%3Aclj-syd%40googlegroups.com/1428350a8e888375">our mailing list</a>.</p>

<p>On a more personal note I&#8217;ve been basically living in Melbourne for the past ~6 months working on a full-time Clojure project. I have learned a lot and can&#8217;t wait to share a whole lot with the group once I&#8217;m back in Sydney.</p>

<h2>Speaking</h2>

<p>I was fortunate enough to speak at a couple of really cool events this year as well as a few user group talks. Here they are:</p>

<ul>
<li><p><a href="http://www.slideshare.net/borgesleonardo/functional-reactive-programming-in-clojurescript">Functional Reactive Programming in Clojurescript</a> - LambdaJam, May 2013 - Brisbane, Australia</p></li>
<li><p><a href="http://www.slideshare.net/borgesleonardo/clojure-macros-workshop-lambdajam-2013-cufp-2013">Clojure macros workshop</a> - LambdaJam, May 2013 - Brisbane, Australia / CUFP, October 2013 - Boston, USA</p></li>
<li><p><a href="http://www.slideshare.net/borgesleonardo/intro-to-clojures-coreasync">Intro to core.async</a> - #cljsyd - Sydney, Australia &amp; #cljmelb - Melbourne, Australia</p></li>
</ul>


<p>I have also attended Clojure/West in Portland back in March. Great conference, great content and amazing people. I put together some slides with my notes <a href="http://www.slideshare.net/borgesleonardo/clojurewest-2013-in-30-mins">on SlideShare</a>.</p>

<h2>Books</h2>

<p>2013 was a great year for Clojure as we saw quite a few new books be released during the year. I&#8217;ll briefly mention a couple:</p>

<h4><a href="http://shop.oreilly.com/product/0636920029786.do">Clojure Cookbook</a></h4>

<p>As the authors describe it: <em>&#8220;Clojure Cookbook marks Clojure&#8217;s entry in O&#8217;Reilly&#8217;s prestigious Cookbook Series. The book will contain hundreds of real-world problems and solutions, ranging from basic utilities to rich web services to heavy data processing.&#8221;</em></p>

<p>I have contributed three recipes to this book so I&#8217;m quite happy to see them make it in. You can buy the early digital edition from <a href="http://shop.oreilly.com/product/0636920029786.do">O&#8217;Reilly&#8217;s website</a>.</p>

<p>The book is the main effort of authors <a href="https://twitter.com/levanderhart">Luke Vanderhart</a> and <a href="https://twitter.com/rkneufeld">Ryan Neufeld</a> with contributions from the Clojure community around the globe.
They&#8217;ve put together quite the selection.</p>

<h4><a href="http://clojurerecipes.net/">Clojure Recipes</a></h4>

<p>Shameless plug of one of #cljsyd&#8217;s regulars, <a href="https://twitter.com/juliansgamble">Julian Gamble</a>, who&#8217;s been working on this for a while. The book should be released at the end of January 2014 and I&#8217;m looking forward to it.</p>

<h4><a href="http://www.packtpub.com/clojure-high-performance-programming/book">Clojure High Performance Programming</a></h4>

<p>I&#8217;ve only just started reading it but I already like what I see enough to mention it here.</p>

<h2>Content</h2>

<p>Here&#8217;s the Top 3 posts from this blog in 2013:</p>

<ul>
<li><p><a href="http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/">Clojure and &#8216;Why Calculating Is Better Than Scheming&#8217;</a> - A fresh look at this popular paper by <a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> from a Clojure perspective.</p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2013/07/06/clojure-core-dot-async-lisp-advantage/">Clojure, core.async and the Lisp Advantage</a> - This year saw much excitement around Clojure&#8217;s <a href="https://github.com/clojure/core.async">core.async</a> library and this post gives a brief introduction as to what it&#8217;s all about.</p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2013/07/15/purely-functional-data-structures-in-clojure-red-black-trees/">Purely Functional Data Structures in Clojure: Red-Black Trees</a> - This post is from a series - though I only have two posts at the moment - about <a href="http://www.leonardoborges.com/writings/2013/07/15/purely-functional-data-structures-in-clojure-red-black-trees/">persistent data structures</a> in Clojure.</p></li>
</ul>


<h2>Non-tech news</h2>

<p>For those who know me my passion for sports - such as martial arts, rock climbing and strength training - is no secret and in 2013 I became a certified personal trainer in Australia. I did this mostly for personal development and to better my own training. The certification is already paying off. It was a great course.</p>

<p><strong>Happy new year! Here&#8217;s to an even better one ahead of us!</strong></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-01-01T23:45:00+11:00" pubdate data-updated="true">Jan 1<span>st</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/misc/'>misc</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2013/09/25/cufp-slash-icfp-2013/">CUFP/ICFP 2013</a></h1>
	<div class="entry-content">
		<p>I&#8217;m sitting in the Lobby of the Hilton in Boston and since my flight back to Australia isn&#8217;t for a few hours I thought I&#8217;d write my experience report while everything is still fresh in my mind.</p>

<p><img class="left" src="/writings/assets/images/posts/cufp2013-badge.jpg" width="318" height="400"></p>

<p><a href="http://cufp.org/">CUFP - Commercial Users of Functional Programming -</a> is a Workshop-like conference targeting the practically-minded functional programming community.</p>

<p>As it&#8217;s stated on their website, <em>&#8220;The CUFP workshop is a place where people can see how others are using functional programming to solve real world problems […]&#8221;</em>.</p>

<p>One of the things that make the event special is that it runs together with <a href="http://icfpconference.org/icfp2013/">ICFP - International Conference on Functional Programming</a> - which is an event on the far opposite side of the spectrum with language designers, professors, compiler implementors getting together and thinking about the future of their languages and fields. The diversity of the event is astonishing.</p>

<p>CUFP itself runs for three days and is divided into a traditional conference format day with several talks and two tutorial days.</p>

<p>I was there for all three days and on the last one I delivered my own tutorial about writing macros in Clojure - more on that later.</p>

<p>As far as the talks of day 1 go, someone already did a great job of summarising them. I highly recommend <a href="http://www.syslog.cl.cam.ac.uk/2013/09/22/liveblogging-cufp-2013/">you go read it</a>.</p>

<h3>Day 2</h3>

<p>In total there were 9 tutorials being offered - two of which made up a two-day Haskell tutorial. That&#8217;s the one I decided to attend.</p>

<p>In the instructions, the instructors mentioned that we could use an online Haskell IDE to follow the course should we choose not to install the Haskell platform on our laptops.</p>

<p>I decided to give it a go. The tool is called FP Haskell Center and has been developed by the awesome guys at <a href="https://www.fpcomplete.com">FP Complete</a>.</p>

<p>It&#8217;s important to note this is an online IDE - but the editor isn&#8217;t the only thing being offered though. The Haskell Centre offers a complete deployment solution as well - though I didn&#8217;t have the chance to play with it.</p>

<p>Back to the tutorial, I used the FP Haskell Centre for day one and it worked great as far as online IDEs go. Compilation and inspecting types do suffer from the round trip over the web and by the end of the day I was feeling a little frustrated with all the waiting. The tool is great and if they offered an offline version, I&#8217;m sure the experience would have been improved tenfold.</p>

<p>Day one was taught by <a href="http://www.well-typed.com/people/andres">Andres Löh</a> from <a href="http://www.well-typed.com/">Well-Typed</a>, a Haskell consultancy.</p>

<p>It was full of exercises in the various basics of Haskell such as expressions, functions, IO, pattern matching and even Monads. I had a lot of fun working through them and it reinforced my opinion about Haskell being as practical a language as any other - but with several advantages.</p>

<h3>Day 3</h3>

<p>Given my frustration with FP Haskell Center being a bit slow I decided to install the Haskell platform on my new laptop and configure emacs with haskell-mode. I was <em>much</em> happier with this setup. haskell-mode has a lot of nifty features that were extremely useful during the tutorial.</p>

<p>The second day of the Haskell tutorial gave way to <a href="http://community.haskell.org/~simonmar/">Simon Marlow</a>, a software engineer from Facebook UK and author of  <a href="http://community.haskell.org/~simonmar/pcph/">Parallel and Concurrent Programming in Haskell</a> - also available freely <a href="http://chimera.labs.oreilly.com/books/1230000000929/index.html">online</a>.</p>

<p>Not surprisingly, his half of the tutorial was about Concurrency. We started with several exercises on IO involving more Monadic functions that we hadn&#8217;t learned the previous day. We then moved on to study the basic Haskell concurrency constructs and primitives. All very interesting stuff.</p>

<p>If you have the chance to attend a tutorial by these guys, do yourself a favour and go for it.</p>

<h3>Day 3 - 2pm onwards</h3>

<p>Unfortunately I missed the second half of the second day as I, too, had to deliver my own tutorial/workshop.</p>

<p>Titled <em>&#8220;Bending Clojure to your will: Macros and Domain Specific Languages&#8221;</em>, the tutorial had participants work their way through several difference exercises aimed at teaching the various nuances of writing macros.</p>

<p>The tutorial has failing tests for all exercises so it&#8217;s dead easy to know when you have arrived at a solution - all participants seemed to have had a great time learning this stuff and I even saw a couple of positive tweets about it - I&#8217;m really happy with how everything went.</p>

<p>The best tweet though was the one saying that someone from the Haskell tutorial decided to switch to mine half-way through. So I see that as a win :) <a href="https://twitter.com/prasincs/status/382585215694413824">Here&#8217;s said tweet</a>.</p>

<p>I&#8217;ve <a href="https://github.com/leonardoborges/clojure-macros-workshop">pushed the exercises to github</a> should you want to try them by yourself. <a href="http://www.slideshare.net/borgesleonardo/clojure-macros-workshop-lambdajam-2013-cufp-2013">Slides are also available</a> though they will likely not make sense out of context.</p>

<p>Enjoy! :)</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-09-25T13:17:00+10:00" pubdate data-updated="true">Sep 25<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>, <a class='category' href='/writings/tags/haskell/'>haskell</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2013/07/15/purely-functional-data-structures-in-clojure-red-black-trees/">Purely Functional Data Structures in Clojure: Red-Black Trees</a></h1>
	<div class="entry-content">
		<blockquote><p>This post is part of a series about Chris Okasaki&#8217;s <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a>. You can see all posts in the series by visiting the <a href="http://www.leonardoborges.com/writings/tags/functional-data-structures/">functional-data-structures</a> category in this blog.</p></blockquote>

<hr />

<p>Recently I had some free time to come back to <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a> and implement a new data structure: <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-black trees</a>.</p>

<h3>Red-black trees</h3>

<p><a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-black trees</a> are a type of <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">self-balancing binary search tree</a>. Back when I first learned the balancing algorithm used in operations such as insert and delete, I remember it being a particularly tricky one.</p>

<p>Traditionally, red-black trees are implemented destructively - meaning insertions and deletions happen in place. So in imperative languages like C or Java there is a lot of node pointer manipulation floating around, making this algorithm error prone.</p>

<p>This post, as its title implies, will deal with the functional implementation which, besides simpler, is also persistent.</p>

<h4>Invariants</h4>

<p>A big disadvantage of binary search trees is that they operate poorly on sorted data with O(N) worst case, pretty much becoming nothing more than a linked list.</p>

<p>This is where Red-black trees come in: when inserting/removing new nodes, the tree balances itself thus guaranteeing search times of O(logN). It does so by satisfying two invariants:</p>

<ul>
<li>No red nodes can have red children</li>
<li>Every path from the root to an empty node contains the same number of black nodes</li>
</ul>


<p>The image below - taken from the book itself - concisely summarises the 4 cases involved in these invariants, starting at the top and then moving counter-clockwise.</p>

<p><img class="center" src="/writings/assets/images/posts/red-black-tree.jpg" width="250" height="333" title="Red-black trees invariants" ></p>

<p>With this in mind I set out to write the <em>balance</em> function in Clojure.</p>

<h3>The code</h3>

<p>In the functional version of a Red-black tree all pointer manipulation required in its destructive counterpart simply disappears, rendering the algorithm a lot simpler.</p>

<p>Nevertheless, we&#8217;re left with some complexity in the <em>balance</em> function around testing a node&#8217;s colour as well as its children&#8217;s and grandchildren&#8217;s.</p>

<p>My first attempt at writing it started like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">mk-tree</span> <span class="p">[</span><span class="nv">color</span> <span class="nv">left</span> <span class="nv">value</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:color</span> <span class="nv">color</span> <span class="nv">:left</span> <span class="nv">left</span> <span class="nv">:value</span> <span class="nv">value</span> <span class="nv">:right</span> <span class="nv">right</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>    <span class="c1">;; case 1</span>
</span><span class='line'>    <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nv">z</span> <span class="nv">:value</span> <span class="nv">d</span> <span class="nv">:right</span><span class="p">}</span> <span class="nv">tree</span>
</span><span class='line'>          <span class="p">{</span><span class="nv">x-color</span> <span class="nv">:color</span> <span class="nv">x</span> <span class="nv">:value</span> <span class="nv">a</span> <span class="nv">:left</span><span class="p">}</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">tree</span> <span class="nv">:left</span><span class="p">)</span>
</span><span class='line'>          <span class="p">{</span><span class="nv">y-color</span> <span class="nv">:color</span> <span class="nv">y</span> <span class="nv">:value</span> <span class="nv">b</span> <span class="nv">:left</span> <span class="nv">c</span> <span class="nv">:right</span><span class="p">}</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">tree</span> <span class="nv">:left</span> <span class="nv">:right</span><span class="p">)</span>
</span><span class='line'>          <span class="nv">d</span> <span class="p">(</span><span class="nf">:right</span> <span class="nv">tree</span><span class="p">)]</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">x-color</span> <span class="nv">:red</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">y-color</span> <span class="nv">:red</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:red</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                    <span class="nv">y</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>        <span class="nv">tree</span><span class="p">)</span>
</span><span class='line'>        <span class="o">...</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>I was extremely unhappy with this. A lot of boilerplate around bindings and tests. And this is only the first case.</p>

<p>But if you read Okasaki&#8217;s implementation of the algorithm in ML - or Haskell -  you&#8217;ll quickly realise how concise and elegant it is. The main reason for that is pattern matching, something we don&#8217;t have built-in in Clojure.</p>

<p>However, Clojure is a Lisp and has a powerful macros system at its disposal. That has given us <a href="https://github.com/clojure/core.match">core.match</a>, a pattern matching library for Clojure.</p>

<h4>core.match</h4>

<p>Using core.match, I rewrote my <em>balance</em> function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">match</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>         <span class="p">[(</span><span class="nf">:or</span> <span class="p">{</span><span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                       <span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span> <span class="nv">:left</span> <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span> <span class="nv">:right</span> <span class="nv">b</span><span class="p">}</span>
</span><span class='line'>                       <span class="nv">:value</span> <span class="nv">y</span> <span class="nv">:right</span> <span class="nv">c</span><span class="p">}</span>
</span><span class='line'>                <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>               <span class="p">{</span><span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                       <span class="nv">:left</span>  <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span>
</span><span class='line'>                       <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span> <span class="nv">:value</span> <span class="nv">y</span> <span class="nv">:left</span> <span class="nv">b</span> <span class="nv">:right</span> <span class="nv">c</span><span class="p">}}</span>
</span><span class='line'>                <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>               <span class="p">{</span><span class="nv">:left</span> <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span>
</span><span class='line'>                <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                        <span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                               <span class="nv">:left</span> <span class="nv">b</span> <span class="nv">:value</span> <span class="nv">y</span> <span class="nv">:right</span> <span class="nv">c</span><span class="p">}</span>
</span><span class='line'>                        <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}}</span>
</span><span class='line'>
</span><span class='line'>               <span class="p">{</span><span class="nv">:left</span> <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span>
</span><span class='line'>                <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                        <span class="nv">:left</span> <span class="nv">b</span> <span class="nv">:value</span> <span class="nv">y</span>
</span><span class='line'>                        <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                                <span class="nv">:left</span> <span class="nv">c</span> <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}}})]</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:red</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                     <span class="nv">y</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>         <span class="nv">:else</span> <span class="nv">tree</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you look closely at the patterns being matched, you&#8217;ll see they cater for all 4 cases and allow for both matching and binding in the same expressions. With only a little over double the size of a single case using the previous function, we now have a fully functioning <em>balance</em> implementation. This is better, but I wanted more.</p>

<p>What I really wanted to be able to write is this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">match</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>           <span class="p">[(</span><span class="nf">:or</span> <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>                 <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">b</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))))]</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                                                              <span class="nv">y</span>
</span><span class='line'>                                                              <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>                 <span class="nv">:else</span> <span class="nv">tree</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Unfortunately core.match doesn&#8217;t support records/protocols yet. However, while reading core.match&#8217;s source code, I found a test that implemented the balance algorithm using a different way of representing a tree.</p>

<p>You see, I went with the map approach because I like how you can ask for the specific keys that represent the parts of the tree, such as <em>:color</em>, <em>:left</em>, <em>:value</em> and <em>:right</em>. But if you&#8217;re happy with using positional elements in a vector to represent your tree, our <em>balance</em> function in Clojure becomes this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">match</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>         <span class="p">[(</span><span class="nf">:or</span> <span class="p">[</span><span class="nv">:black</span> <span class="p">[</span><span class="nv">:red</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">]</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">]</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]</span>
</span><span class='line'>               <span class="p">[</span><span class="nv">:black</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">]]</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]</span>
</span><span class='line'>               <span class="p">[</span><span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">[</span><span class="nv">:red</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">]</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]]</span>
</span><span class='line'>               <span class="p">[</span><span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">b</span> <span class="nv">y</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]]])]</span> <span class="p">[</span><span class="nv">:red</span> <span class="p">[</span><span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">]</span>
</span><span class='line'>                                                            <span class="nv">y</span>
</span><span class='line'>                                                            <span class="p">[</span><span class="nv">:black</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]]</span>
</span><span class='line'>               <span class="nv">:else</span> <span class="nv">tree</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Which is <em>amazingly</em> similar to the protocols/records version above.</p>

<p>I guess one of the lessons here is that by carefully choosing the data structure to represent your problem, your implementation can become substantially simpler.</p>

<p>As usual, <a href="https://github.com/leonardoborges/purely-functional-data-structures">all code is on github</a>, with the Red-black tree specific section in <a href="https://github.com/leonardoborges/purely-functional-data-structures/blob/master/src/purely_functional_data_structures/ch3.clj#L384">this direct link</a>. The project also includes tests.</p>

<p>Until next time.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-07-15T21:42:00+10:00" pubdate data-updated="true">Jul 15<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/functional-data-structures/'>functional-data-structures</a>, <a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2013/07/06/clojure-core-dot-async-lisp-advantage/">Clojure, core.async and the Lisp Advantage</a></h1>
	<div class="entry-content">
		<p>Long gone are the days when systems needed to do only one thing at a time.</p>

<p>Concurrency is the word but it often leads to complex code, dealing with locks, mutexes etc…</p>

<p>There are several different abstractions which allows us to both model and think about asynchronous code in a more sane fashion: futures, promises and events/callbacks are but a few of them.</p>

<p>I won&#8217;t get into the merits - or lack thereof - of these alternatives in this post but rather focus on a different alternative: <a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes - CSP</a>.</p>

<h3>CSP and Go</h3>

<p>CSP isn&#8217;t new. It was first described in 1978 by <a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a> and languages such as <a href="http://bit.ly/14rEwxU">Occam</a> and <a href="http://bit.ly/14rEAh7">Erlang</a> stem from it.</p>

<p>It has however gained momentum by being natively supported by the <a href="http://bit.ly/11ZvMzj">Go programming language</a>.</p>

<p>I haven&#8217;t read Hoare&#8217;s paper so I&#8217;ll use a little bit of what I know about Go&#8217;s implementation of CSP.</p>

<p>Go introduced the concept of a <code>goroutine</code>. It <em>looks</em> like a function call:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// doing some stuff...</span>
</span><span class='line'><span class="k">go</span> <span class="n">myFunction</span><span class="p">(</span><span class="s">&quot;argument&quot;</span><span class="p">)</span> <span class="c1">//does stuff in the background...</span>
</span><span class='line'><span class="c1">//continuing about my business...</span>
</span></code></pre></td></tr></table></div></figure>


<p>What this does is it creates a <em>lightweight</em> process and returns control immediately to the caller.</p>

<p>It is <em>lightweight</em> because it doesn&#8217;t map 1-1 to native OS threads.</p>

<p>The reasoning behind it is that creating too many threads can bring your machine (or VM) down due to the amount of stack allocated to each one.</p>

<p><code>goroutines</code> are cheap to create so you can have hundreds of thousands of them, and the runtime will multiplex them into a thread pool.</p>

<p>The immediate advantage is that it is dead simple to achieve a higher degree of concurrency.</p>

<p>So far it sounds awfully similar to using futures with a pre-configured thread pool and a bit of syntactic sugar. But this is not the end of it.</p>

<h3>Communication</h3>

<p><code>goroutines</code> really shine when your several lightweight processes need to talk to each other. This is where a new abstraction comes into play:<code>channels</code>.</p>

<p>Channels are first-class citizens - meaning you can pass them as arguments to functions as well as the return value of functions.</p>

<p>Using them is straightforward:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="n">c</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="nb">string</span><span class="p">)</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">time</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">Duration</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
</span><span class='line'>  <span class="n">c</span> <span class="p">&lt;-</span> <span class="s">&quot;Leo&quot;</span>
</span><span class='line'><span class="p">}()</span>
</span><span class='line'><span class="n">fmt</span><span class="p">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">&quot;Hello: %s\n&quot;</span><span class="p">,</span> <span class="p">&lt;-</span><span class="n">c</span><span class="p">)</span> <span class="c1">//this will block until the channel has something to give us </span>
</span></code></pre></td></tr></table></div></figure>


<p>The code above creates a goroutine from an anonymous-executing function that will, in the background, sleep for 5 seconds and then send the string <code>Leo</code> to the channel <code>c</code>. Since control is returned immediately after that, the call blocks on the next line where it&#8217;s trying to read a value from the channel using the <code>&lt;-c</code> statement.</p>

<h3>Lisp</h3>

<p>&#8220;But What does all this have to do with Lisp?&#8221; - ah! I&#8217;m glad you asked.</p>

<p>It actually has more to do with <a href="http://clojure.org/">Clojure</a> - and by extension, Lisp.</p>

<p><a href="http://clojure.org/">Clojure</a> is a modern Lisp for the JVM, built for concurrency. The core team recently released <a href="https://github.com/clojure/core.async">core.async</a>, a new library that adds support for asynchronous programming much in the same way Go does with goroutines.</p>

<p>To highlight the similarities, I&#8217;ll show and translate a couple of the examples from Rob Pike&#8217;s presentation, <a href="http://talks.golang.org/2012/concurrency.slide#1">Go Concurrency patterns</a>.</p>

<h4>Setting the scene</h4>

<p>Say you&#8217;re Google. And you need to write code that takes user input, - a search string - hits 3 different search services, - web, images and video - aggregates the results and presents them to the user.</p>

<p>Since they are three different services, you wish to do this concurrently.</p>

<p>To simulate these services, Rob presented a function that has unpredictable performance based of a random amount of sleep, shown below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="k">var</span> <span class="p">(</span>
</span><span class='line'>    <span class="n">Web</span>   <span class="p">=</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="s">&quot;web&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Image</span> <span class="p">=</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="s">&quot;image&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Video</span> <span class="p">=</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="s">&quot;video&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">type</span> <span class="n">Search</span> <span class="k">func</span><span class="p">(</span><span class="n">query</span> <span class="nb">string</span><span class="p">)</span> <span class="n">Result</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="n">kind</span> <span class="nb">string</span><span class="p">)</span> <span class="n">Search</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">query</span> <span class="nb">string</span><span class="p">)</span> <span class="n">Result</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">time</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="p">.</span><span class="n">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
</span><span class='line'>              <span class="k">return</span> <span class="n">Result</span><span class="p">(</span><span class="n">fmt</span><span class="p">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">&quot;%s result for %q\n&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">query</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is one way we could write such function in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">fake-search</span> <span class="p">[</span><span class="nv">kind</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">query</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">lang</span><span class="o">.</span><span class="nv">Math/random</span><span class="p">)</span> <span class="mi">1000</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">str </span><span class="nv">kind</span> <span class="s">&quot; result for &quot;</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">web</span>   <span class="p">(</span><span class="nf">fake-search</span> <span class="s">&quot;Web&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">image</span> <span class="p">(</span><span class="nf">fake-search</span> <span class="s">&quot;Image&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">video</span> <span class="p">(</span><span class="nf">fake-search</span> <span class="s">&quot;Video&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Google Search 2.0</h4>

<p>The first example is the simple case: we hit the services concurrently, wait for them to respond and then return the results:</p>

<blockquote><p>This example is from <a href="http://talks.golang.org/2012/concurrency.slide#46">slide #46</a>.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="k">func</span> <span class="n">Google</span><span class="p">(</span><span class="n">query</span> <span class="nb">string</span><span class="p">)</span> <span class="p">(</span><span class="n">results</span> <span class="p">[]</span><span class="n">Result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">)</span>
</span><span class='line'>    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Web</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Image</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Video</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">result</span> <span class="p">:=</span> <span class="p">&lt;-</span><span class="n">c</span>
</span><span class='line'>        <span class="n">results</span> <span class="p">=</span> <span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And here&#8217;s the Clojure version:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">google2-0</span> <span class="p">[</span><span class="nv">query</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">web</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">image</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">video</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">results</span> <span class="nv">_</span><span class="p">]</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">conj </span><span class="nv">results</span> <span class="p">(</span><span class="nf">&lt;!!</span> <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">c</span><span class="p">)))))</span>
</span><span class='line'>            <span class="p">[]</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">google2-0</span> <span class="s">&quot;Clojure&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; prints [&quot;Video result for Clojure&quot; &quot;Web result for Clojure&quot; &quot;Image result for Clojure&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <a href="http://clojure.github.io/core.async/#clojure.core.async/%3E!"><code>&gt;!</code></a> operator puts a value into a channel inside a <code>go</code> form. The function then uses <a href="http://clojure.github.io/core.async/#clojure.core.async/&lt;!!"><code>&lt;!!</code></a> to block on the <code>c</code> channel until it gets a value we can use.</p>

<h4>Google Search 2.1</h4>

<p>This is virtually the same example but this time we do not wish to wait on slow servers. So we&#8217;ll return whatever results we have after a pre-defined timeout.</p>

<blockquote><p>This example is from <a href="http://talks.golang.org/2012/concurrency.slide#47">slide #47</a>.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="n">c</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">)</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Web</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Image</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Video</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">timeout</span> <span class="p">:=</span> <span class="n">time</span><span class="p">.</span><span class="n">After</span><span class="p">(</span><span class="mi">80</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">select</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">result</span> <span class="p">:=</span> <span class="p">&lt;-</span><span class="n">c</span><span class="p">:</span>
</span><span class='line'>        <span class="n">results</span> <span class="p">=</span> <span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">&lt;-</span><span class="n">timeout</span><span class="p">:</span>
</span><span class='line'>        <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="s">&quot;timed out&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span>
</span></code></pre></td></tr></table></div></figure>


<p>You&#8217;ll notice the use of <code>select</code> here.</p>

<p><code>select</code> waits on multiple channels and returns as soon as <em>any</em> of them has something to say.</p>

<p>The trick of this example is that one of these channels times out, at which point you get the message &#8220;timed out&#8221;, effectively moving on to the next iteration and ignoring that slow server(s) response.</p>

<p>We can express the same intent in Clojure as well:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">google2-1</span> <span class="p">[</span><span class="nv">query</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">t</span> <span class="p">(</span><span class="nf">timeout</span> <span class="mi">500</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">web</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">image</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">video</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">results</span> <span class="nv">_</span><span class="p">]</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">conj </span><span class="nv">results</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">alts!!</span> <span class="p">[</span><span class="nv">c</span> <span class="nv">t</span><span class="p">]))))</span>
</span><span class='line'>            <span class="p">[]</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">google2-1</span> <span class="s">&quot;Clojure&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; prints [&quot;Video result for Clojure&quot; nil nil]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Everything looks the same but we&#8217;re using <a href="http://clojure.github.io/core.async/#clojure.core.async/alts!!"><code>alts!!</code></a> to wait on the channels <code>c</code> and <code>t</code> (the timeout channel). This is analogous to Go&#8217;s <code>select</code> form in that it waits for any channel to receive a value or, in this case, to timeout.</p>

<p>Note the <code>nil</code> values. Those came from servers which did not respond in time and were simply ignored.</p>

<p>Effectively what this means is that each time you run this function you&#8217;ll likely get different results, depending on how long the <code>fake-search</code> function takes to run.</p>

<p>Amazing, huh?</p>

<h3>The big deal</h3>

<p>But here&#8217;s the <em>big deal</em> about this: although <a href="https://github.com/clojure/core.async">core.async</a> looks like it&#8217;s deeply integrated into the language, it is <em>just</em> a library!</p>

<p>It&#8217;s not a separate compiler. It&#8217;s not a new language. And it&#8217;s not a special version of Clojure.</p>

<p>Since Clojure supports macros - like all Lisps - the core team was able to create the syntax required to easily use <a href="https://github.com/clojure/core.async">core.async</a>. And that&#8217;s the beauty of it!</p>

<p><em>The Lisp advantage, once again.</em></p>

<h4>Clojure&#8217;s advantage</h4>

<p>Now one thing I haven&#8217;t mentioned is that Clojure is particularly well suited for this - and in a way even more so than Go: Clojure is opinionated and favours immutability.</p>

<p>That means that when using channels - and in fact any type of concurrent programming - you can safely share your data structures between concurrent units of work. Since they&#8217;re immutable, you can&#8217;t shoot yourself in the foot.</p>

<p>One last thing: <a href="https://github.com/clojure/core.async">core.async</a> states as one of its goals Clojurescript compatibility, bringing channel based concurrent programming to the browser. Exciting stuff.</p>

<h3>More on core.async</h3>

<p><a href="https://github.com/clojure/core.async">core.async</a> is still in alpha but you are encouraged to take it for a spin. Documentation is still lacking so I recommend you look at:</p>

<ul>
<li><a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">Rich&#8217;s blog post about it</a></li>
<li><a href="https://github.com/clojure/core.async">The source code on github</a></li>
<li><a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">The walkthrough namespace</a>, which showcases its features.</li>
</ul>


<p>Also, the full Clojure code I used here can be seen in <a href="https://gist.github.com/leonardoborges/5924461">this gist</a>.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-07-06T18:50:00+10:00" pubdate data-updated="true">Jul 6<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/concurrency/'>concurrency</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2013/04/11/functional-programmers-unite-lambdajam-down-under/">Functional Programmers Unite! LambdaJam Down Under</a></h1>
	<div class="entry-content">
		<p>I hinted at <a href="http://www.yowconference.com.au/lambdajam/">LambdaJam Australia</a> back in my <a href="http://www.leonardoborges.com/writings/2013/01/02/so-long-2012-year-highlights/">2012 Highlights post</a> and the dates are fast approaching so I thought appropriate to blog about it once more.</p>

<p><a href="http://www.yowconference.com.au/lambdajam/">YOW! LambdaJam</a> is a conference targeted at intermediate and advanced functional programmers and is organised in talks, jams and workshops.</p>

<ul>
<li><strong>Talks</strong> are the traditional format and are 30 minutes long;</li>
<li><strong>Workshops</strong> aim to introduce a specific subjects to attendees in great detail and are up to two hours long;</li>
<li><strong>Jams</strong> are hands-on sessions. Participants will be guided through pre-defined problems around a given subject/technology and encouraged to work through the solutions either by themselves or ideally as small groups. Jams are also 2 hours long;</li>
</ul>


<p>Sounds pretty amazing, doesn&#8217;t it?</p>

<p>If you&#8217;re still not convinced, check out the <a href="http://www.yowconference.com.au/lambdajam/Program.html">program</a>.</p>

<p>The conference will run for 2 days, May 16-17, in Brisbane. <a href="http://yowlambdajam2013.eventbrite.com.au/">Tickets are on sale</a>.</p>

<h3>Clojure</h3>

<p>Besides the conference itself, <a href="http://clojure.com/">Clojure/core</a> will be giving an Intro to Clojure workshop in Sydney, Melbourne and Brisbane. It&#8217;s a great opportunity to learn from the language maintainers.</p>

<p>If you&#8217;re attending the conference already, you&#8217;re in luck because there is a 20% off discount <a href="http://yowlambdajam2013.eventbrite.com.au/">on the link above</a> if you attend both the conference and the workshop.</p>

<p>In case you&#8217;d like to attend the workshops only, you can buy individual tickets for <a href="http://clojurecore-sydney.eventbrite.com.au/">Sydney</a>, <a href="http://clojurecore-melbourne.eventbrite.com.au/">Melbourne</a> and <a href="http://clojurecore-brisbane-eorg.eventbrite.com.au/">Brisbane</a>.</p>

<h3>Scala</h3>

<p><a href="http://tmorris.net/">Tony Morris</a> will also be delivering a Functional Programming in Scala workshop in Brisbane and 20% off combo tickets can be bought from the <a href="http://yowlambdajam2013.eventbrite.com.au/">EventBrite page for LambdaJam</a>.</p>

<h3>See you there</h3>

<p>Got tickets yet? No? What are you waiting for?</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-04-11T11:37:00+10:00" pubdate data-updated="true">Apr 11<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>, <a class='category' href='/writings/tags/lambdajam/'>lambdajam</a>, <a class='category' href='/writings/tags/scala/'>scala</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/">Clojure and &#8216;Why Calculating Is Better Than Scheming&#8217;</a></h1>
	<div class="entry-content">
		<p>Last week while attending <a href="http://clojurewest.org">Clojure/West</a> in Portland I came across a paper called <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf">Why calculating is better than scheming</a>. In a nutshell, this paper is a critique to <a href="http://en.wikipedia.org/wiki/Hal_Abelson">Abelson</a> and <a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">Sussman</a>&#8217;s classic textbook <a href="http://mitpress.mit.edu/sicp/">SICP - Structure and Interpretation of Computer Programs</a>,
used by MIT for many years to teach their introductory programming course.</p>

<p>If you haven&#8217;t read <a href="http://mitpress.mit.edu/sicp/">SICP</a>, you should. It&#8217;s an amazing book. It uses <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, a dialect of Lisp, as the vehicle to present fundamental programming concepts.</p>

<p><a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> - the author of this particular paper - contrasts teaching in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> to teaching using <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> and <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a>, pointing out
four major features he considers important and lacking in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>. They are:</p>

<ul>
<li>Pattern matching</li>
<li>A syntax close to traditional mathematical notation</li>
<li>A static type discipline and user-defined types</li>
<li>Lazy Evaluation</li>
</ul>


<blockquote><p>Note:  <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> influenced <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a> which in turn influenced <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>.  Their syntax is similiar, so where Wadler used Miranda code snippets in the paper, I&#8217;ll be using Haskell in this post.</p></blockquote>

<p>As an aside, although the paper talks specifically of <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, the term Lisp is used quite loosely and could lead the not-so-careful reader to be misled regarding a whole family of languages. Lisps have come a long way and modern dialects - of which I&#8217;ll be focusing on <a href="http://clojure.org/">Clojure</a> - address many of the concerns raised by <a href="http://homepages.inf.ed.ac.uk/wadler/">Wadler</a>.</p>

<p>Let us begin.</p>

<h3>Pattern Matching</h3>

<p>Here Clojure, and most - all? - Lisps, are out of luck.</p>

<p>The example used in the paper is that of summing all integers in a list. First in Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">sum</span> <span class="kt">[]</span>   <span class="ow">=</span> <span class="mi">0</span>
</span><span class='line'><span class="nf">sum</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">sum</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
</span><span class='line'>      <span class="mi">0</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">first </span><span class="nv">coll</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The question here is this: Which snippet is easier to read/reason about? the Haskell code!</p>

<p>I must confess that I, too, miss pattern matching sometimes. However we can still improve our Clojure version to read nicer on the eyes by using <a href="http://www.haskell.org/haskellwiki/Haskell">destructuring</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">sum</span> <span class="p">[[</span><span class="nv">first</span> <span class="nv">&amp;</span> <span class="nv">rest</span> <span class="nv">:as</span> <span class="nv">coll</span><span class="p">]]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
</span><span class='line'>      <span class="mi">0</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="nv">first</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">rest</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And that&#8217;s pretty much it. Without proper pattern matching, we can&#8217;t get much better than that.</p>

<p>In addition to the Haskell snippet being easier to read, it&#8217;s also easier to prove correct by structural induction, as demonstrated in Wadler&#8217;s paper.</p>

<blockquote><p>Note: <a href="https://github.com/clojure/core.match">core.match</a> adds support to pattern matching in Clojure. At the time of this writing, it&#8217;s considered &#8220;alpha quality&#8221;</p></blockquote>

<h3>Data structures</h3>

<p>The paper continues to discuss exercise 2-27 from the <a href="http://mitpress.mit.edu/sicp/">SICP</a>, where the reader has to write code to represent a binary mobile, which consists of a left and right branch with each branch being a rod of certain length, from which hangs either a weight or another binary mobile.</p>

<p>Translating the Scheme example to Clojure, such a structure is represented using lists, like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-mobile</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">list </span><span class="nv">left</span> <span class="nv">right</span><span class="p">))</span>
</span><span class='line'>  
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-branch</span> <span class="p">[</span><span class="nv">length</span> <span class="nv">structure</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">list </span><span class="nv">length</span> <span class="nv">structure</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Wadler then contrasts this with the equivalent Miranda code, translated below to Haskell, taking advantage of <a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">algebraic data types</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Structure</span> <span class="ow">=</span> <span class="kt">Weight</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">Mobile</span> <span class="kt">Branch</span> <span class="kt">Branch</span>
</span><span class='line'><span class="kr">data</span> <span class="kt">Branch</span> <span class="ow">=</span> <span class="kt">Branch</span> <span class="kt">Int</span> <span class="kt">Structure</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first claim is that the Haskell/Miranda data type declaration makes it clearer what the data structure looks like, which is fair.</p>

<p>Also, the compiler can catch errors early on.</p>

<p>However, when writing idiomatic Clojure code, here&#8217;s how I&#8217;d actually create this structure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-mobile</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:left</span> <span class="nv">left</span> <span class="nv">:right</span> <span class="nv">right</span><span class="p">})</span>
</span><span class='line'>  
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-branch</span> <span class="p">[</span><span class="nv">length</span> <span class="nv">structure</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:length</span> <span class="nv">length</span> <span class="nv">:structure</span> <span class="nv">structure</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Granted, it&#8217;s still not as clear and the compiler can&#8217;t validate the shape of our data structure.</p>

<p>This is however cleaner than the previous version and drives home the point that Clojure isn&#8217;t limited to lists, having literals for other data types such as the hash maps used in this example.</p>

<p>The second part of this claim is that through custom data types and pattern mathing, extracting values from those structures becomes simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">totalWeight</span> <span class="p">(</span><span class="kt">Weight</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="n">w</span>
</span><span class='line'><span class="nf">totalWeight</span> <span class="p">(</span><span class="kt">Mobile</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">totalWeightBranch</span> <span class="n">l</span> <span class="o">+</span> <span class="n">totalWeightBranch</span> <span class="n">r</span>
</span><span class='line'>
</span><span class='line'><span class="nf">totalWeightBranch</span><span class="p">(</span><span class="kt">Branch</span> <span class="n">d</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">totalWeight</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure>


<p>Once again Clojure can improve things by taking advantage of its builtin data structures and destructuring:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">total-weight</span> <span class="p">[{</span><span class="nv">:keys</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span> <span class="nv">:as</span> <span class="nv">structure</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">structure</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">structure</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">total-weight-branch</span> <span class="nv">left</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">total-weight-branch</span> <span class="nv">right</span><span class="p">))))</span>
</span><span class='line'>      
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">total-weight-branch</span> <span class="p">[{</span><span class="nv">structure</span> <span class="nv">:structure</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">total-weight</span> <span class="nv">structure</span><span class="p">))</span>     
</span></code></pre></td></tr></table></div></figure>


<p>For a language with no pattern matching nor algebraic data types, this snippet is clear, concise and elegant - and a real improvement
over the Scheme version discussed in the paper - which was essentially handicapped by the use of lists to simulate &#8216;structs&#8217;.</p>

<p>As far as Clojure goes, this claim ends here: the next point in the paper, about changing from using <code>list</code> to using <code>cons</code>, is rendered moot since
we&#8217;re using hash maps to represent our mobiles.</p>

<h3>Lisp lists are not self-escaping</h3>

<p>Creating lists in Clojure goes like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span> <span class="c1">;; ((1 2) nil)</span>
</span><span class='line'>
</span><span class='line'><span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span> <span class="c1">;; ((1 2) nil)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Both statements above are equivalent, with the second one being clearly more concise.</p>

<p>The claim here is that the fact that you need to either use the <code>list</code> function or quote the form is cumbersome and can be confusing to beginners.</p>

<p>Clojure solves this by providing literals to another data structure - vectors:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="nv">nil</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Simple and concise - in fact, in idiomatic Clojure code, you&#8217;ll rarely see quoted lists where a vector will do.</p>

<p>This is possible because both lists and vectors conform to a higher level abstraction called a <a href="http://clojure.org/sequences#Sequences-The%20Seq%20library-Seq%20in,%20Seq%20out">Seq</a>, in terms of which most list
operations are defined.</p>

<p>This eliminates the two following points mentioned in the paper as it allows a beginner to defer his/her understanding of quoted forms
to more advanced lessons/usages.</p>

<h3>Programs that Manipulate Programs - the interpreter example</h3>

<p>Here Wadler shows a simple grammar for an interpreter in both Miranda and Scheme.</p>

<p>He claims that since Haskell/Miranda have free data types, representing such grammar becomes simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Lambda</span> <span class="kt">Var</span> <span class="kt">Term</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Apply</span> <span class="kt">Term</span> <span class="kt">Term</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Closure</span> <span class="kt">Env</span> <span class="kt">Var</span> <span class="kt">Term</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Env</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Var</span><span class="p">,</span> <span class="kt">Term</span><span class="p">)]</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is true in that one can easily scan the snippet above and deduce quickly what <code>Term</code> looks like.</p>

<p>Then, by using pattern matching, <code>eval</code> could be implemented like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">e</span> <span class="n">v</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">v</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Closure</span> <span class="n">e</span> <span class="n">v</span> <span class="n">t</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t0</span> <span class="n">t1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">apply</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span> <span class="n">t0</span><span class="p">)</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span> <span class="n">t1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>I do believe this makes Haskell an excellent choice for writing interpreters and compilers.</p>

<p>However, the flip side is that entering such terms in Haskell is cumbersome. Consider the term below:</p>

<blockquote><p>(λx.(x x)) (λx.(x x))</p></blockquote>

<p>This is how to represent this term using the grammar defined above:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="s">&quot;x&quot;</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)))</span>
</span><span class='line'>       <span class="p">(</span><span class="kt">Lambda</span> <span class="s">&quot;x&quot;</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The strength in Lisp lies elsewhere. Since we have quoted forms, entering a similar term is a lot less verbose and closer to its intended representation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="o">&#39;</span><span class="p">((</span><span class="nf">lambda</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">lambda</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is, of course, at the expense of making <code>eval</code> a more complicated function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">eval</span> <span class="p">[</span><span class="nv">e</span> <span class="nv">t</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">lookup</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">variable-name</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">lambda?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">make-closure</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">lambda-var</span> <span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">lambda-body</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nb">eval </span><span class="nv">e</span> <span class="p">(</span><span class="nf">apply-operator</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">eval </span><span class="nv">e</span> <span class="p">(</span><span class="nf">apply-operand</span> <span class="nv">t</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>The paper leaves out an important advantage of Lisps though:</p>

<p>Because we can write code for our made up language directly in its (almost)abstract syntax tree form, Lisps are the ideal choice when writing <a href="http://martinfowler.com/bliki/InternalDslStyle.html">Internal Domain Specific Languages</a>.</p>

<h3>Lazy Evaluation</h3>

<h4>Lists</h4>

<p>Haskell and Miranda are lazy languages and that yields a lot of power. This claim is more specific to the use of lazy lists - or sequences, streams - and starts off with a snippet that calculates the sum of squares of all odd numbers from 1 up to 100:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">sum</span> <span class="p">[</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">odd</span> <span class="n">i</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>What follows in the paper is a not-so-clear snippet of equivalent functionality using Scheme streams.</p>

<p>Clojure features lazy sequences and list comprehensions, making the above Haskell example trivial to write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="k">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)</span> <span class="nv">:when</span> <span class="p">(</span><span class="nf">odd?</span> <span class="nv">i</span><span class="p">)]</span> <span class="p">(</span><span class="nb">* </span><span class="nv">i</span> <span class="nv">i</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you&#8217;re following at home with the original paper you&#8217;ll see this is more readable and elegant than the equivalent Scheme example.</p>

<p>Another - also idiomatic - way to write the same expression is by using a combination of map/filter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Deciding which one is clearer is left as an exercise to the reader.</p>

<h4>Special forms and lazy evaluation</h4>

<p>In this section, Wadler brings another example from SICP where the reader wishes to implement his/her own <code>if</code> form.</p>

<p>As we know, in order to implement our own version of <code>if</code>, we need to use macros. That is because in Lisps arguments to functions are eagerly evaluated.</p>

<p>One might implement it like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defmacro </span><span class="nv">my-if</span> <span class="p">[</span><span class="nv">pred</span> <span class="nv">then</span> <span class="nv">else</span><span class="p">]</span>
</span><span class='line'>  <span class="o">`</span><span class="p">(</span><span class="k">cond </span><span class="nv">~pred</span> <span class="nv">~then</span>
</span><span class='line'>          <span class="nv">:else</span> <span class="nv">~else</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In Lazy languages, such as Haskell and Miranda, this problem doesn&#8217;t occur allowing such functions to be defined without the need for special and/or quoted forms:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">myIf</span> <span class="kt">True</span>  <span class="n">t</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">t</span>
</span><span class='line'><span class="nf">myIf</span> <span class="kt">False</span> <span class="n">t</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">e</span>
</span></code></pre></td></tr></table></div></figure>


<p>However this completely dismisses the power of macros which allow you to extend the language in ways no other language allows - as is extensively demonstrated in books such as <a href="http://amzn.to/14mrrbk">On Lisp</a> and <a href="http://amzn.to/WKpMZA">Let Over Lambda</a>.</p>

<p>As <a href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Guy Steele</a> once put it:  <em>&#8221;[…] If you give someone Lisp, he has any language he pleases&#8221;</em></p>

<h3>Conclusion</h3>

<p>Hopefully this post doesn&#8217;t come off as trying to invalidate Wadler&#8217;s paper - that is not my intention.</p>

<p>While I do think a few of the points discussed are only applicable to the domain in which his paper was written - teaching - they are still valid and worth understanding.</p>

<p>I do however expect to have given you a different perspective on it, showing the strengths of modern Lisps such as Clojure and how it approaches these issues - such as by using its rich set of data structures, literals and techniques such as destructuring.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-03-25T11:00:00+11:00" pubdate data-updated="true">Mar 25<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>, <a class='category' href='/writings/tags/haskell/'>haskell</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2013/02/03/purely-functional-data-structures-in-clojure-leftist-heaps/">Purely Functional Data Structures in Clojure: Leftist Heaps</a></h1>
	<div class="entry-content">
		<blockquote><p>This post is part of a series about Chris Okasaki&#8217;s <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a>. You can see all posts in the series by visiting the <a href="http://www.leonardoborges.com/writings/tags/functional-data-structures/">functional-data-structures</a> category in this blog.</p></blockquote>

<hr />

<p>Last year I started reading a book called <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a>. It&#8217;s a fascinating book and if you&#8217;ve ever wondered how Clojure&#8217;s persistent data structures work, it&#8217;s mandatory reading.</p>

<p>However, all code samples in the book are written in <a href="http://bit.ly/YqYjtt">ML</a> - with <a href="http://bit.ly/YqYmp6">Haskell</a> versions in the end of the book. This means I got stuck in Chapter 3, where the ML snippets start.</p>

<p>I had no clue about Haskell&#8217;s - much less ML&#8217;s! - syntax and I was finding it very difficult to follow along. What I did notice is that their syntaxes are not so different from each other.</p>

<p>So I put the book down and read <a href="http://amzn.to/VuD3jT">Learn You a Haskell For Great Good!</a> with the hopes that learning more about haskell&#8217;s syntax - in particular, learning how to read its type signatures - would help me get going with <em>Puretly Functional Data Structures</em>.</p>

<p>Luckily, I was right - and I recommend you do the same if you&#8217;re not familiar with either of those languages. <a href="http://amzn.to/VuD3jT">Learn You a Haskell For Great Good!</a> is a great book and I got a lot out of it. <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">My series on Monads</a> is a product of reading it.</p>

<p>Enough background though.</p>

<p>The purpose of this post is two-fold: One is to share the <a href="https://github.com/leonardoborges/purely-functional-data-structures">github repository</a> I created and that will contain the Clojure versions of the data structures in the book as well as most solutions to the exercises - or at least as many as my time-poor life allows me to implement.</p>

<p>The other is to walk you through some of the code and get a discussion going. Hopefully we will all learn something - as I certainly have when implementing these. Today, we&#8217;ll start with Leftist Heaps.</p>

<h3>Leftist Heaps</h3>

<p><a href="http://en.wikipedia.org/wiki/Leftist_tree">Leftist Heaps</a> - or trees - are a variant of <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heaps</a> that can be used as priority queues. On top of the standard invariants of binary heaps, it obeys the leftist property:</p>

<ul>
<li>Every node has a <em>rank</em>, which is the distance from its right spine to the nearest leaf</li>
<li>A node&#8217;s left child has a rank at least as large as its right child</li>
</ul>


<p>In a nutshell, these are the operations we need to be able to perform on a leftist heap:</p>

<ul>
<li>insert a value into an existing heap</li>
<li>merge two heaps</li>
<li>find the minimum value in a heap</li>
<li>delete the minimum value, returning a new heap</li>
</ul>


<p>Since the book uses ML/Haskell, it starts with a data type definition for Heaps that exposes these and a couple of other auxiliary functions. I decided to take a stab at writing the solution using Clojure&#8217;s protocols and records:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defprotocol</span> <span class="nv">Heap</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is-empty?</span>   <span class="p">[</span><span class="nv">this</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">insert</span>      <span class="p">[</span><span class="nv">this</span> <span class="nv">v</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">merge </span>      <span class="p">[</span><span class="nv">this</span> <span class="nv">other</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">rank</span>        <span class="p">[</span><span class="nv">this</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">find-min</span>    <span class="p">[</span><span class="nv">this</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">delete-min</span>  <span class="p">[</span><span class="nv">this</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">defrecord</span> <span class="nv">LeftistHeap</span> <span class="p">[</span><span class="nv">rank</span> <span class="nv">value</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>When implementing the algorithms the base case for the recursive solutions will involve dealing with <em>nil</em> values which at first seems like it wouldn&#8217;t be a problem. However, protocol functions dispatch on the type of its first argument so what happens if I call the function <em>is-empty?</em> on <em>nil</em>?</p>

<p>Luckily, Clojure allows us to extend a protocol to core types:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">extend-protocol</span> <span class="nv">Heap</span>
</span><span class='line'>  <span class="nv">nil</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">rank</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">merge </span><span class="p">[</span><span class="nv">_</span> <span class="nv">other</span><span class="p">]</span> <span class="nv">other</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is-empty?</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">true</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">LeftistHeap</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is-empty?</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">nil? </span><span class="nv">this</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">rank</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">:rank</span> <span class="nv">this</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nb">merge </span><span class="p">[{</span><span class="nv">val-this</span> <span class="nv">:value</span> <span class="nv">left-this</span> <span class="nv">:left</span> <span class="nv">right-this</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">this</span><span class="p">}</span>
</span><span class='line'>          <span class="p">{</span><span class="nv">val-other</span> <span class="nv">:value</span> <span class="nv">left-other</span> <span class="nv">:left</span> <span class="nv">right-other</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">other</span><span class="p">}]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">cond</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">is-empty?</span> <span class="nv">other</span><span class="p">)</span> <span class="nv">this</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">val-this</span> <span class="nv">val-other</span><span class="p">)</span> <span class="p">(</span><span class="nf">ensure-leftist</span> <span class="nv">left-this</span>
</span><span class='line'>                                             <span class="p">(</span><span class="nb">merge </span><span class="nv">right-this</span> <span class="nv">other</span><span class="p">)</span>
</span><span class='line'>                                             <span class="nv">val-this</span><span class="p">)</span>
</span><span class='line'>     <span class="nv">:else</span> <span class="p">(</span><span class="nf">ensure-leftist</span> <span class="nv">left-other</span>
</span><span class='line'>                           <span class="p">(</span><span class="nb">merge </span><span class="nv">this</span> <span class="nv">right-other</span><span class="p">)</span>
</span><span class='line'>                           <span class="nv">val-other</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">insert</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">v</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">merge </span><span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="mi">1</span> <span class="nv">v</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>           <span class="nv">this</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">find-min</span> <span class="p">[{</span><span class="nv">v</span> <span class="nv">:value</span><span class="p">}]</span> <span class="nv">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">delete-min</span> <span class="p">[{</span><span class="nv">left</span> <span class="nv">:left</span> <span class="nv">right</span> <span class="nv">:right</span><span class="p">}]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">merge </span><span class="nv">right</span> <span class="nv">left</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note how I extended a few of the protocol functions to the nil data type, allowing me to continue with this implementation with no nasty hacks.</p>

<p>There&#8217;s one last bit missing: a function that will ensure each heap retains the leftist property:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">ensure-leftist</span>
</span><span class='line'> <span class="p">[</span><span class="nv">this</span> <span class="nv">other</span> <span class="nv">v</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">rank-this</span> <span class="p">(</span><span class="nf">rank</span> <span class="nv">this</span><span class="p">)</span>
</span><span class='line'>       <span class="nv">rank-other</span> <span class="p">(</span><span class="nf">rank</span> <span class="nv">other</span><span class="p">)]</span>
</span><span class='line'>   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">rank-this</span> <span class="nv">rank-other</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-other</span><span class="p">)</span> <span class="nv">v</span> <span class="nv">this</span> <span class="nv">other</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-this</span><span class="p">)</span> <span class="nv">v</span> <span class="nv">other</span> <span class="nv">this</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The reason this function is isolated is that the Heap protocol defined above is fairly generic and could be used for defining other types of heaps - and I didn&#8217;t feel it warranted its own interface.</p>

<p>We can now play with it and create a new leftist heap:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="mi">1</span> <span class="mi">3</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">7</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">20</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>While I quite like this approach, I thought I&#8217;d also implement this solution using Clojure&#8217;s core data types - maps in this case - and no protocols. The code is shown below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">mk-heap</span> <span class="p">[</span><span class="nv">rank</span> <span class="nv">value</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:rank</span> <span class="nv">rank</span> <span class="nv">:value</span> <span class="nv">value</span> <span class="nv">:left</span> <span class="nv">left</span> <span class="nv">:right</span> <span class="nv">right</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-rank</span> <span class="p">[</span><span class="nv">heap</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">heap</span><span class="p">)</span>
</span><span class='line'>    <span class="mi">0</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">:rank</span> <span class="nv">heap</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">ensure-leftist-heap</span> <span class="p">[</span><span class="nv">value</span> <span class="nv">heap-a</span> <span class="nv">heap-b</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">rank-a</span> <span class="p">(</span><span class="nf">heap-rank</span> <span class="nv">heap-a</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">rank-b</span> <span class="p">(</span><span class="nf">heap-rank</span> <span class="nv">heap-b</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">rank-a</span> <span class="nv">rank-b</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">mk-heap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-b</span><span class="p">)</span> <span class="nv">value</span> <span class="nv">heap-a</span> <span class="nv">heap-b</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">mk-heap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-a</span><span class="p">)</span> <span class="nv">value</span> <span class="nv">heap-b</span> <span class="nv">heap-a</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">merge-heaps</span> <span class="p">[{</span><span class="nv">val-a</span> <span class="nv">:value</span> <span class="nv">left-a</span> <span class="nv">:left</span> <span class="nv">right-a</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">heap-a</span><span class="p">}</span>
</span><span class='line'>                   <span class="p">{</span><span class="nv">val-b</span> <span class="nv">:value</span> <span class="nv">left-b</span> <span class="nv">:left</span> <span class="nv">right-b</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">heap-b</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">cond</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">nil? </span><span class="nv">heap-a</span><span class="p">)</span> <span class="nv">heap-b</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">nil? </span><span class="nv">heap-b</span><span class="p">)</span> <span class="nv">heap-a</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">val-a</span> <span class="nv">val-b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ensure-leftist-heap</span> <span class="nv">val-a</span>
</span><span class='line'>                                         <span class="nv">left-a</span>
</span><span class='line'>                                         <span class="p">(</span><span class="nf">merge-heaps</span> <span class="nv">right-a</span> <span class="nv">heap-b</span><span class="p">))</span>
</span><span class='line'>   <span class="nv">:else</span> <span class="p">(</span><span class="nf">ensure-leftist-heap</span> <span class="nv">val-b</span>
</span><span class='line'>                              <span class="nv">left-b</span>
</span><span class='line'>                              <span class="p">(</span><span class="nf">merge-heaps</span> <span class="nv">heap-a</span> <span class="nv">right-b</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-insert</span> <span class="p">[</span><span class="nv">value</span> <span class="nv">heap</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">merge-heaps</span> <span class="p">(</span><span class="nf">mk-heap</span> <span class="mi">1</span> <span class="nv">value</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>               <span class="nv">heap</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-find-min</span> <span class="p">[{</span><span class="nv">v</span> <span class="nv">:value</span><span class="p">}]</span> <span class="nv">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-delete-min</span> <span class="p">[{</span><span class="nv">left</span> <span class="nv">:left</span> <span class="nv">right</span> <span class="nv">:right</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">merge-heaps</span> <span class="nv">right</span> <span class="nv">left</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using it is equally simple:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">mk-heap</span> <span class="mi">1</span> <span class="mi">3</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">7</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">20</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&#8217;s it for now.</p>

<p>As I implement more of the book&#8217;s code and exercises I&#8217;ll add them to the <a href="https://github.com/leonardoborges/purely-functional-data-structures">github repo</a> - it also includes tests for all implementations.</p>

<p>Enjoy :)</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-02-03T12:41:00+11:00" pubdate data-updated="true">Feb 3<span>rd</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/functional-data-structures/'>functional-data-structures</a>, <a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/writings/2013/01/04/bouncer-validation-lib-for-clojure/">Announcing Bouncer, a Validation Library for Clojure Apps</a></h1>
	<div class="entry-content">
		<p>Today I&#8217;m releasing bouncer, which was extracted from a project I&#8217;ve been working on.</p>

<p>It&#8217;s a validation library for Clojure apps and it lets you write code like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">person</span> <span class="p">{</span><span class="nv">:name</span> <span class="s">&quot;Leo&quot;</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="nv">person</span>
</span><span class='line'>    <span class="nv">:name</span> <span class="nv">required</span>
</span><span class='line'>    <span class="nv">:age</span>  <span class="p">[</span><span class="nv">required</span> <span class="nv">number</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you&#8217;d like to see more examples and a detailed guide check out the <a href="http://github.com/leonardoborges/bouncer">github repository</a>. The README should get you started.</p>

<p>This post however isn&#8217;t only about announcing bouncer. It&#8217;s also about the motivation and implementation details behind it.</p>

<p>There are a couple of Clojure validation libraries already out there so why would I write a new one?
Well&#8230;</p>

<ul>
<li><p>Writing Clojure is fun! (who knew? :P)</p></li>
<li><p>Because I believe this problem can be solved more elegantly with the use of Monads</p></li>
</ul>


<p>If you&#8217;ve been following me for a while, you&#8217;ll know that I spent most of 2012 deepening my knowledge about functional programming.</p>

<p>In that journey, the unavoidable subject of monads came about - and it was both interesting and enlightening enough that made me <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">write a whole series of posts about it</a>.</p>

<p>After learning what they are and then thinking about the validation problem for a while, I couldn&#8217;t help but notice that the problem had a lot in common with the <a href="http://www.haskell.org/haskellwiki/State_Monad">State Monad</a>.</p>

<p>In order to explain how the two relate, I&#8217;ll have to digress for a moment. It&#8217;ll all make sense in the end - or so I hope</p>

<h2>Purity</h2>

<p>In pure functional languages, such as Haskell, functions can&#8217;t have side effects. These include performing IO, changing global variables or launching missiles.</p>

<p>Because of that, functions in Haskell are pure: if you repeatedly call a function <em>f</em> with the same argument <code>x</code> over time you will <em>always</em> get the same result back.</p>

<p>Pure functions are not a feature of Haskell though. We, too, can write pure functions if we wish:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">double</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The function <code>double</code> above is pure. If we call it with 10, we can be sure the result will always be 20.</p>

<p>This leaves us with a question though: If we were to write our programs with pure functions only, how would we perform computations that need to carry state - state that needs to change over time - around?</p>

<p>A good example of such computation is generating random numbers.</p>

<p>Most programming languages provide generators capable of creating random numbers on demand. Using them is usually trivial. Here&#8217;s an example in Java:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Random</span> <span class="n">gen</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">gen</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span> <span class="c1">// 0.0037635726242281065</span>
</span><span class='line'><span class="n">gen</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span> <span class="c1">// 0.15821091918430885</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Impurity alert!</strong></p>

<p>The function <code>nextDouble</code> above is obviously <em>not</em> pure. Multiple invocations of it with the same argument - in this case, none - returns different results.</p>

<p><code>nextDouble</code>  is keeping some sort of global state between function calls.</p>

<p>This is where the State Monad comes in. It allows such functions to remain pure.</p>

<h2>The State Monad</h2>

<p>The State Monad provides a way to abstract <em>state</em> from the function that needs to operate on it.</p>

<p>Sounds confusing? Hopefully an example will clear things up.</p>

<p>Let&#8217;s have a look at the clojure function <code>rand</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">rand</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; 0.04388682005715605</span>
</span><span class='line'><span class="p">(</span><span class="nf">rand</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; 0.43057496371080517</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>rand</code> suffers from the same problem as <code>nextDouble</code> we saw above. It keeps it&#8217;s own state that is shared across calls, therefore being an impure function.</p>

<p>Now let&#8217;s write a pure version of <code>rand</code>. We&#8217;ll call it <code>pure-rand</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">gen</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">pure-rand</span> <span class="p">[</span><span class="nv">g</span><span class="p">]</span>
</span><span class='line'>    <span class="p">[(</span><span class="o">.</span><span class="nv">nextDouble</span> <span class="nv">g</span><span class="p">)</span> <span class="nv">g</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="nv">gen</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; [0.5783608063218478 #&lt;Random java.util.Random@7f30ab6&gt;]</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="nv">gen</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; [0.9251968987499839 #&lt;Random java.util.Random@7f30ab6&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is interesting. <code>pure-rand</code> now takes a generator as an argument and returns a two-element vector containing the random number itself - the result we&#8217;re actually interested in - and the generator that was passed in.</p>

<p>Recall however that the generator returned, albeit the same object, is in a new sate.</p>

<p>By re-writing the function like this, we&#8217;ve regained purity, as demonstrated below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span> <span class="mi">100</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; [0.7220096548596434 #&lt;Random java.util.Random@bb14fe1&gt;]</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span> <span class="mi">100</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; [0.7220096548596434 #&lt;Random java.util.Random@bb14fe1&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, as long as we provide the same generator - the same argument - we get the same result back.</p>

<p>If you&#8217;re wondering why I&#8217;m returning a two element vector from our little function, the answer lies in the State Monad implementation as found in the <a href="https://github.com/clojure/algo.monads/">algo.monads</a> library.</p>

<p>From its docstring:</p>

<blockquote><p><strong>State Monad</strong>: Monad describing stateful computations. The monadic values have the structure:</p>

<pre><code>(fn [old-state] [result new-state]).
</code></pre></blockquote>

<p>It expects a function that receives its old state and returns the result and the new state - these are called monadic values.</p>

<p>By designing the function to follow this contract, we can leverage the <code>domonad</code> macro - think of it as syntactic sugar for working with monads:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure</span><span class="o">.</span><span class="nv">algo</span><span class="o">.</span><span class="nv">monads</span> <span class="nv">:as</span> <span class="nv">m</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="p">((</span><span class="nf">m/domonad</span> <span class="nv">m/state-m</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">a</span> <span class="nv">pure-rand</span>
</span><span class='line'>     <span class="nv">b</span> <span class="nv">pure-rand</span>
</span><span class='line'>     <span class="nv">c</span> <span class="nv">pure-rand</span><span class="p">]</span>
</span><span class='line'>     <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">])</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span> <span class="mi">100</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [[0.7220096548596434 0.19497605734770518 0.6671595726539502] </span>
</span><span class='line'><span class="c1">;; #&lt;Random java.util.Random@358ddfd6&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the example above, we&#8217;re using our <code>pure-rand</code> function in the context of the State Monad to generate 3 random numbers - based on some initial state - and returning them as a vector.</p>

<p>As we&#8217;ve seen before the result is itself in a vector alongside the new state.</p>

<p>This is where the State Monad and the validation problem meet:</p>

<p>In <a href="http://github.com/leonardoborges/bouncer">bouncer</a>, each validation function is designed to be compatible with the State Monad, just like <code>pure-rand</code> above:</p>

<p>It receives an initial state - at first, the map to be validated - and returns a vector with the map of errors and the new state: the original map augmented with any errors from previous validators.</p>

<p>The end result, should one or more validations fail, is a map with all errors that might have happened, plus our new state.</p>

<p>Now if you head to the <a href="http://github.com/leonardoborges/bouncer">github repository</a> and read the examples by keeping the State Monad and the above explanation in mind, the similarities should be obvious.</p>

<h2>Wrapping up</h2>

<p>As I mentioned in the beginning of the article, there are <a href="https://github.com/r0man/validation-clj">other</a> validation <a href="https://github.com/michaelklishin/validateur">libraries</a> for Clojure and at the time of this writing they have more features than <a href="http://github.com/leonardoborges/bouncer">bouncer</a> - by all means have a look at them.</p>

<p>However I will keep maintaining <a href="http://github.com/leonardoborges/bouncer">bouncer</a> for a couple of reasons:</p>

<ul>
<li>That&#8217;s what I&#8217;m using in my current side project</li>
<li>It takes a fundamentally different implementation approach that is in itself worthy of exploration</li>
<li>If nothing else, this is yet another example of where Monads can be useful.</li>
</ul>


<h4>Acknowledgments</h4>

<p>Thanks to <a href="https://twitter.com/stevebuik">Steve</a> and <a href="https://twitter.com/juliansgamble">Julian</a> for reviewing early drafts of this post as well as <a href="https://twitter.com/nick_s_drew">Nick</a> for being such a PITA :) - our discussions led to a considerably nicer design.</p>

<p>As usual, let me know your thoughts.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-01-04T17:39:00+11:00" pubdate data-updated="true">Jan 4<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/writings/" class="prev">Prev</a>
    
    
        <a href="/writings/writings/page/3/" class="next">Next</a>
    
    <div class="center"><a href="/writings/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    Leonardo Borges

</footer>
	<script src="/writings/javascripts/slash.js"></script>
<script src="/writings/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'leonardoborges';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-2811271-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>