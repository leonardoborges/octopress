
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Clojure and 'Why calculating is better than scheming' - Leonardo Borges</title>
	<meta name="author" content="Leonardo Borges">

	
	<meta name="description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="http://feeds.feedburner.com/leonardoborges" rel="alternate" title="Leonardo Borges" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/writings/favicon.png" rel="shortcut icon">
	<link href="/writings/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/writings/">Leonardo Borges</a></h1>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/writings/">Blog</a></li>
  <li><a href="/writings/about">About</a></li>
  <li><a href="/writings/projects">Projects</a></li>
  <li><a href="/writings/presentations">Talks</a></li>
  <li><a href="/writings/books">Books</a></li>
  <li><a href="/writings/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main-navigation">
  <li><a href="/writings/">Blog</a></li>
  <li><a href="/writings/about">About</a></li>
  <li><a href="/writings/projects">Projects</a></li>
  <li><a href="/writings/presentations">Talks</a></li>
  <li><a href="/writings/books">Books</a></li>
  <li><a href="/writings/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.leonardoborges.com/writings">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/leonardo_borges" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/leonardoborges" title="GitHub">GitHub</a>
		
		
		
		
		
		<a class="rss" href="http://feeds.feedburner.com/leonardoborges" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:www.leonardoborges.com/writings">
	</form>
</nav>

</header>
	
		
<!-- <div id="banner" class="inner"> -->
<!--     <div class="container"> -->
<!--         <ul class="feed"></ul> -->
<!--     </div> -->
<!--     <small><a href="http://twitter.com/leonardo_borges">leonardo_borges</a> @ <a href="http://twitter.com">Twitter</a></small> -->
<!--     <div class="loading">Loading...</div> -->
<!-- </div> -->
<!-- <script src="/writings/javascripts/twitter.js"></script> -->
<!-- <script type="text/javascript"> -->
<!--     (function($){ -->
<!--         $('#banner').getTwitterFeed('leonardo_borges', 4, false); -->
<!--     })(jQuery); -->
<!-- </script> -->


	
	<div id="content" class="inner"><article class="post">
	<h1 class="title">Clojure and 'Why Calculating Is Better Than Scheming'</h1>
	<div class="entry-content"><p>Last week while attending <a href="http://clojurewest.org">Clojure/West</a> in Portland I came across a paper called <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf">Why calculating is better than scheming</a>. In a nutshell, this paper is a critique to <a href="http://en.wikipedia.org/wiki/Hal_Abelson">Abelson</a> and <a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">Sussman</a>&#8217;s classic textbook <a href="http://mitpress.mit.edu/sicp/">SICP - Structure and Interpretation of Computer Programs</a>,
used by MIT for many years to teach their introductory programming course.</p>

<p>If you haven&#8217;t read <a href="http://mitpress.mit.edu/sicp/">SICP</a>, you should. It&#8217;s an amazing book. It uses <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, a dialect of Lisp, as the vehicle to present fundamental programming concepts.</p>

<p><a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> - the author of this particular paper - contrasts teaching in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> to teaching using <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> and <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a>, pointing out
four major features he considers important and lacking in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>. They are:</p>

<ul>
<li>Pattern matching</li>
<li>A syntax close to traditional mathematical notation</li>
<li>A static type discipline and user-defined types</li>
<li>Lazy Evaluation</li>
</ul>


<blockquote><p>Note:  <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> influenced <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a> which in turn influenced <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>.  Their syntax is similiar, so where Wadler used Miranda code snippets in the paper, I&#8217;ll be using Haskell in this post.</p></blockquote>

<p>As an aside, although the paper talks specifically of <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, the term Lisp is used quite loosely and could lead the not-so-careful reader to be misled regarding a whole family of languages. Lisps have come a long way and modern dialects - of which I&#8217;ll be focusing on <a href="http://clojure.org/">Clojure</a> - address many of the concerns raised by <a href="http://homepages.inf.ed.ac.uk/wadler/">Wadler</a>.</p>

<p>Let us begin.</p>

<h3>Pattern Matching</h3>

<p>Here Clojure, and most - all? - Lisps, are out of luck.</p>

<p>The example used in the paper is that of summing all integers in a list. First in Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">sum</span> <span class="kt">[]</span>   <span class="ow">=</span> <span class="mi">0</span>
</span><span class='line'><span class="nf">sum</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">sum</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
</span><span class='line'>      <span class="mi">0</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">first </span><span class="nv">coll</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The question here is this: Which snippet is easier to read/reason about? the Haskell code!</p>

<p>I must confess that I, too, miss pattern matching sometimes. However we can still improve our Clojure version to read nicer on the eyes by using <a href="http://www.haskell.org/haskellwiki/Haskell">destructuring</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">sum</span> <span class="p">[[</span><span class="nv">first</span> <span class="nv">&amp;</span> <span class="nv">rest</span> <span class="nv">:as</span> <span class="nv">coll</span><span class="p">]]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
</span><span class='line'>      <span class="mi">0</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="nv">first</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">rest</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And that&#8217;s pretty much it. Without proper pattern matching, we can&#8217;t get much better than that.</p>

<p>In addition to the Haskell snippet being easier to read, it&#8217;s also easier to prove correct by structural induction, as demonstrated in Wadler&#8217;s paper.</p>

<blockquote><p>Note: <a href="https://github.com/clojure/core.match">core.match</a> adds support to pattern matching in Clojure. At the time of this writing, it&#8217;s considered &#8220;alpha quality&#8221;</p></blockquote>

<h3>Data structures</h3>

<p>The paper continues to discuss exercise 2-27 from the <a href="http://mitpress.mit.edu/sicp/">SICP</a>, where the reader has to write code to represent a binary mobile, which consists of a left and right branch with each branch being a rod of certain length, from which hangs either a weight or another binary mobile.</p>

<p>Translating the Scheme example to Clojure, such a structure is represented using lists, like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-mobile</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">list </span><span class="nv">left</span> <span class="nv">right</span><span class="p">))</span>
</span><span class='line'>  
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-branch</span> <span class="p">[</span><span class="nv">length</span> <span class="nv">structure</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">list </span><span class="nv">length</span> <span class="nv">structure</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Wadler then contrasts this with the equivalent Miranda code, translated below to Haskell, taking advantage of <a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">algebraic data types</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Structure</span> <span class="ow">=</span> <span class="kt">Weight</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">Mobile</span> <span class="kt">Branch</span> <span class="kt">Branch</span>
</span><span class='line'><span class="kr">data</span> <span class="kt">Branch</span> <span class="ow">=</span> <span class="kt">Branch</span> <span class="kt">Int</span> <span class="kt">Structure</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first claim is that the Haskell/Miranda data type declaration makes it clearer what the data structure looks like, which is fair.</p>

<p>Also, the compiler can catch errors early on.</p>

<p>However, when writing idiomatic Clojure code, here&#8217;s how I&#8217;d actually create this structure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-mobile</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:left</span> <span class="nv">left</span> <span class="nv">:right</span> <span class="nv">right</span><span class="p">})</span>
</span><span class='line'>  
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-branch</span> <span class="p">[</span><span class="nv">length</span> <span class="nv">structure</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:length</span> <span class="nv">length</span> <span class="nv">:structure</span> <span class="nv">structure</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Granted, it&#8217;s still not as clear and the compiler can&#8217;t validate the shape of our data structure.</p>

<p>This is however cleaner than the previous version and drives home the point that Clojure isn&#8217;t limited to lists, having literals for other data types such as the hash maps used in this example.</p>

<p>The second part of this claim is that through custom data types and pattern mathing, extracting values from those structures becomes simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">totalWeight</span> <span class="p">(</span><span class="kt">Weight</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="n">w</span>
</span><span class='line'><span class="nf">totalWeight</span> <span class="p">(</span><span class="kt">Mobile</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">totalWeightBranch</span> <span class="n">l</span> <span class="o">+</span> <span class="n">totalWeightBranch</span> <span class="n">r</span>
</span><span class='line'>
</span><span class='line'><span class="nf">totalWeightBranch</span><span class="p">(</span><span class="kt">Branch</span> <span class="n">d</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">totalWeight</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure>


<p>Once again Clojure can improve things by taking advantage of its builtin data structures and destructuring:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">total-weight</span> <span class="p">[{</span><span class="nv">:keys</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span> <span class="nv">:as</span> <span class="nv">structure</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">structure</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">structure</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">total-weight-branch</span> <span class="nv">left</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">total-weight-branch</span> <span class="nv">right</span><span class="p">))))</span>
</span><span class='line'>      
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">total-weight-branch</span> <span class="p">[{</span><span class="nv">structure</span> <span class="nv">:structure</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">total-weight</span> <span class="nv">structure</span><span class="p">))</span>     
</span></code></pre></td></tr></table></div></figure>


<p>For a language with no pattern matching nor algebraic data types, this snippet is clear, concise and elegant - and a real improvement
over the Scheme version discussed in the paper - which was essentially handicapped by the use of lists to simulate &#8216;structs&#8217;.</p>

<p>As far as Clojure goes, this claim ends here: the next point in the paper, about changing from using <code>list</code> to using <code>cons</code>, is rendered moot since
we&#8217;re using hash maps to represent our mobiles.</p>

<h3>Lisp lists are not self-escaping</h3>

<p>Creating lists in Clojure goes like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span> <span class="c1">;; ((1 2) nil)</span>
</span><span class='line'>
</span><span class='line'><span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span> <span class="c1">;; ((1 2) nil)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Both statements above are equivalent, with the second one being clearly more concise.</p>

<p>The claim here is that the fact that you need to either use the <code>list</code> function or quote the form is cumbersome and can be confusing to beginners.</p>

<p>Clojure solves this by providing literals to another data structure - vectors:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="nv">nil</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Simple and concise - in fact, in idiomatic Clojure code, you&#8217;ll rarely see quoted lists where a vector will do.</p>

<p>This is possible because both lists and vectors conform to a higher level abstraction called a <a href="http://clojure.org/sequences#Sequences-The%20Seq%20library-Seq%20in,%20Seq%20out">Seq</a>, in terms of which most list
operations are defined.</p>

<p>This eliminates the two following points mentioned in the paper as it allows a beginner to defer his/her understanding of quoted forms
to more advanced lessons/usages.</p>

<h3>Programs that Manipulate Programs - the interpreter example</h3>

<p>Here Wadler shows a simple grammar for an interpreter in both Miranda and Scheme.</p>

<p>He claims that since Haskell/Miranda have free data types, representing such grammar becomes simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Lambda</span> <span class="kt">Var</span> <span class="kt">Term</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Apply</span> <span class="kt">Term</span> <span class="kt">Term</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Closure</span> <span class="kt">Env</span> <span class="kt">Var</span> <span class="kt">Term</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Env</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Var</span><span class="p">,</span> <span class="kt">Term</span><span class="p">)]</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is true in that one can easily scan the snippet above and deduce quickly what <code>Term</code> looks like.</p>

<p>Then, by using pattern matching, <code>eval</code> could be implemented like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">e</span> <span class="n">v</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">v</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Closure</span> <span class="n">e</span> <span class="n">v</span> <span class="n">t</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t0</span> <span class="n">t1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">apply</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span> <span class="n">t0</span><span class="p">)</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span> <span class="n">t1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>I do believe this makes Haskell an excellent choice for writing interpreters and compilers.</p>

<p>However, the flip side is that entering such terms in Haskell is cumbersome. Consider the term below:</p>

<blockquote><p>(λx.(x x)) (λx.(x x))</p></blockquote>

<p>This is how to represent this term using the grammar defined above:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="s">&quot;x&quot;</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)))</span>
</span><span class='line'>       <span class="p">(</span><span class="kt">Lambda</span> <span class="s">&quot;x&quot;</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The strength in Lisp lies elsewhere. Since we have quoted forms, entering a similar term is a lot less verbose and closer to its intended representation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="o">&#39;</span><span class="p">((</span><span class="nf">lambda</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">lambda</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is, of course, at the expense of making <code>eval</code> a more complicated function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">eval</span> <span class="p">[</span><span class="nv">e</span> <span class="nv">t</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">lookup</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">variable-name</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">lambda?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">make-closure</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">lambda-var</span> <span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">lambda-body</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nb">eval </span><span class="nv">e</span> <span class="p">(</span><span class="nf">apply-operator</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">eval </span><span class="nv">e</span> <span class="p">(</span><span class="nf">apply-operand</span> <span class="nv">t</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>The paper leaves out an important advantage of Lisps though:</p>

<p>Because we can write code for our made up language directly in its (almost)abstract syntax tree form, Lisps are the ideal choice when writing <a href="http://martinfowler.com/bliki/InternalDslStyle.html">Internal Domain Specific Languages</a>.</p>

<h3>Lazy Evaluation</h3>

<h4>Lists</h4>

<p>Haskell and Miranda are lazy languages and that yields a lot of power. This claim is more specific to the use of lazy lists - or sequences, streams - and starts off with a snippet that calculates the sum of squares of all odd numbers from 1 up to 100:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">sum</span> <span class="p">[</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">odd</span> <span class="n">i</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>What follows in the paper is a not-so-clear snippet of equivalent functionality using Scheme streams.</p>

<p>Clojure features lazy sequences and list comprehensions, making the above Haskell example trivial to write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="k">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)</span> <span class="nv">:when</span> <span class="p">(</span><span class="nf">odd?</span> <span class="nv">i</span><span class="p">)]</span> <span class="p">(</span><span class="nb">* </span><span class="nv">i</span> <span class="nv">i</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you&#8217;re following at home with the original paper you&#8217;ll see this is more readable and elegant than the equivalent Scheme example.</p>

<p>Another - also idiomatic - way to write the same expression is by using a combination of map/filter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Deciding which one is clearer is left as an exercise to the reader.</p>

<h4>Special forms and lazy evaluation</h4>

<p>In this section, Wadler brings another example from SICP where the reader wishes to implement his/her own <code>if</code> form.</p>

<p>As we know, in order to implement our own version of <code>if</code>, we need to use macros. That is because in Lisps arguments to functions are eagerly evaluated.</p>

<p>One might implement it like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defmacro </span><span class="nv">my-if</span> <span class="p">[</span><span class="nv">pred</span> <span class="nv">then</span> <span class="nv">else</span><span class="p">]</span>
</span><span class='line'>  <span class="o">`</span><span class="p">(</span><span class="k">cond </span><span class="nv">~pred</span> <span class="nv">~then</span>
</span><span class='line'>          <span class="nv">:else</span> <span class="nv">~else</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In Lazy languages, such as Haskell and Miranda, this problem doesn&#8217;t occur allowing such functions to be defined without the need for special and/or quoted forms:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">myIf</span> <span class="kt">True</span>  <span class="n">t</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">t</span>
</span><span class='line'><span class="nf">myIf</span> <span class="kt">False</span> <span class="n">t</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">e</span>
</span></code></pre></td></tr></table></div></figure>


<p>However this completely dismisses the power of macros which allow you to extend the language in ways no other language allows - as is extensively demonstrated in books such as <a href="http://amzn.to/14mrrbk">On Lisp</a> and <a href="http://amzn.to/WKpMZA">Let Over Lambda</a>.</p>

<p>As <a href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Guy Steele</a> once put it:  <em>&#8221;[…] If you give someone Lisp, he has any language he pleases&#8221;</em></p>

<h3>Conclusion</h3>

<p>Hopefully this post doesn&#8217;t come off as trying to invalidate Wadler&#8217;s paper - that is not my intention.</p>

<p>While I do think a few of the points discussed are only applicable to the domain in which his paper was written - teaching - they are still valid and worth understanding.</p>

<p>I do however expect to have given you a different perspective on it, showing the strengths of modern Lisps such as Clojure and how it approaches these issues - such as by using its rich set of data structures, literals and techniques such as destructuring.</p>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-03-25T11:00:00+11:00" pubdate data-updated="true">Mar 25<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/writings/tags/clojure/'>clojure</a>, <a class='category' href='/writings/tags/functional-programming/'>functional-programming</a>, <a class='category' href='/writings/tags/haskell/'>haskell</a>


</div>
	
</div></article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	<a class="addthis_button_facebook_like" fb:like:layout="button_count" addthis:url="http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/"></a>
	
	
	<a class="addthis_button_tweet" addthis:url="http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/"></a>
	
	
	<a class="addthis_button_google_plusone" g:plusone:size="medium" addthis:url="http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/"></a>
	
	<a class="addthis_counter addthis_pill_style" addthis:url="http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    Leonardo Borges

</footer>
	<script src="/writings/javascripts/slash.js"></script>
<script src="/writings/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'leonardoborges';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/';
        var disqus_url = 'http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-2811271-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>