<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Leonardo Borges]]></title>
  <link href="http://www.leonardoborges.com/writings/atom-clojure.xml" rel="self"/>
  <link href="http://www.leonardoborges.com/writings/"/>
  <updated>2018-02-19T20:38:30+11:00</updated>
  <id>http://www.leonardoborges.com/writings/</id>
  <author>
    <name><![CDATA[Leonardo Borges]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mission accomplished]]></title>
    <link href="http://www.leonardoborges.com/writings/2016/05/27/mission-accomplished/"/>
    <updated>2016-05-27T17:40:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2016/05/27/mission-accomplished</id>
    <content type="html"><![CDATA[<p>A year and four months ago <a href="http://www.leonardoborges.com/writings/2014/12/27/staring-a-new-chapter/">I joined Atlassian</a> to pursue a very exciting opportunity: to deliver realtime collaborative editing to Confluence. I have talked about it last year at <a href="https://www.youtube.com/watch?v=3QR8meTrh5g&amp;index=16&amp;list=PLZdCLR02grLoBx0Y5ZrpdmLxc160PIwzQ">EuroClojure</a> and this year at <a href="http://qconsp.com/presentation/colabora%C3%A7%C3%A3o-em-tempo-real-com-clojure-e-clojurescript%E2%80%8B">QCon Brazil</a>. Even <a href="http://www.cognitect.com/">Cognitect</a> wrote <a href="http://blog.cognitect.com/blog/2015/7/21/atlassian-builds-realtime-collaboration-services-with-clojure">a few words about it</a>.</p>

<p>In a nutshell this involved writing Clojure code all day to build an awesome service we call Synchrony. Synchrony is capable of realtime data synchronisation - not just collaborative editing - and as such its applications are many! This has been proven again and again internally during the Atlassian ShipIt hackatons, and externally via <a href="https://enso.me/">Enso.me</a>, which is powered by Synchrony.</p>

<p>Throughout this journey I took on more responsibility and transitioned into the Development Team Lead role. This gave me the opportunity to help drive the product roadmap and vision within the company in addition to leading a very capable team. What an amazing learning experience it has been!</p>

<h3>Today</h3>

<p>Fast-forward to today and collaborative editing is finally being used by real customers as part of our early access program! It&#8217;s been a great journey and we have achieved a huge milestone!</p>

<p>For a more up to date look at Synchrony I highly recommend <a href="https://twitter.com/draftkraft">Haymo Meran</a>&#8217;s presentation at <a href="https://www.youtube.com/watch?v=EgCYd6ei7QI">this year&#8217;s AtlasCamp</a>. Haymo is a friend and one of the original founders of Wikidocs, the company where the technology behind Synchrony was originally developed.</p>

<p>I&#8217;m really proud of what we have accomplished and it&#8217;s a great moment to look for a change, again :)</p>

<h3>The future</h3>

<p>Yes, I am leaving Atlassian - last day is June 17th. I&#8217;ll be moving on to a new opportunity about which I&#8217;m really excited. But that is the subject of another blog post :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Clojure Sydney Meetup, four years in]]></title>
    <link href="http://www.leonardoborges.com/writings/2016/02/08/the-clojure-sydney-meetup-four-years-in/"/>
    <updated>2016-02-08T12:43:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2016/02/08/the-clojure-sydney-meetup-four-years-in</id>
    <content type="html"><![CDATA[<h2>In the beginning</h2>

<p>Nearly 4 years ago I founded the Sydney Clojure User Group. I had been playing with Clojure for a little while
and started a small study group to learn more. Initially this group was private and held at the ThoughtWorks office.</p>

<p>After a couple of meetups and conversations I decided to open up the group to the public and then realised we weren&#8217;t the only ones interested in Clojure and, even more important, interested in meeting like-minded people, share experiences and help each other.</p>

<p>Back then none of us used Clojure for anything serious. Apart from Steve. Steve is a brave man and was building his new startup on top of Clojure. This was a great source of inspiration and learning for all of us. Steve hired Harry and Harry told us first hand what using Clojure for work could be like.</p>

<p>For all of us hobbyist Clojurists, this was a great start.</p>

<p>Since then we&#8217;ve held 37 meetups with an average of 22.25 attendees per meetup. These numbers won&#8217;t impress many people, no doubt about that. What is impressive however is how it&#8217;s changed over the years.</p>

<h2>Where are we at?</h2>

<p>Last December I sent out a survey and the result for one of the questions made me smile. The question was: <em>Do you currently use Clojure in your day job?</em></p>

<p><img class="center border" src="http://www.leonardoborges.com/writings/assets/images/working-with-clojure-survey-results.png" width="541" height="195"></p>

<p>This is absolutely amazing. It&#8217;s great to see how much the community has matured. Nearly 50% of meetup attendees currently work with Clojure in Sydney! I&#8217;m fortunate to say I can <a href="http://www.leonardoborges.com/writings/2014/12/27/staring-a-new-chapter/">include myself towards this milestone</a>!</p>

<h2>Going forward</h2>

<p>We&#8217;re now in 2016 and the group shows no signs of slowing down. In fact, we&#8217;re picking up the pace a little and starting the new year with a new venue: from now on we&#8217;ll be meeting at <a href="https://www.atlassian.com/">Atlassian</a>!</p>

<p>I would like to thank ThoughtWorks for all the support in starting and running the meetup. I wouldn&#8217;t have been able to do it if it wasn&#8217;t for them.</p>

<p>See you at the <a href="http://www.meetup.com/clj-syd/events/228691721/">next meetup</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Reactive Programming has been published]]></title>
    <link href="http://www.leonardoborges.com/writings/2015/03/27/clojure-reactive-programming-has-been-published/"/>
    <updated>2015-03-27T15:10:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2015/03/27/clojure-reactive-programming-has-been-published</id>
    <content type="html"><![CDATA[<p>I&#8217;m extremely happy to let everyone know my book, <a href="https://www.packtpub.com/web-development/clojure-reactive-programming">Clojure Reactive Programming</a>, has finally been published!</p>

<p>You can get it at the <a href="https://www.packtpub.com/web-development/clojure-reactive-programming">publisher&#8217;s website</a> or on <a href="http://www.amazon.com/Clojure-Reactive-Programming-Leonardo-Borges/dp/1783986662/ref=sr_1_1?ie=UTF8&amp;qid=1427205216&amp;sr=8-1&amp;keywords=Clojure+Reactive+Programming">Amazon</a>. I had a great time writing it and I truly hope you find it useful!</p>

<p>I&#8217;ve met a few authors here and there and I heard more than once that a book is never really finished. I now know what they mean.</p>

<p>The book doesn&#8217;t cover everything I wanted to write about due to time and space limitations. Having said that, now that the book is out I do plan to expand on a few things using this blog.</p>

<p>Stay tuned!</p>

<p>Thanks to everyone who gave me feedback on early drafts of the book! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ClojureBridge Sydney, vol. I]]></title>
    <link href="http://www.leonardoborges.com/writings/2014/12/22/clojurebridge-sydney/"/>
    <updated>2014-12-22T18:18:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2014/12/22/clojurebridge-sydney</id>
    <content type="html"><![CDATA[<p>This past weekend - 19-20th of December - a group of highly motivated individuals gave up their Friday night and their entire Saturday simply to learn how to code in Clojure!</p>

<p>It was the first ever <a href="http://www.clojurebridge.org/">ClojureBridge</a> edition in Sydney and if you haven&#8217;t heard of it before, its goal is to increase diversity in the Clojure community. It does so by offering free workshops targeted at beginners.</p>

<p>You should totally read <a href="http://juliangamble.com/blog/2014/12/20/why-clojurebridge-is-awesome/">Julian Gamble&#8217;s post</a> about the event for details. He&#8217;s was one of the volunteers on the day and has done a great job of describing his experiences.</p>

<p>I just wanted to take the opportunity to highlight and thank all volunteers who also gave up their time for free to help and coach 24 people eager to learn Clojure. They are: Alexandra Luca, <a href="https://twitter.com/claudionatoli">Claudio Natoli</a>, <a href="https://twitter.com/juliansgamble">Julian Gamble</a>, Marcin Nikliborc, <a href="https://twitter.com/novemberkilo">Navin K</a>, Scott Robinson, <a href="https://twitter.com/svetixbot">Svetlana Filimonova</a> &amp; <a href="https://twitter.com/vineethvarghese">Vineeth Varghese</a>.</p>

<p><img class="left border" src="http://www.leonardoborges.com/writings/assets/images/posts/clojurebridge_cupcakes.jpg" width="231" height="346"></p>

<p>Without you, the event would not have happened!</p>

<p>A big thank you to our main sponsor - <a href="http://www.thoughtworks.com/">ThoughtWorks</a> - who provided the venue, food, drinks and, of course, Clojure cupcakes.</p>

<p>Another big thank you to <a href="https://www.atlassian.com/">Atlassian</a> who gave some cool gifts to our attendees! (Sunnies and hats!).</p>

<p>Last but not least, a <strong>huge</strong> thank you to all attendees who were absolutely stellar and made the event an amazing experience!</p>

<p>I had a blast organising and running the event and hopefully we will have a new edition soon! I hope it ignited the desire to learn even more about Clojure and Functional Programming!</p>

<p>Happy holidays!</p>

<p>λ♥</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EuroClojure 2014 and announcing my book]]></title>
    <link href="http://www.leonardoborges.com/writings/2014/07/20/euroclojure-2014-and-clojure-reactive-programming/"/>
    <updated>2014-07-20T15:50:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2014/07/20/euroclojure-2014-and-clojure-reactive-programming</id>
    <content type="html"><![CDATA[<p>A bit late for a EuroClojure 2014 post but I suppose &#8220;better late than never&#8221; applies here.</p>

<p>The best part of every conference is the networking. Meeting new and interesting people is priceless and I did plenty of that - mostly over Polish beer and food. Polish beer isn&#8217;t the greatest but if you must have it, better stick to Żywiec. It&#8217;s widely available and was the one which didn&#8217;t give me a headache :) - I&#8217;ve been told there are amazing microbreweries though I didn&#8217;t get a chance to try any while in Krákow.</p>

<p>The food on the other hand was excellent every single time. But I digress.</p>

<p>There&#8217;s no point in me describing the talks I watched as someone else has already done a
much better job of it: it&#8217;s all <a href="https://gist.github.com/philandstuff/299cda371c7e74b03f18">in this gist</a> by <a href="https://twitter.com/philandstuff">Philip Potter</a>.</p>

<p>I gave a talk titled <em>Taming Asynchronous Workflows with Functional Reactive Programming</em>. You can check out the <a href="http://www.slideshare.net/borgesleonardo/functional-reactive-programming-compositional-event-systems">slides here</a>. The video will be available in  <a href="https://vimeo.com/100688924">this link</a> soon. I&#8217;ve received a lot of great feedback on it both at the event and afterwards through different channels. I&#8217;m really happy with how it turned out.</p>

<p>In this talk I mentioned publicly for the first time* that I am working on a book called <strong>Clojure Reactive Programming</strong> to be published by <a href="http://www.packtpub.com/">PacktPub</a>. It seemed appropriate to announce it here as well.</p>

<p>As of yet there&#8217;s no set date but I&#8217;m spending most of my free time working on it. I&#8217;d say I have 55% of it done. Feel free to ping me directly if you&#8217;d like to know more. Alternatively you might want to follow the <a href="https://twitter.com/CljReactiveProg">twitter account I created for the book</a>.</p>

<p>There&#8217;s not much there yet but I&#8217;ll try and post book updates somewhat regularly.</p>

<p>See you around.</p>

<p>* <em>Strictly not true as I&#8217;ve announced it before but this was the first time for a wider Clojure audience and the first time captured on camera so there&#8217;s no denying now ;)</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Validation and Internationalization in Clojure with bouncer &amp; tower]]></title>
    <link href="http://www.leonardoborges.com/writings/2014/01/04/validation-and-internationalization-in-clojure-with-bouncer-and-tower/"/>
    <updated>2014-01-04T19:00:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2014/01/04/validation-and-internationalization-in-clojure-with-bouncer-and-tower</id>
    <content type="html"><![CDATA[<p>I released <a href="https://github.com/leonardoborges/bouncer">bouncer</a> in April last year and since then it has had a small but steady growth in usage.</p>

<p>So much so that I received some community feedback in the form of emails and pull requests which is simply <em>great</em>!</p>

<p>The latest and most substantial pull request, submitted by <a href="https://github.com/dm3">Vadim Platonov</a>, added the ability to customise validation messages in anyway you like, as you can see in the section <a href="https://github.com/leonardoborges/bouncer#internationalization-and-customised-error-messages">Internationalization and customised error messages</a> of the <a href="https://github.com/leonardoborges/bouncer/blob/master/README.md">README</a>.</p>

<p>However the documentation only gives a simple example and while I believe it should show users how this opens up several different usage patterns, I thought I&#8217;d expand that in this post and integrate <a href="https://github.com/leonardoborges/bouncer">bouncer</a> with the excellent Internationalization library <a href="https://github.com/ptaoussanis/tower">tower</a> to show how validation and I18n could work together in this configuration.</p>

<blockquote><p>If you&#8217;ve never used bouncer before, I&#8217;d recommend you have a quick look at the <a href="https://github.com/leonardoborges/bouncer#basic-validations">Basic Validations</a> section of the <a href="https://github.com/leonardoborges/bouncer/blob/master/README.md">README</a> before continuing.</p></blockquote>

<h2>Setup</h2>

<p>The first thing you&#8217;ll need to do is create a new leiningen project and add both <a href="https://github.com/leonardoborges/bouncer">bouncer</a> and <a href="https://github.com/ptaoussanis/tower">tower</a> as dependencies in your <code>project.clj</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">[</span><span class="nv">bouncer</span> <span class="s">&quot;0.3.1-beta1&quot;</span><span class="p">]</span>
</span><span class='line'><span class="p">[</span><span class="nv">com</span><span class="o">.</span><span class="nv">taoensso/tower</span> <span class="s">&quot;2.0.1&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Next, in your <code>core</code> namespace - or wherever, really - require both libs and set up a dictionary to be used in the examples:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">ns</span> <span class="nv">bouncer+tower</span><span class="o">.</span><span class="nv">core</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">:require</span> <span class="p">[</span><span class="nv">taoensso</span><span class="o">.</span><span class="nv">tower</span> <span class="nv">:as</span> <span class="nv">tower</span>
</span><span class='line'>             <span class="nv">:refer</span> <span class="p">(</span><span class="nf">with-locale</span> <span class="nv">with-tscope</span> <span class="nv">t</span> <span class="nv">*locale*</span><span class="p">)]</span>
</span><span class='line'>            <span class="p">[</span><span class="nv">bouncer</span><span class="o">.</span><span class="nv">core</span> <span class="nv">:refer</span> <span class="p">[</span><span class="nv">validate</span><span class="p">]]</span>
</span><span class='line'>            <span class="p">[</span><span class="nv">bouncer</span><span class="o">.</span><span class="nv">validators</span> <span class="nv">:as</span> <span class="nv">v</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">my-tconfig</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:dev-mode?</span> <span class="nv">true</span>
</span><span class='line'>   <span class="nv">:fallback-locale</span> <span class="nv">:en</span>
</span><span class='line'>   <span class="nv">:dictionary</span>
</span><span class='line'>   <span class="p">{</span><span class="nv">:en</span>
</span><span class='line'>    <span class="p">{</span><span class="nv">:person</span>  <span class="p">{</span><span class="nv">:name</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;A person must have a name&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:age</span>  <span class="p">{</span><span class="nv">:number</span>   <span class="s">&quot;A person&#39;s age must be a number. You provided &#39;%s&#39;&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:address</span> <span class="p">{</span><span class="nv">:postcode</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;Missing postcode in address&quot;</span><span class="p">}}}</span>
</span><span class='line'>     <span class="nv">:missing</span>  <span class="s">&quot;&lt;Missing translation: [%1$s %2$s %3$s]&gt;&quot;</span><span class="p">}</span>
</span><span class='line'>    <span class="nv">:pt-BR</span>
</span><span class='line'>    <span class="p">{</span><span class="nv">:person</span>  <span class="p">{</span><span class="nv">:name</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;Atributo Nome para Pessoa é obrigatório.&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:age</span>  <span class="p">{</span><span class="nv">:number</span>   <span class="s">&quot;Atributo Idade para Pessoa deve ser um número. Valor recebido foi &#39;%s&#39;&quot;</span><span class="p">}</span>
</span><span class='line'>               <span class="nv">:address</span> <span class="p">{</span><span class="nv">:postcode</span> <span class="p">{</span><span class="nv">:required</span> <span class="s">&quot;Endereço deve ter um código postal&quot;</span><span class="p">}}}</span>
</span><span class='line'>     <span class="nv">:missing</span>  <span class="s">&quot;&lt;Tradução ausente: [%1$s %2$s %3$s]&gt;&quot;</span><span class="p">}}})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Also, we need someting to validate so go ahead and create a map representing a person:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">person</span> <span class="p">{</span><span class="nv">:age</span> <span class="s">&quot;NaN&quot;</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Customising bouncer</h2>

<p>Since <code>0.3.1-beta1</code>, <a href="https://github.com/leonardoborges/bouncer">bouncer</a>&#8217;s <code>validate</code> function receives an optional first argument called <em>message-fn</em>. As the name implies, it is a function from <em>error metadata</em> to, most likely, a string. This is our opportunity to use tower&#8217;s features to translate our error messages.</p>

<p>In order to accomplish that, we&#8217;ll be using this message function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">message-fn</span>
</span><span class='line'>  <span class="s">&quot;Receives a locale, tscope and a map containing error metadata.</span>
</span><span class='line'>
</span><span class='line'><span class="s">  Uses this information to return a I18n&#39;ed string&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">locale</span> <span class="nv">tscope</span> <span class="p">{</span><span class="nv">:keys</span> <span class="p">[</span><span class="nv">path</span> <span class="nv">value</span><span class="p">]</span>
</span><span class='line'>                  <span class="p">{</span><span class="nv">validator</span> <span class="nv">:validator</span><span class="p">}</span> <span class="nv">:metadata</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">tr-key</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">flatten</span> <span class="p">[</span><span class="nv">path</span> <span class="nv">validator</span><span class="p">])</span>
</span><span class='line'>                    <span class="p">(</span><span class="nb">map </span><span class="nv">name</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">clojure</span><span class="o">.</span><span class="nv">string/join</span> <span class="s">&quot;/&quot;</span><span class="p">)</span>
</span><span class='line'>                    <span class="nv">keyword</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">with-tscope</span> <span class="nv">tscope</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">t</span> <span class="nv">locale</span> <span class="nv">my-tconfig</span> <span class="nv">tr-key</span> <span class="nv">value</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In order to understand the function above, let&#8217;s validate the person map using <code>identity</code> so we can inspect the error metadata that will be the third argument to this function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="nv">identity</span>
</span><span class='line'>          <span class="nv">person</span>
</span><span class='line'>          <span class="nv">:name</span> <span class="nv">v/required</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [{:name</span>
</span><span class='line'><span class="c1">;;   ({:path [:name],</span>
</span><span class='line'><span class="c1">;;     :value nil,</span>
</span><span class='line'><span class="c1">;;     :args nil,</span>
</span><span class='line'><span class="c1">;;     :metadata</span>
</span><span class='line'><span class="c1">;;     {:optional false,</span>
</span><span class='line'><span class="c1">;;      :default-message-format &quot;%s must be present&quot;,</span>
</span><span class='line'><span class="c1">;;      :validator :bouncer.validators/required},</span>
</span><span class='line'><span class="c1">;;     :message nil})}</span>
</span><span class='line'><span class="c1">;;  {:age &quot;NaN&quot;,</span>
</span><span class='line'><span class="c1">;;   :bouncer.core/errors</span>
</span><span class='line'><span class="c1">;;   {:name</span>
</span><span class='line'><span class="c1">;;    ({:path [:name],</span>
</span><span class='line'><span class="c1">;;      :value nil,</span>
</span><span class='line'><span class="c1">;;      :args nil,</span>
</span><span class='line'><span class="c1">;;      :metadata</span>
</span><span class='line'><span class="c1">;;      {:optional false,</span>
</span><span class='line'><span class="c1">;;       :default-message-format &quot;%s must be present&quot;,</span>
</span><span class='line'><span class="c1">;;       :validator :bouncer.validators/required},</span>
</span><span class='line'><span class="c1">;;      :message nil})}}]</span>
</span></code></pre></td></tr></table></div></figure>


<p>As we&#8217;re only validating the name in this case, that&#8217;s all we get in the return value of <code>validate</code>. However you can see how we have all sorts of useful information now - hopefully this makes the <code>message-fn</code> code above easier to understand.</p>

<h2>Take it for a spin</h2>

<p>We&#8217;re now ready for a couple of examples, using two different locales. Let&#8217;s get on with it:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">message-fn</span> <span class="nv">:en</span> <span class="nv">:person</span><span class="p">)</span>
</span><span class='line'>          <span class="nv">person</span>
</span><span class='line'>          <span class="nv">:name</span> <span class="nv">v/required</span>
</span><span class='line'>          <span class="nv">:age</span>  <span class="nv">v/number</span>
</span><span class='line'>          <span class="p">[</span><span class="nv">:address</span> <span class="nv">:postcode</span><span class="p">]</span> <span class="nv">v/required</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [{:address {:postcode (&quot;Missing postcode in address&quot;)},</span>
</span><span class='line'><span class="c1">;;   :age (&quot;A person&#39;s age must be a number. You provided &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;   :name (&quot;A person must have a name&quot;)}</span>
</span><span class='line'><span class="c1">;;  {:age &quot;NaN&quot;,</span>
</span><span class='line'><span class="c1">;;   :bouncer.core/errors</span>
</span><span class='line'><span class="c1">;;   {:address {:postcode (&quot;Missing postcode in address&quot;)},</span>
</span><span class='line'><span class="c1">;;    :age (&quot;A person&#39;s age must be a number. You provided &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;    :name (&quot;A person must have a name&quot;)}}]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now let&#8217;s get some messages in portuguese, shall we?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">message-fn</span> <span class="nv">:pt-BR</span> <span class="nv">:person</span><span class="p">)</span>
</span><span class='line'>          <span class="nv">person</span>
</span><span class='line'>          <span class="nv">:name</span> <span class="nv">v/required</span>
</span><span class='line'>          <span class="nv">:age</span>  <span class="nv">v/number</span>
</span><span class='line'>          <span class="p">[</span><span class="nv">:address</span> <span class="nv">:postcode</span><span class="p">]</span> <span class="nv">v/required</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [{:address {:postcode (&quot;Endereço deve ter um código postal&quot;)},</span>
</span><span class='line'><span class="c1">;;   :age</span>
</span><span class='line'><span class="c1">;;   (&quot;Atributo Idade para Pessoa deve ser um número. Valor recebido foi &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;   :name (&quot;Atributo Nome para Pessoa é obrigatório.&quot;)}</span>
</span><span class='line'><span class="c1">;;  {:age &quot;NaN&quot;,</span>
</span><span class='line'><span class="c1">;;   :bouncer.core/errors</span>
</span><span class='line'><span class="c1">;;   {:address {:postcode (&quot;Endereço deve ter um código postal&quot;)},</span>
</span><span class='line'><span class="c1">;;    :age</span>
</span><span class='line'><span class="c1">;;    (&quot;Atributo Idade para Pessoa deve ser um número. Valor recebido foi &#39;NaN&#39;&quot;),</span>
</span><span class='line'><span class="c1">;;    :name (&quot;Atributo Nome para Pessoa é obrigatório.&quot;)}}]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In case you&#8217;re too lazy to do this all from scratch, I created a github repo containing this example ready for you to play with. <a href="https://github.com/leonardoborges/bouncer-tower">Go get it</a>.</p>

<h2>Conclusion</h2>

<p>Hopefully this gives you a little taste of what you can do with the latest version of <a href="https://github.com/leonardoborges/bouncer">bouncer</a>. Remember this is but one of many ways you could integrate the library so get creative :)</p>

<p>Once again, thanks to <a href="https://github.com/dm3">Vadim Platonov</a> for submitting this pull request.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CUFP/ICFP 2013]]></title>
    <link href="http://www.leonardoborges.com/writings/2013/09/25/cufp-slash-icfp-2013/"/>
    <updated>2013-09-25T13:17:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2013/09/25/cufp-slash-icfp-2013</id>
    <content type="html"><![CDATA[<p>I&#8217;m sitting in the Lobby of the Hilton in Boston and since my flight back to Australia isn&#8217;t for a few hours I thought I&#8217;d write my experience report while everything is still fresh in my mind.</p>

<p><img class="left" src="http://www.leonardoborges.com/writings/assets/images/posts/cufp2013-badge.jpg" width="318" height="400"></p>

<p><a href="http://cufp.org/">CUFP - Commercial Users of Functional Programming -</a> is a Workshop-like conference targeting the practically-minded functional programming community.</p>

<p>As it&#8217;s stated on their website, <em>&#8220;The CUFP workshop is a place where people can see how others are using functional programming to solve real world problems […]&#8221;</em>.</p>

<p>One of the things that make the event special is that it runs together with <a href="http://icfpconference.org/icfp2013/">ICFP - International Conference on Functional Programming</a> - which is an event on the far opposite side of the spectrum with language designers, professors, compiler implementors getting together and thinking about the future of their languages and fields. The diversity of the event is astonishing.</p>

<p>CUFP itself runs for three days and is divided into a traditional conference format day with several talks and two tutorial days.</p>

<p>I was there for all three days and on the last one I delivered my own tutorial about writing macros in Clojure - more on that later.</p>

<p>As far as the talks of day 1 go, someone already did a great job of summarising them. I highly recommend <a href="http://www.syslog.cl.cam.ac.uk/2013/09/22/liveblogging-cufp-2013/">you go read it</a>.</p>

<h3>Day 2</h3>

<p>In total there were 9 tutorials being offered - two of which made up a two-day Haskell tutorial. That&#8217;s the one I decided to attend.</p>

<p>In the instructions, the instructors mentioned that we could use an online Haskell IDE to follow the course should we choose not to install the Haskell platform on our laptops.</p>

<p>I decided to give it a go. The tool is called FP Haskell Center and has been developed by the awesome guys at <a href="https://www.fpcomplete.com">FP Complete</a>.</p>

<p>It&#8217;s important to note this is an online IDE - but the editor isn&#8217;t the only thing being offered though. The Haskell Centre offers a complete deployment solution as well - though I didn&#8217;t have the chance to play with it.</p>

<p>Back to the tutorial, I used the FP Haskell Centre for day one and it worked great as far as online IDEs go. Compilation and inspecting types do suffer from the round trip over the web and by the end of the day I was feeling a little frustrated with all the waiting. The tool is great and if they offered an offline version, I&#8217;m sure the experience would have been improved tenfold.</p>

<p>Day one was taught by <a href="http://www.well-typed.com/people/andres">Andres Löh</a> from <a href="http://www.well-typed.com/">Well-Typed</a>, a Haskell consultancy.</p>

<p>It was full of exercises in the various basics of Haskell such as expressions, functions, IO, pattern matching and even Monads. I had a lot of fun working through them and it reinforced my opinion about Haskell being as practical a language as any other - but with several advantages.</p>

<h3>Day 3</h3>

<p>Given my frustration with FP Haskell Center being a bit slow I decided to install the Haskell platform on my new laptop and configure emacs with haskell-mode. I was <em>much</em> happier with this setup. haskell-mode has a lot of nifty features that were extremely useful during the tutorial.</p>

<p>The second day of the Haskell tutorial gave way to <a href="http://community.haskell.org/~simonmar/">Simon Marlow</a>, a software engineer from Facebook UK and author of  <a href="http://community.haskell.org/~simonmar/pcph/">Parallel and Concurrent Programming in Haskell</a> - also available freely <a href="http://chimera.labs.oreilly.com/books/1230000000929/index.html">online</a>.</p>

<p>Not surprisingly, his half of the tutorial was about Concurrency. We started with several exercises on IO involving more Monadic functions that we hadn&#8217;t learned the previous day. We then moved on to study the basic Haskell concurrency constructs and primitives. All very interesting stuff.</p>

<p>If you have the chance to attend a tutorial by these guys, do yourself a favour and go for it.</p>

<h3>Day 3 - 2pm onwards</h3>

<p>Unfortunately I missed the second half of the second day as I, too, had to deliver my own tutorial/workshop.</p>

<p>Titled <em>&#8220;Bending Clojure to your will: Macros and Domain Specific Languages&#8221;</em>, the tutorial had participants work their way through several difference exercises aimed at teaching the various nuances of writing macros.</p>

<p>The tutorial has failing tests for all exercises so it&#8217;s dead easy to know when you have arrived at a solution - all participants seemed to have had a great time learning this stuff and I even saw a couple of positive tweets about it - I&#8217;m really happy with how everything went.</p>

<p>The best tweet though was the one saying that someone from the Haskell tutorial decided to switch to mine half-way through. So I see that as a win :) <a href="https://twitter.com/prasincs/status/382585215694413824">Here&#8217;s said tweet</a>.</p>

<p>I&#8217;ve <a href="https://github.com/leonardoborges/clojure-macros-workshop">pushed the exercises to github</a> should you want to try them by yourself. <a href="http://www.slideshare.net/borgesleonardo/clojure-macros-workshop-lambdajam-2013-cufp-2013">Slides are also available</a> though they will likely not make sense out of context.</p>

<p>Enjoy! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Purely functional data structures in Clojure: Red-Black Trees]]></title>
    <link href="http://www.leonardoborges.com/writings/2013/07/15/purely-functional-data-structures-in-clojure-red-black-trees/"/>
    <updated>2013-07-15T21:42:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2013/07/15/purely-functional-data-structures-in-clojure-red-black-trees</id>
    <content type="html"><![CDATA[<blockquote><p>This post is part of a series about Chris Okasaki&#8217;s <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a>. You can see all posts in the series by visiting the <a href="http://www.leonardoborges.com/writings/tags/functional-data-structures/">functional-data-structures</a> category in this blog.</p></blockquote>

<hr />

<p>Recently I had some free time to come back to <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a> and implement a new data structure: <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-black trees</a>.</p>

<h3>Red-black trees</h3>

<p><a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-black trees</a> are a type of <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">self-balancing binary search tree</a>. Back when I first learned the balancing algorithm used in operations such as insert and delete, I remember it being a particularly tricky one.</p>

<p>Traditionally, red-black trees are implemented destructively - meaning insertions and deletions happen in place. So in imperative languages like C or Java there is a lot of node pointer manipulation floating around, making this algorithm error prone.</p>

<p>This post, as its title implies, will deal with the functional implementation which, besides simpler, is also persistent.</p>

<h4>Invariants</h4>

<p>A big disadvantage of binary search trees is that they operate poorly on sorted data with O(N) worst case, pretty much becoming nothing more than a linked list.</p>

<p>This is where Red-black trees come in: when inserting/removing new nodes, the tree balances itself thus guaranteeing search times of O(logN). It does so by satisfying two invariants:</p>

<ul>
<li>No red nodes can have red children</li>
<li>Every path from the root to an empty node contains the same number of black nodes</li>
</ul>


<p>The image below - taken from the book itself - concisely summarises the 4 cases involved in these invariants, starting at the top and then moving counter-clockwise.</p>

<p><img class="center" src="http://www.leonardoborges.com/writings/assets/images/posts/red-black-tree.jpg" width="250" height="333" title="Red-black trees invariants" ></p>

<p>With this in mind I set out to write the <em>balance</em> function in Clojure.</p>

<h3>The code</h3>

<p>In the functional version of a Red-black tree all pointer manipulation required in its destructive counterpart simply disappears, rendering the algorithm a lot simpler.</p>

<p>Nevertheless, we&#8217;re left with some complexity in the <em>balance</em> function around testing a node&#8217;s colour as well as its children&#8217;s and grandchildren&#8217;s.</p>

<p>My first attempt at writing it started like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">mk-tree</span> <span class="p">[</span><span class="nv">color</span> <span class="nv">left</span> <span class="nv">value</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:color</span> <span class="nv">color</span> <span class="nv">:left</span> <span class="nv">left</span> <span class="nv">:value</span> <span class="nv">value</span> <span class="nv">:right</span> <span class="nv">right</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>    <span class="c1">;; case 1</span>
</span><span class='line'>    <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nv">z</span> <span class="nv">:value</span> <span class="nv">d</span> <span class="nv">:right</span><span class="p">}</span> <span class="nv">tree</span>
</span><span class='line'>          <span class="p">{</span><span class="nv">x-color</span> <span class="nv">:color</span> <span class="nv">x</span> <span class="nv">:value</span> <span class="nv">a</span> <span class="nv">:left</span><span class="p">}</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">tree</span> <span class="nv">:left</span><span class="p">)</span>
</span><span class='line'>          <span class="p">{</span><span class="nv">y-color</span> <span class="nv">:color</span> <span class="nv">y</span> <span class="nv">:value</span> <span class="nv">b</span> <span class="nv">:left</span> <span class="nv">c</span> <span class="nv">:right</span><span class="p">}</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">tree</span> <span class="nv">:left</span> <span class="nv">:right</span><span class="p">)</span>
</span><span class='line'>          <span class="nv">d</span> <span class="p">(</span><span class="nf">:right</span> <span class="nv">tree</span><span class="p">)]</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">x-color</span> <span class="nv">:red</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">y-color</span> <span class="nv">:red</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:red</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                    <span class="nv">y</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>        <span class="nv">tree</span><span class="p">)</span>
</span><span class='line'>        <span class="o">...</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>I was extremely unhappy with this. A lot of boilerplate around bindings and tests. And this is only the first case.</p>

<p>But if you read Okasaki&#8217;s implementation of the algorithm in ML - or Haskell -  you&#8217;ll quickly realise how concise and elegant it is. The main reason for that is pattern matching, something we don&#8217;t have built-in in Clojure.</p>

<p>However, Clojure is a Lisp and has a powerful macros system at its disposal. That has given us <a href="https://github.com/clojure/core.match">core.match</a>, a pattern matching library for Clojure.</p>

<h4>core.match</h4>

<p>Using core.match, I rewrote my <em>balance</em> function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">match</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>         <span class="p">[(</span><span class="nf">:or</span> <span class="p">{</span><span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                       <span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span> <span class="nv">:left</span> <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span> <span class="nv">:right</span> <span class="nv">b</span><span class="p">}</span>
</span><span class='line'>                       <span class="nv">:value</span> <span class="nv">y</span> <span class="nv">:right</span> <span class="nv">c</span><span class="p">}</span>
</span><span class='line'>                <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>               <span class="p">{</span><span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                       <span class="nv">:left</span>  <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span>
</span><span class='line'>                       <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span> <span class="nv">:value</span> <span class="nv">y</span> <span class="nv">:left</span> <span class="nv">b</span> <span class="nv">:right</span> <span class="nv">c</span><span class="p">}}</span>
</span><span class='line'>                <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>               <span class="p">{</span><span class="nv">:left</span> <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span>
</span><span class='line'>                <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                        <span class="nv">:left</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                               <span class="nv">:left</span> <span class="nv">b</span> <span class="nv">:value</span> <span class="nv">y</span> <span class="nv">:right</span> <span class="nv">c</span><span class="p">}</span>
</span><span class='line'>                        <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}}</span>
</span><span class='line'>
</span><span class='line'>               <span class="p">{</span><span class="nv">:left</span> <span class="nv">a</span> <span class="nv">:value</span> <span class="nv">x</span>
</span><span class='line'>                <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                        <span class="nv">:left</span> <span class="nv">b</span> <span class="nv">:value</span> <span class="nv">y</span>
</span><span class='line'>                        <span class="nv">:right</span> <span class="p">{</span><span class="nv">:color</span> <span class="nv">:red</span>
</span><span class='line'>                                <span class="nv">:left</span> <span class="nv">c</span> <span class="nv">:value</span> <span class="nv">z</span> <span class="nv">:right</span> <span class="nv">d</span><span class="p">}}})]</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:red</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                     <span class="nv">y</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">mk-tree</span> <span class="nv">:black</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>         <span class="nv">:else</span> <span class="nv">tree</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you look closely at the patterns being matched, you&#8217;ll see they cater for all 4 cases and allow for both matching and binding in the same expressions. With only a little over double the size of a single case using the previous function, we now have a fully functioning <em>balance</em> implementation. This is better, but I wanted more.</p>

<p>What I really wanted to be able to write is this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">match</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>           <span class="p">[(</span><span class="nf">:or</span> <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>                 <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">b</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))))]</span> <span class="p">(</span><span class="nf">Red</span><span class="o">.</span> <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>                                                              <span class="nv">y</span>
</span><span class='line'>                                                              <span class="p">(</span><span class="nf">Black</span><span class="o">.</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'>                 <span class="nv">:else</span> <span class="nv">tree</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Unfortunately core.match doesn&#8217;t support records/protocols yet. However, while reading core.match&#8217;s source code, I found a test that implemented the balance algorithm using a different way of representing a tree.</p>

<p>You see, I went with the map approach because I like how you can ask for the specific keys that represent the parts of the tree, such as <em>:color</em>, <em>:left</em>, <em>:value</em> and <em>:right</em>. But if you&#8217;re happy with using positional elements in a vector to represent your tree, our <em>balance</em> function in Clojure becomes this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">match</span> <span class="p">[</span><span class="nv">tree</span><span class="p">]</span>
</span><span class='line'>         <span class="p">[(</span><span class="nf">:or</span> <span class="p">[</span><span class="nv">:black</span> <span class="p">[</span><span class="nv">:red</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">]</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">]</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]</span>
</span><span class='line'>               <span class="p">[</span><span class="nv">:black</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">]]</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]</span>
</span><span class='line'>               <span class="p">[</span><span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">[</span><span class="nv">:red</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">b</span> <span class="nv">y</span> <span class="nv">c</span><span class="p">]</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]]</span>
</span><span class='line'>               <span class="p">[</span><span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">b</span> <span class="nv">y</span> <span class="p">[</span><span class="nv">:red</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]]])]</span> <span class="p">[</span><span class="nv">:red</span> <span class="p">[</span><span class="nv">:black</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">]</span>
</span><span class='line'>                                                            <span class="nv">y</span>
</span><span class='line'>                                                            <span class="p">[</span><span class="nv">:black</span> <span class="nv">c</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">]]</span>
</span><span class='line'>               <span class="nv">:else</span> <span class="nv">tree</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Which is <em>amazingly</em> similar to the protocols/records version above.</p>

<p>I guess one of the lessons here is that by carefully choosing the data structure to represent your problem, your implementation can become substantially simpler.</p>

<p>As usual, <a href="https://github.com/leonardoborges/purely-functional-data-structures">all code is on github</a>, with the Red-black tree specific section in <a href="https://github.com/leonardoborges/purely-functional-data-structures/blob/master/src/purely_functional_data_structures/ch3.clj#L384">this direct link</a>. The project also includes tests.</p>

<p>Until next time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure, core.async and the Lisp advantage]]></title>
    <link href="http://www.leonardoborges.com/writings/2013/07/06/clojure-core-dot-async-lisp-advantage/"/>
    <updated>2013-07-06T18:50:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2013/07/06/clojure-core-dot-async-lisp-advantage</id>
    <content type="html"><![CDATA[<p>Long gone are the days when systems needed to do only one thing at a time.</p>

<p>Concurrency is the word but it often leads to complex code, dealing with locks, mutexes etc…</p>

<p>There are several different abstractions which allows us to both model and think about asynchronous code in a more sane fashion: futures, promises and events/callbacks are but a few of them.</p>

<p>I won&#8217;t get into the merits - or lack thereof - of these alternatives in this post but rather focus on a different alternative: <a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes - CSP</a>.</p>

<h3>CSP and Go</h3>

<p>CSP isn&#8217;t new. It was first described in 1978 by <a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a> and languages such as <a href="http://bit.ly/14rEwxU">Occam</a> and <a href="http://bit.ly/14rEAh7">Erlang</a> stem from it.</p>

<p>It has however gained momentum by being natively supported by the <a href="http://bit.ly/11ZvMzj">Go programming language</a>.</p>

<p>I haven&#8217;t read Hoare&#8217;s paper so I&#8217;ll use a little bit of what I know about Go&#8217;s implementation of CSP.</p>

<p>Go introduced the concept of a <code>goroutine</code>. It <em>looks</em> like a function call:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// doing some stuff...</span>
</span><span class='line'><span class="k">go</span> <span class="n">myFunction</span><span class="p">(</span><span class="s">&quot;argument&quot;</span><span class="p">)</span> <span class="c1">//does stuff in the background...</span>
</span><span class='line'><span class="c1">//continuing about my business...</span>
</span></code></pre></td></tr></table></div></figure>


<p>What this does is it creates a <em>lightweight</em> process and returns control immediately to the caller.</p>

<p>It is <em>lightweight</em> because it doesn&#8217;t map 1-1 to native OS threads.</p>

<p>The reasoning behind it is that creating too many threads can bring your machine (or VM) down due to the amount of stack allocated to each one.</p>

<p><code>goroutines</code> are cheap to create so you can have hundreds of thousands of them, and the runtime will multiplex them into a thread pool.</p>

<p>The immediate advantage is that it is dead simple to achieve a higher degree of concurrency.</p>

<p>So far it sounds awfully similar to using futures with a pre-configured thread pool and a bit of syntactic sugar. But this is not the end of it.</p>

<h3>Communication</h3>

<p><code>goroutines</code> really shine when your several lightweight processes need to talk to each other. This is where a new abstraction comes into play:<code>channels</code>.</p>

<p>Channels are first-class citizens - meaning you can pass them as arguments to functions as well as the return value of functions.</p>

<p>Using them is straightforward:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="n">c</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="nb">string</span><span class="p">)</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">time</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">Duration</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
</span><span class='line'>  <span class="n">c</span> <span class="p">&lt;-</span> <span class="s">&quot;Leo&quot;</span>
</span><span class='line'><span class="p">}()</span>
</span><span class='line'><span class="n">fmt</span><span class="p">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">&quot;Hello: %s\n&quot;</span><span class="p">,</span> <span class="p">&lt;-</span><span class="n">c</span><span class="p">)</span> <span class="c1">//this will block until the channel has something to give us </span>
</span></code></pre></td></tr></table></div></figure>


<p>The code above creates a goroutine from an anonymous-executing function that will, in the background, sleep for 5 seconds and then send the string <code>Leo</code> to the channel <code>c</code>. Since control is returned immediately after that, the call blocks on the next line where it&#8217;s trying to read a value from the channel using the <code>&lt;-c</code> statement.</p>

<h3>Lisp</h3>

<p>&#8220;But What does all this have to do with Lisp?&#8221; - ah! I&#8217;m glad you asked.</p>

<p>It actually has more to do with <a href="http://clojure.org/">Clojure</a> - and by extension, Lisp.</p>

<p><a href="http://clojure.org/">Clojure</a> is a modern Lisp for the JVM, built for concurrency. The core team recently released <a href="https://github.com/clojure/core.async">core.async</a>, a new library that adds support for asynchronous programming much in the same way Go does with goroutines.</p>

<p>To highlight the similarities, I&#8217;ll show and translate a couple of the examples from Rob Pike&#8217;s presentation, <a href="http://talks.golang.org/2012/concurrency.slide#1">Go Concurrency patterns</a>.</p>

<h4>Setting the scene</h4>

<p>Say you&#8217;re Google. And you need to write code that takes user input, - a search string - hits 3 different search services, - web, images and video - aggregates the results and presents them to the user.</p>

<p>Since they are three different services, you wish to do this concurrently.</p>

<p>To simulate these services, Rob presented a function that has unpredictable performance based of a random amount of sleep, shown below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="k">var</span> <span class="p">(</span>
</span><span class='line'>    <span class="n">Web</span>   <span class="p">=</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="s">&quot;web&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Image</span> <span class="p">=</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="s">&quot;image&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Video</span> <span class="p">=</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="s">&quot;video&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">type</span> <span class="n">Search</span> <span class="k">func</span><span class="p">(</span><span class="n">query</span> <span class="nb">string</span><span class="p">)</span> <span class="n">Result</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">fakeSearch</span><span class="p">(</span><span class="n">kind</span> <span class="nb">string</span><span class="p">)</span> <span class="n">Search</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">query</span> <span class="nb">string</span><span class="p">)</span> <span class="n">Result</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">time</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="p">.</span><span class="n">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
</span><span class='line'>              <span class="k">return</span> <span class="n">Result</span><span class="p">(</span><span class="n">fmt</span><span class="p">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">&quot;%s result for %q\n&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">query</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is one way we could write such function in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">fake-search</span> <span class="p">[</span><span class="nv">kind</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">query</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">lang</span><span class="o">.</span><span class="nv">Math/random</span><span class="p">)</span> <span class="mi">1000</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">str </span><span class="nv">kind</span> <span class="s">&quot; result for &quot;</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">web</span>   <span class="p">(</span><span class="nf">fake-search</span> <span class="s">&quot;Web&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">image</span> <span class="p">(</span><span class="nf">fake-search</span> <span class="s">&quot;Image&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">video</span> <span class="p">(</span><span class="nf">fake-search</span> <span class="s">&quot;Video&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Google Search 2.0</h4>

<p>The first example is the simple case: we hit the services concurrently, wait for them to respond and then return the results:</p>

<blockquote><p>This example is from <a href="http://talks.golang.org/2012/concurrency.slide#46">slide #46</a>.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="k">func</span> <span class="n">Google</span><span class="p">(</span><span class="n">query</span> <span class="nb">string</span><span class="p">)</span> <span class="p">(</span><span class="n">results</span> <span class="p">[]</span><span class="n">Result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">c</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">)</span>
</span><span class='line'>    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Web</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Image</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Video</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">result</span> <span class="p">:=</span> <span class="p">&lt;-</span><span class="n">c</span>
</span><span class='line'>        <span class="n">results</span> <span class="p">=</span> <span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And here&#8217;s the Clojure version:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">google2-0</span> <span class="p">[</span><span class="nv">query</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">web</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">image</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">video</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">results</span> <span class="nv">_</span><span class="p">]</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">conj </span><span class="nv">results</span> <span class="p">(</span><span class="nf">&lt;!!</span> <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">c</span><span class="p">)))))</span>
</span><span class='line'>            <span class="p">[]</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">google2-0</span> <span class="s">&quot;Clojure&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; prints [&quot;Video result for Clojure&quot; &quot;Web result for Clojure&quot; &quot;Image result for Clojure&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <a href="http://clojure.github.io/core.async/#clojure.core.async/%3E!"><code>&gt;!</code></a> operator puts a value into a channel inside a <code>go</code> form. The function then uses <a href="http://clojure.github.io/core.async/#clojure.core.async/&lt;!!"><code>&lt;!!</code></a> to block on the <code>c</code> channel until it gets a value we can use.</p>

<h4>Google Search 2.1</h4>

<p>This is virtually the same example but this time we do not wish to wait on slow servers. So we&#8217;ll return whatever results we have after a pre-defined timeout.</p>

<blockquote><p>This example is from <a href="http://talks.golang.org/2012/concurrency.slide#47">slide #47</a>.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="n">c</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">)</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Web</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Image</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="p">&lt;-</span> <span class="n">Video</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">timeout</span> <span class="p">:=</span> <span class="n">time</span><span class="p">.</span><span class="n">After</span><span class="p">(</span><span class="mi">80</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">select</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">result</span> <span class="p">:=</span> <span class="p">&lt;-</span><span class="n">c</span><span class="p">:</span>
</span><span class='line'>        <span class="n">results</span> <span class="p">=</span> <span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">&lt;-</span><span class="n">timeout</span><span class="p">:</span>
</span><span class='line'>        <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="s">&quot;timed out&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span>
</span></code></pre></td></tr></table></div></figure>


<p>You&#8217;ll notice the use of <code>select</code> here.</p>

<p><code>select</code> waits on multiple channels and returns as soon as <em>any</em> of them has something to say.</p>

<p>The trick of this example is that one of these channels times out, at which point you get the message &#8220;timed out&#8221;, effectively moving on to the next iteration and ignoring that slow server(s) response.</p>

<p>We can express the same intent in Clojure as well:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">google2-1</span> <span class="p">[</span><span class="nv">query</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">t</span> <span class="p">(</span><span class="nf">timeout</span> <span class="mi">500</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">web</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">image</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">video</span> <span class="nv">query</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">results</span> <span class="nv">_</span><span class="p">]</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">conj </span><span class="nv">results</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">alts!!</span> <span class="p">[</span><span class="nv">c</span> <span class="nv">t</span><span class="p">]))))</span>
</span><span class='line'>            <span class="p">[]</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">google2-1</span> <span class="s">&quot;Clojure&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; prints [&quot;Video result for Clojure&quot; nil nil]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Everything looks the same but we&#8217;re using <a href="http://clojure.github.io/core.async/#clojure.core.async/alts!!"><code>alts!!</code></a> to wait on the channels <code>c</code> and <code>t</code> (the timeout channel). This is analogous to Go&#8217;s <code>select</code> form in that it waits for any channel to receive a value or, in this case, to timeout.</p>

<p>Note the <code>nil</code> values. Those came from servers which did not respond in time and were simply ignored.</p>

<p>Effectively what this means is that each time you run this function you&#8217;ll likely get different results, depending on how long the <code>fake-search</code> function takes to run.</p>

<p>Amazing, huh?</p>

<h3>The big deal</h3>

<p>But here&#8217;s the <em>big deal</em> about this: although <a href="https://github.com/clojure/core.async">core.async</a> looks like it&#8217;s deeply integrated into the language, it is <em>just</em> a library!</p>

<p>It&#8217;s not a separate compiler. It&#8217;s not a new language. And it&#8217;s not a special version of Clojure.</p>

<p>Since Clojure supports macros - like all Lisps - the core team was able to create the syntax required to easily use <a href="https://github.com/clojure/core.async">core.async</a>. And that&#8217;s the beauty of it!</p>

<p><em>The Lisp advantage, once again.</em></p>

<h4>Clojure&#8217;s advantage</h4>

<p>Now one thing I haven&#8217;t mentioned is that Clojure is particularly well suited for this - and in a way even more so than Go: Clojure is opinionated and favours immutability.</p>

<p>That means that when using channels - and in fact any type of concurrent programming - you can safely share your data structures between concurrent units of work. Since they&#8217;re immutable, you can&#8217;t shoot yourself in the foot.</p>

<p>One last thing: <a href="https://github.com/clojure/core.async">core.async</a> states as one of its goals Clojurescript compatibility, bringing channel based concurrent programming to the browser. Exciting stuff.</p>

<h3>More on core.async</h3>

<p><a href="https://github.com/clojure/core.async">core.async</a> is still in alpha but you are encouraged to take it for a spin. Documentation is still lacking so I recommend you look at:</p>

<ul>
<li><a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">Rich&#8217;s blog post about it</a></li>
<li><a href="https://github.com/clojure/core.async">The source code on github</a></li>
<li><a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">The walkthrough namespace</a>, which showcases its features.</li>
</ul>


<p>Also, the full Clojure code I used here can be seen in <a href="https://gist.github.com/leonardoborges/5924461">this gist</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Programmers Unite! LambdaJam down under]]></title>
    <link href="http://www.leonardoborges.com/writings/2013/04/11/functional-programmers-unite-lambdajam-down-under/"/>
    <updated>2013-04-11T11:37:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2013/04/11/functional-programmers-unite-lambdajam-down-under</id>
    <content type="html"><![CDATA[<p>I hinted at <a href="http://www.yowconference.com.au/lambdajam/">LambdaJam Australia</a> back in my <a href="http://www.leonardoborges.com/writings/2013/01/02/so-long-2012-year-highlights/">2012 Highlights post</a> and the dates are fast approaching so I thought appropriate to blog about it once more.</p>

<p><a href="http://www.yowconference.com.au/lambdajam/">YOW! LambdaJam</a> is a conference targeted at intermediate and advanced functional programmers and is organised in talks, jams and workshops.</p>

<ul>
<li><strong>Talks</strong> are the traditional format and are 30 minutes long;</li>
<li><strong>Workshops</strong> aim to introduce a specific subjects to attendees in great detail and are up to two hours long;</li>
<li><strong>Jams</strong> are hands-on sessions. Participants will be guided through pre-defined problems around a given subject/technology and encouraged to work through the solutions either by themselves or ideally as small groups. Jams are also 2 hours long;</li>
</ul>


<p>Sounds pretty amazing, doesn&#8217;t it?</p>

<p>If you&#8217;re still not convinced, check out the <a href="http://www.yowconference.com.au/lambdajam/Program.html">program</a>.</p>

<p>The conference will run for 2 days, May 16-17, in Brisbane. <a href="http://yowlambdajam2013.eventbrite.com.au/">Tickets are on sale</a>.</p>

<h3>Clojure</h3>

<p>Besides the conference itself, <a href="http://clojure.com/">Clojure/core</a> will be giving an Intro to Clojure workshop in Sydney, Melbourne and Brisbane. It&#8217;s a great opportunity to learn from the language maintainers.</p>

<p>If you&#8217;re attending the conference already, you&#8217;re in luck because there is a 20% off discount <a href="http://yowlambdajam2013.eventbrite.com.au/">on the link above</a> if you attend both the conference and the workshop.</p>

<p>In case you&#8217;d like to attend the workshops only, you can buy individual tickets for <a href="http://clojurecore-sydney.eventbrite.com.au/">Sydney</a>, <a href="http://clojurecore-melbourne.eventbrite.com.au/">Melbourne</a> and <a href="http://clojurecore-brisbane-eorg.eventbrite.com.au/">Brisbane</a>.</p>

<h3>Scala</h3>

<p><a href="http://tmorris.net/">Tony Morris</a> will also be delivering a Functional Programming in Scala workshop in Brisbane and 20% off combo tickets can be bought from the <a href="http://yowlambdajam2013.eventbrite.com.au/">EventBrite page for LambdaJam</a>.</p>

<h3>See you there</h3>

<p>Got tickets yet? No? What are you waiting for?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure and 'Why calculating is better than scheming']]></title>
    <link href="http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/"/>
    <updated>2013-03-25T11:00:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming</id>
    <content type="html"><![CDATA[<p>Last week while attending <a href="http://clojurewest.org">Clojure/West</a> in Portland I came across a paper called <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf">Why calculating is better than scheming</a>. In a nutshell, this paper is a critique to <a href="http://en.wikipedia.org/wiki/Hal_Abelson">Abelson</a> and <a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">Sussman</a>&#8217;s classic textbook <a href="http://mitpress.mit.edu/sicp/">SICP - Structure and Interpretation of Computer Programs</a>,
used by MIT for many years to teach their introductory programming course.</p>

<p>If you haven&#8217;t read <a href="http://mitpress.mit.edu/sicp/">SICP</a>, you should. It&#8217;s an amazing book. It uses <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, a dialect of Lisp, as the vehicle to present fundamental programming concepts.</p>

<p><a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> - the author of this particular paper - contrasts teaching in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> to teaching using <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> and <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a>, pointing out
four major features he considers important and lacking in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>. They are:</p>

<ul>
<li>Pattern matching</li>
<li>A syntax close to traditional mathematical notation</li>
<li>A static type discipline and user-defined types</li>
<li>Lazy Evaluation</li>
</ul>


<blockquote><p>Note:  <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> influenced <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a> which in turn influenced <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>.  Their syntax is similiar, so where Wadler used Miranda code snippets in the paper, I&#8217;ll be using Haskell in this post.</p></blockquote>

<p>As an aside, although the paper talks specifically of <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, the term Lisp is used quite loosely and could lead the not-so-careful reader to be misled regarding a whole family of languages. Lisps have come a long way and modern dialects - of which I&#8217;ll be focusing on <a href="http://clojure.org/">Clojure</a> - address many of the concerns raised by <a href="http://homepages.inf.ed.ac.uk/wadler/">Wadler</a>.</p>

<p>Let us begin.</p>

<h3>Pattern Matching</h3>

<p>Here Clojure, and most - all? - Lisps, are out of luck.</p>

<p>The example used in the paper is that of summing all integers in a list. First in Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">sum</span> <span class="kt">[]</span>   <span class="ow">=</span> <span class="mi">0</span>
</span><span class='line'><span class="nf">sum</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">sum</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
</span><span class='line'>      <span class="mi">0</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">first </span><span class="nv">coll</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The question here is this: Which snippet is easier to read/reason about? the Haskell code!</p>

<p>I must confess that I, too, miss pattern matching sometimes. However we can still improve our Clojure version to read nicer on the eyes by using <a href="http://www.haskell.org/haskellwiki/Haskell">destructuring</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">sum</span> <span class="p">[[</span><span class="nv">first</span> <span class="nv">&amp;</span> <span class="nv">rest</span> <span class="nv">:as</span> <span class="nv">coll</span><span class="p">]]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
</span><span class='line'>      <span class="mi">0</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="nv">first</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">rest</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And that&#8217;s pretty much it. Without proper pattern matching, we can&#8217;t get much better than that.</p>

<p>In addition to the Haskell snippet being easier to read, it&#8217;s also easier to prove correct by structural induction, as demonstrated in Wadler&#8217;s paper.</p>

<blockquote><p>Note: <a href="https://github.com/clojure/core.match">core.match</a> adds support to pattern matching in Clojure. At the time of this writing, it&#8217;s considered &#8220;alpha quality&#8221;</p></blockquote>

<h3>Data structures</h3>

<p>The paper continues to discuss exercise 2-27 from the <a href="http://mitpress.mit.edu/sicp/">SICP</a>, where the reader has to write code to represent a binary mobile, which consists of a left and right branch with each branch being a rod of certain length, from which hangs either a weight or another binary mobile.</p>

<p>Translating the Scheme example to Clojure, such a structure is represented using lists, like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-mobile</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">list </span><span class="nv">left</span> <span class="nv">right</span><span class="p">))</span>
</span><span class='line'>  
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-branch</span> <span class="p">[</span><span class="nv">length</span> <span class="nv">structure</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">list </span><span class="nv">length</span> <span class="nv">structure</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Wadler then contrasts this with the equivalent Miranda code, translated below to Haskell, taking advantage of <a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">algebraic data types</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Structure</span> <span class="ow">=</span> <span class="kt">Weight</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">Mobile</span> <span class="kt">Branch</span> <span class="kt">Branch</span>
</span><span class='line'><span class="kr">data</span> <span class="kt">Branch</span> <span class="ow">=</span> <span class="kt">Branch</span> <span class="kt">Int</span> <span class="kt">Structure</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first claim is that the Haskell/Miranda data type declaration makes it clearer what the data structure looks like, which is fair.</p>

<p>Also, the compiler can catch errors early on.</p>

<p>However, when writing idiomatic Clojure code, here&#8217;s how I&#8217;d actually create this structure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-mobile</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:left</span> <span class="nv">left</span> <span class="nv">:right</span> <span class="nv">right</span><span class="p">})</span>
</span><span class='line'>  
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">make-branch</span> <span class="p">[</span><span class="nv">length</span> <span class="nv">structure</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:length</span> <span class="nv">length</span> <span class="nv">:structure</span> <span class="nv">structure</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Granted, it&#8217;s still not as clear and the compiler can&#8217;t validate the shape of our data structure.</p>

<p>This is however cleaner than the previous version and drives home the point that Clojure isn&#8217;t limited to lists, having literals for other data types such as the hash maps used in this example.</p>

<p>The second part of this claim is that through custom data types and pattern mathing, extracting values from those structures becomes simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">totalWeight</span> <span class="p">(</span><span class="kt">Weight</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="n">w</span>
</span><span class='line'><span class="nf">totalWeight</span> <span class="p">(</span><span class="kt">Mobile</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">totalWeightBranch</span> <span class="n">l</span> <span class="o">+</span> <span class="n">totalWeightBranch</span> <span class="n">r</span>
</span><span class='line'>
</span><span class='line'><span class="nf">totalWeightBranch</span><span class="p">(</span><span class="kt">Branch</span> <span class="n">d</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">totalWeight</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure>


<p>Once again Clojure can improve things by taking advantage of its builtin data structures and destructuring:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">total-weight</span> <span class="p">[{</span><span class="nv">:keys</span> <span class="p">[</span><span class="nv">left</span> <span class="nv">right</span><span class="p">]</span> <span class="nv">:as</span> <span class="nv">structure</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">number?</span> <span class="nv">structure</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">structure</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">total-weight-branch</span> <span class="nv">left</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">total-weight-branch</span> <span class="nv">right</span><span class="p">))))</span>
</span><span class='line'>      
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">total-weight-branch</span> <span class="p">[{</span><span class="nv">structure</span> <span class="nv">:structure</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">total-weight</span> <span class="nv">structure</span><span class="p">))</span>     
</span></code></pre></td></tr></table></div></figure>


<p>For a language with no pattern matching nor algebraic data types, this snippet is clear, concise and elegant - and a real improvement
over the Scheme version discussed in the paper - which was essentially handicapped by the use of lists to simulate &#8216;structs&#8217;.</p>

<p>As far as Clojure goes, this claim ends here: the next point in the paper, about changing from using <code>list</code> to using <code>cons</code>, is rendered moot since
we&#8217;re using hash maps to represent our mobiles.</p>

<h3>Lisp lists are not self-escaping</h3>

<p>Creating lists in Clojure goes like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span> <span class="c1">;; ((1 2) nil)</span>
</span><span class='line'>
</span><span class='line'><span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span> <span class="c1">;; ((1 2) nil)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Both statements above are equivalent, with the second one being clearly more concise.</p>

<p>The claim here is that the fact that you need to either use the <code>list</code> function or quote the form is cumbersome and can be confusing to beginners.</p>

<p>Clojure solves this by providing literals to another data structure - vectors:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="nv">nil</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Simple and concise - in fact, in idiomatic Clojure code, you&#8217;ll rarely see quoted lists where a vector will do.</p>

<p>This is possible because both lists and vectors conform to a higher level abstraction called a <a href="http://clojure.org/sequences#Sequences-The%20Seq%20library-Seq%20in,%20Seq%20out">Seq</a>, in terms of which most list
operations are defined.</p>

<p>This eliminates the two following points mentioned in the paper as it allows a beginner to defer his/her understanding of quoted forms
to more advanced lessons/usages.</p>

<h3>Programs that Manipulate Programs - the interpreter example</h3>

<p>Here Wadler shows a simple grammar for an interpreter in both Miranda and Scheme.</p>

<p>He claims that since Haskell/Miranda have free data types, representing such grammar becomes simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Lambda</span> <span class="kt">Var</span> <span class="kt">Term</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Apply</span> <span class="kt">Term</span> <span class="kt">Term</span>
</span><span class='line'>          <span class="o">|</span> <span class="kt">Closure</span> <span class="kt">Env</span> <span class="kt">Var</span> <span class="kt">Term</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Env</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Var</span><span class="p">,</span> <span class="kt">Term</span><span class="p">)]</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Var</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is true in that one can easily scan the snippet above and deduce quickly what <code>Term</code> looks like.</p>

<p>Then, by using pattern matching, <code>eval</code> could be implemented like so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">e</span> <span class="n">v</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">v</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Closure</span> <span class="n">e</span> <span class="n">v</span> <span class="n">t</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">e</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t0</span> <span class="n">t1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">apply</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span> <span class="n">t0</span><span class="p">)</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span> <span class="n">t1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>I do believe this makes Haskell an excellent choice for writing interpreters and compilers.</p>

<p>However, the flip side is that entering such terms in Haskell is cumbersome. Consider the term below:</p>

<blockquote><p>(λx.(x x)) (λx.(x x))</p></blockquote>

<p>This is how to represent this term using the grammar defined above:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="s">&quot;x&quot;</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)))</span>
</span><span class='line'>       <span class="p">(</span><span class="kt">Lambda</span> <span class="s">&quot;x&quot;</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">&quot;x&quot;</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The strength in Lisp lies elsewhere. Since we have quoted forms, entering a similar term is a lot less verbose and closer to its intended representation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="o">&#39;</span><span class="p">((</span><span class="nf">lambda</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">lambda</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is, of course, at the expense of making <code>eval</code> a more complicated function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">eval</span> <span class="p">[</span><span class="nv">e</span> <span class="nv">t</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">lookup</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">variable-name</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">lambda?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">make-closure</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">lambda-var</span> <span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">lambda-body</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply?</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nb">eval </span><span class="nv">e</span> <span class="p">(</span><span class="nf">apply-operator</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">eval </span><span class="nv">e</span> <span class="p">(</span><span class="nf">apply-operand</span> <span class="nv">t</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>The paper leaves out an important advantage of Lisps though:</p>

<p>Because we can write code for our made up language directly in its (almost)abstract syntax tree form, Lisps are the ideal choice when writing <a href="http://martinfowler.com/bliki/InternalDslStyle.html">Internal Domain Specific Languages</a>.</p>

<h3>Lazy Evaluation</h3>

<h4>Lists</h4>

<p>Haskell and Miranda are lazy languages and that yields a lot of power. This claim is more specific to the use of lazy lists - or sequences, streams - and starts off with a snippet that calculates the sum of squares of all odd numbers from 1 up to 100:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">sum</span> <span class="p">[</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">odd</span> <span class="n">i</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>What follows in the paper is a not-so-clear snippet of equivalent functionality using Scheme streams.</p>

<p>Clojure features lazy sequences and list comprehensions, making the above Haskell example trivial to write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="k">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)</span> <span class="nv">:when</span> <span class="p">(</span><span class="nf">odd?</span> <span class="nv">i</span><span class="p">)]</span> <span class="p">(</span><span class="nb">* </span><span class="nv">i</span> <span class="nv">i</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you&#8217;re following at home with the original paper you&#8217;ll see this is more readable and elegant than the equivalent Scheme example.</p>

<p>Another - also idiomatic - way to write the same expression is by using a combination of map/filter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="nv">%</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Deciding which one is clearer is left as an exercise to the reader.</p>

<h4>Special forms and lazy evaluation</h4>

<p>In this section, Wadler brings another example from SICP where the reader wishes to implement his/her own <code>if</code> form.</p>

<p>As we know, in order to implement our own version of <code>if</code>, we need to use macros. That is because in Lisps arguments to functions are eagerly evaluated.</p>

<p>One might implement it like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defmacro </span><span class="nv">my-if</span> <span class="p">[</span><span class="nv">pred</span> <span class="nv">then</span> <span class="nv">else</span><span class="p">]</span>
</span><span class='line'>  <span class="o">`</span><span class="p">(</span><span class="k">cond </span><span class="nv">~pred</span> <span class="nv">~then</span>
</span><span class='line'>          <span class="nv">:else</span> <span class="nv">~else</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In Lazy languages, such as Haskell and Miranda, this problem doesn&#8217;t occur allowing such functions to be defined without the need for special and/or quoted forms:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">myIf</span> <span class="kt">True</span>  <span class="n">t</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">t</span>
</span><span class='line'><span class="nf">myIf</span> <span class="kt">False</span> <span class="n">t</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">e</span>
</span></code></pre></td></tr></table></div></figure>


<p>However this completely dismisses the power of macros which allow you to extend the language in ways no other language allows - as is extensively demonstrated in books such as <a href="http://amzn.to/14mrrbk">On Lisp</a> and <a href="http://amzn.to/WKpMZA">Let Over Lambda</a>.</p>

<p>As <a href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Guy Steele</a> once put it:  <em>&#8221;[…] If you give someone Lisp, he has any language he pleases&#8221;</em></p>

<h3>Conclusion</h3>

<p>Hopefully this post doesn&#8217;t come off as trying to invalidate Wadler&#8217;s paper - that is not my intention.</p>

<p>While I do think a few of the points discussed are only applicable to the domain in which his paper was written - teaching - they are still valid and worth understanding.</p>

<p>I do however expect to have given you a different perspective on it, showing the strengths of modern Lisps such as Clojure and how it approaches these issues - such as by using its rich set of data structures, literals and techniques such as destructuring.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Purely functional data structures in Clojure: Leftist Heaps]]></title>
    <link href="http://www.leonardoborges.com/writings/2013/02/03/purely-functional-data-structures-in-clojure-leftist-heaps/"/>
    <updated>2013-02-03T12:41:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2013/02/03/purely-functional-data-structures-in-clojure-leftist-heaps</id>
    <content type="html"><![CDATA[<blockquote><p>This post is part of a series about Chris Okasaki&#8217;s <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a>. You can see all posts in the series by visiting the <a href="http://www.leonardoborges.com/writings/tags/functional-data-structures/">functional-data-structures</a> category in this blog.</p></blockquote>

<hr />

<p>Last year I started reading a book called <a href="http://amzn.to/UcIidh">Purely Functional Data Structures</a>. It&#8217;s a fascinating book and if you&#8217;ve ever wondered how Clojure&#8217;s persistent data structures work, it&#8217;s mandatory reading.</p>

<p>However, all code samples in the book are written in <a href="http://bit.ly/YqYjtt">ML</a> - with <a href="http://bit.ly/YqYmp6">Haskell</a> versions in the end of the book. This means I got stuck in Chapter 3, where the ML snippets start.</p>

<p>I had no clue about Haskell&#8217;s - much less ML&#8217;s! - syntax and I was finding it very difficult to follow along. What I did notice is that their syntaxes are not so different from each other.</p>

<p>So I put the book down and read <a href="http://amzn.to/VuD3jT">Learn You a Haskell For Great Good!</a> with the hopes that learning more about haskell&#8217;s syntax - in particular, learning how to read its type signatures - would help me get going with <em>Puretly Functional Data Structures</em>.</p>

<p>Luckily, I was right - and I recommend you do the same if you&#8217;re not familiar with either of those languages. <a href="http://amzn.to/VuD3jT">Learn You a Haskell For Great Good!</a> is a great book and I got a lot out of it. <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">My series on Monads</a> is a product of reading it.</p>

<p>Enough background though.</p>

<p>The purpose of this post is two-fold: One is to share the <a href="https://github.com/leonardoborges/purely-functional-data-structures">github repository</a> I created and that will contain the Clojure versions of the data structures in the book as well as most solutions to the exercises - or at least as many as my time-poor life allows me to implement.</p>

<p>The other is to walk you through some of the code and get a discussion going. Hopefully we will all learn something - as I certainly have when implementing these. Today, we&#8217;ll start with Leftist Heaps.</p>

<h3>Leftist Heaps</h3>

<p><a href="http://en.wikipedia.org/wiki/Leftist_tree">Leftist Heaps</a> - or trees - are a variant of <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heaps</a> that can be used as priority queues. On top of the standard invariants of binary heaps, it obeys the leftist property:</p>

<ul>
<li>Every node has a <em>rank</em>, which is the distance from its right spine to the nearest leaf</li>
<li>A node&#8217;s left child has a rank at least as large as its right child</li>
</ul>


<p>In a nutshell, these are the operations we need to be able to perform on a leftist heap:</p>

<ul>
<li>insert a value into an existing heap</li>
<li>merge two heaps</li>
<li>find the minimum value in a heap</li>
<li>delete the minimum value, returning a new heap</li>
</ul>


<p>Since the book uses ML/Haskell, it starts with a data type definition for Heaps that exposes these and a couple of other auxiliary functions. I decided to take a stab at writing the solution using Clojure&#8217;s protocols and records:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defprotocol</span> <span class="nv">Heap</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is-empty?</span>   <span class="p">[</span><span class="nv">this</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">insert</span>      <span class="p">[</span><span class="nv">this</span> <span class="nv">v</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">merge </span>      <span class="p">[</span><span class="nv">this</span> <span class="nv">other</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">rank</span>        <span class="p">[</span><span class="nv">this</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">find-min</span>    <span class="p">[</span><span class="nv">this</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">delete-min</span>  <span class="p">[</span><span class="nv">this</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">defrecord</span> <span class="nv">LeftistHeap</span> <span class="p">[</span><span class="nv">rank</span> <span class="nv">value</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>When implementing the algorithms the base case for the recursive solutions will involve dealing with <em>nil</em> values which at first seems like it wouldn&#8217;t be a problem. However, protocol functions dispatch on the type of its first argument so what happens if I call the function <em>is-empty?</em> on <em>nil</em>?</p>

<p>Luckily, Clojure allows us to extend a protocol to core types:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">extend-protocol</span> <span class="nv">Heap</span>
</span><span class='line'>  <span class="nv">nil</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">rank</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">merge </span><span class="p">[</span><span class="nv">_</span> <span class="nv">other</span><span class="p">]</span> <span class="nv">other</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is-empty?</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">true</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">LeftistHeap</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is-empty?</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">nil? </span><span class="nv">this</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">rank</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">:rank</span> <span class="nv">this</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nb">merge </span><span class="p">[{</span><span class="nv">val-this</span> <span class="nv">:value</span> <span class="nv">left-this</span> <span class="nv">:left</span> <span class="nv">right-this</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">this</span><span class="p">}</span>
</span><span class='line'>          <span class="p">{</span><span class="nv">val-other</span> <span class="nv">:value</span> <span class="nv">left-other</span> <span class="nv">:left</span> <span class="nv">right-other</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">other</span><span class="p">}]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">cond</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">is-empty?</span> <span class="nv">other</span><span class="p">)</span> <span class="nv">this</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">val-this</span> <span class="nv">val-other</span><span class="p">)</span> <span class="p">(</span><span class="nf">ensure-leftist</span> <span class="nv">left-this</span>
</span><span class='line'>                                             <span class="p">(</span><span class="nb">merge </span><span class="nv">right-this</span> <span class="nv">other</span><span class="p">)</span>
</span><span class='line'>                                             <span class="nv">val-this</span><span class="p">)</span>
</span><span class='line'>     <span class="nv">:else</span> <span class="p">(</span><span class="nf">ensure-leftist</span> <span class="nv">left-other</span>
</span><span class='line'>                           <span class="p">(</span><span class="nb">merge </span><span class="nv">this</span> <span class="nv">right-other</span><span class="p">)</span>
</span><span class='line'>                           <span class="nv">val-other</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">insert</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">v</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">merge </span><span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="mi">1</span> <span class="nv">v</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>           <span class="nv">this</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">find-min</span> <span class="p">[{</span><span class="nv">v</span> <span class="nv">:value</span><span class="p">}]</span> <span class="nv">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">(</span><span class="nf">delete-min</span> <span class="p">[{</span><span class="nv">left</span> <span class="nv">:left</span> <span class="nv">right</span> <span class="nv">:right</span><span class="p">}]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">merge </span><span class="nv">right</span> <span class="nv">left</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note how I extended a few of the protocol functions to the nil data type, allowing me to continue with this implementation with no nasty hacks.</p>

<p>There&#8217;s one last bit missing: a function that will ensure each heap retains the leftist property:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">ensure-leftist</span>
</span><span class='line'> <span class="p">[</span><span class="nv">this</span> <span class="nv">other</span> <span class="nv">v</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">rank-this</span> <span class="p">(</span><span class="nf">rank</span> <span class="nv">this</span><span class="p">)</span>
</span><span class='line'>       <span class="nv">rank-other</span> <span class="p">(</span><span class="nf">rank</span> <span class="nv">other</span><span class="p">)]</span>
</span><span class='line'>   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">rank-this</span> <span class="nv">rank-other</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-other</span><span class="p">)</span> <span class="nv">v</span> <span class="nv">this</span> <span class="nv">other</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-this</span><span class="p">)</span> <span class="nv">v</span> <span class="nv">other</span> <span class="nv">this</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The reason this function is isolated is that the Heap protocol defined above is fairly generic and could be used for defining other types of heaps - and I didn&#8217;t feel it warranted its own interface.</p>

<p>We can now play with it and create a new leftist heap:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">-&gt;LeftistHeap</span> <span class="mi">1</span> <span class="mi">3</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">7</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">insert</span> <span class="mi">20</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>While I quite like this approach, I thought I&#8217;d also implement this solution using Clojure&#8217;s core data types - maps in this case - and no protocols. The code is shown below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">mk-heap</span> <span class="p">[</span><span class="nv">rank</span> <span class="nv">value</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:rank</span> <span class="nv">rank</span> <span class="nv">:value</span> <span class="nv">value</span> <span class="nv">:left</span> <span class="nv">left</span> <span class="nv">:right</span> <span class="nv">right</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-rank</span> <span class="p">[</span><span class="nv">heap</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">heap</span><span class="p">)</span>
</span><span class='line'>    <span class="mi">0</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">:rank</span> <span class="nv">heap</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">ensure-leftist-heap</span> <span class="p">[</span><span class="nv">value</span> <span class="nv">heap-a</span> <span class="nv">heap-b</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">rank-a</span> <span class="p">(</span><span class="nf">heap-rank</span> <span class="nv">heap-a</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">rank-b</span> <span class="p">(</span><span class="nf">heap-rank</span> <span class="nv">heap-b</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">rank-a</span> <span class="nv">rank-b</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">mk-heap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-b</span><span class="p">)</span> <span class="nv">value</span> <span class="nv">heap-a</span> <span class="nv">heap-b</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">mk-heap</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">rank-a</span><span class="p">)</span> <span class="nv">value</span> <span class="nv">heap-b</span> <span class="nv">heap-a</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">merge-heaps</span> <span class="p">[{</span><span class="nv">val-a</span> <span class="nv">:value</span> <span class="nv">left-a</span> <span class="nv">:left</span> <span class="nv">right-a</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">heap-a</span><span class="p">}</span>
</span><span class='line'>                   <span class="p">{</span><span class="nv">val-b</span> <span class="nv">:value</span> <span class="nv">left-b</span> <span class="nv">:left</span> <span class="nv">right-b</span> <span class="nv">:right</span> <span class="nv">:as</span> <span class="nv">heap-b</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">cond</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">nil? </span><span class="nv">heap-a</span><span class="p">)</span> <span class="nv">heap-b</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">nil? </span><span class="nv">heap-b</span><span class="p">)</span> <span class="nv">heap-a</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">val-a</span> <span class="nv">val-b</span><span class="p">)</span> <span class="p">(</span><span class="nf">ensure-leftist-heap</span> <span class="nv">val-a</span>
</span><span class='line'>                                         <span class="nv">left-a</span>
</span><span class='line'>                                         <span class="p">(</span><span class="nf">merge-heaps</span> <span class="nv">right-a</span> <span class="nv">heap-b</span><span class="p">))</span>
</span><span class='line'>   <span class="nv">:else</span> <span class="p">(</span><span class="nf">ensure-leftist-heap</span> <span class="nv">val-b</span>
</span><span class='line'>                              <span class="nv">left-b</span>
</span><span class='line'>                              <span class="p">(</span><span class="nf">merge-heaps</span> <span class="nv">heap-a</span> <span class="nv">right-b</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-insert</span> <span class="p">[</span><span class="nv">value</span> <span class="nv">heap</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">merge-heaps</span> <span class="p">(</span><span class="nf">mk-heap</span> <span class="mi">1</span> <span class="nv">value</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>               <span class="nv">heap</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-find-min</span> <span class="p">[{</span><span class="nv">v</span> <span class="nv">:value</span><span class="p">}]</span> <span class="nv">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">heap-delete-min</span> <span class="p">[{</span><span class="nv">left</span> <span class="nv">:left</span> <span class="nv">right</span> <span class="nv">:right</span><span class="p">}]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">merge-heaps</span> <span class="nv">right</span> <span class="nv">left</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using it is equally simple:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">mk-heap</span> <span class="mi">1</span> <span class="mi">3</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">7</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">heap-insert</span> <span class="mi">20</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&#8217;s it for now.</p>

<p>As I implement more of the book&#8217;s code and exercises I&#8217;ll add them to the <a href="https://github.com/leonardoborges/purely-functional-data-structures">github repo</a> - it also includes tests for all implementations.</p>

<p>Enjoy :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Announcing bouncer, a validation library for Clojure Apps]]></title>
    <link href="http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure/"/>
    <updated>2013-01-04T17:39:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure</id>
    <content type="html"><![CDATA[<p>Today I&#8217;m releasing bouncer, which was extracted from a project I&#8217;ve been working on.</p>

<p>It&#8217;s a validation library for Clojure apps and it lets you write code like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">person</span> <span class="p">{</span><span class="nv">:name</span> <span class="s">&quot;Leo&quot;</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">validate</span> <span class="nv">person</span>
</span><span class='line'>    <span class="nv">:name</span> <span class="nv">required</span>
</span><span class='line'>    <span class="nv">:age</span>  <span class="p">[</span><span class="nv">required</span> <span class="nv">number</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you&#8217;d like to see more examples and a detailed guide check out the <a href="http://github.com/leonardoborges/bouncer">github repository</a>. The README should get you started.</p>

<p>This post however isn&#8217;t only about announcing bouncer. It&#8217;s also about the motivation and implementation details behind it.</p>

<p>There are a couple of Clojure validation libraries already out there so why would I write a new one?
Well&#8230;</p>

<ul>
<li><p>Writing Clojure is fun! (who knew? :P)</p></li>
<li><p>Because I believe this problem can be solved more elegantly with the use of Monads</p></li>
</ul>


<p>If you&#8217;ve been following me for a while, you&#8217;ll know that I spent most of 2012 deepening my knowledge about functional programming.</p>

<p>In that journey, the unavoidable subject of monads came about - and it was both interesting and enlightening enough that made me <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">write a whole series of posts about it</a>.</p>

<p>After learning what they are and then thinking about the validation problem for a while, I couldn&#8217;t help but notice that the problem had a lot in common with the <a href="http://www.haskell.org/haskellwiki/State_Monad">State Monad</a>.</p>

<p>In order to explain how the two relate, I&#8217;ll have to digress for a moment. It&#8217;ll all make sense in the end - or so I hope</p>

<h2>Purity</h2>

<p>In pure functional languages, such as Haskell, functions can&#8217;t have side effects. These include performing IO, changing global variables or launching missiles.</p>

<p>Because of that, functions in Haskell are pure: if you repeatedly call a function <em>f</em> with the same argument <code>x</code> over time you will <em>always</em> get the same result back.</p>

<p>Pure functions are not a feature of Haskell though. We, too, can write pure functions if we wish:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">double</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The function <code>double</code> above is pure. If we call it with 10, we can be sure the result will always be 20.</p>

<p>This leaves us with a question though: If we were to write our programs with pure functions only, how would we perform computations that need to carry state - state that needs to change over time - around?</p>

<p>A good example of such computation is generating random numbers.</p>

<p>Most programming languages provide generators capable of creating random numbers on demand. Using them is usually trivial. Here&#8217;s an example in Java:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Random</span> <span class="n">gen</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">gen</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span> <span class="c1">// 0.0037635726242281065</span>
</span><span class='line'><span class="n">gen</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span> <span class="c1">// 0.15821091918430885</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Impurity alert!</strong></p>

<p>The function <code>nextDouble</code> above is obviously <em>not</em> pure. Multiple invocations of it with the same argument - in this case, none - returns different results.</p>

<p><code>nextDouble</code>  is keeping some sort of global state between function calls.</p>

<p>This is where the State Monad comes in. It allows such functions to remain pure.</p>

<h2>The State Monad</h2>

<p>The State Monad provides a way to abstract <em>state</em> from the function that needs to operate on it.</p>

<p>Sounds confusing? Hopefully an example will clear things up.</p>

<p>Let&#8217;s have a look at the clojure function <code>rand</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">rand</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; 0.04388682005715605</span>
</span><span class='line'><span class="p">(</span><span class="nf">rand</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; 0.43057496371080517</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>rand</code> suffers from the same problem as <code>nextDouble</code> we saw above. It keeps it&#8217;s own state that is shared across calls, therefore being an impure function.</p>

<p>Now let&#8217;s write a pure version of <code>rand</code>. We&#8217;ll call it <code>pure-rand</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">gen</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">pure-rand</span> <span class="p">[</span><span class="nv">g</span><span class="p">]</span>
</span><span class='line'>    <span class="p">[(</span><span class="o">.</span><span class="nv">nextDouble</span> <span class="nv">g</span><span class="p">)</span> <span class="nv">g</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="nv">gen</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; [0.5783608063218478 #&lt;Random java.util.Random@7f30ab6&gt;]</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="nv">gen</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; [0.9251968987499839 #&lt;Random java.util.Random@7f30ab6&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is interesting. <code>pure-rand</code> now takes a generator as an argument and returns a two-element vector containing the random number itself - the result we&#8217;re actually interested in - and the generator that was passed in.</p>

<p>Recall however that the generator returned, albeit the same object, is in a new sate.</p>

<p>By re-writing the function like this, we&#8217;ve regained purity, as demonstrated below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span> <span class="mi">100</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; [0.7220096548596434 #&lt;Random java.util.Random@bb14fe1&gt;]</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">pure-rand</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span> <span class="mi">100</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; [0.7220096548596434 #&lt;Random java.util.Random@bb14fe1&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, as long as we provide the same generator - the same argument - we get the same result back.</p>

<p>If you&#8217;re wondering why I&#8217;m returning a two element vector from our little function, the answer lies in the State Monad implementation as found in the <a href="https://github.com/clojure/algo.monads/">algo.monads</a> library.</p>

<p>From its docstring:</p>

<blockquote><p><strong>State Monad</strong>: Monad describing stateful computations. The monadic values have the structure:</p>

<pre><code>(fn [old-state] [result new-state]).
</code></pre></blockquote>

<p>It expects a function that receives its old state and returns the result and the new state - these are called monadic values.</p>

<p>By designing the function to follow this contract, we can leverage the <code>domonad</code> macro - think of it as syntactic sugar for working with monads:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure</span><span class="o">.</span><span class="nv">algo</span><span class="o">.</span><span class="nv">monads</span> <span class="nv">:as</span> <span class="nv">m</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="p">((</span><span class="nf">m/domonad</span> <span class="nv">m/state-m</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">a</span> <span class="nv">pure-rand</span>
</span><span class='line'>     <span class="nv">b</span> <span class="nv">pure-rand</span>
</span><span class='line'>     <span class="nv">c</span> <span class="nv">pure-rand</span><span class="p">]</span>
</span><span class='line'>     <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">])</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Random</span><span class="o">.</span> <span class="mi">100</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; [[0.7220096548596434 0.19497605734770518 0.6671595726539502] </span>
</span><span class='line'><span class="c1">;; #&lt;Random java.util.Random@358ddfd6&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the example above, we&#8217;re using our <code>pure-rand</code> function in the context of the State Monad to generate 3 random numbers - based on some initial state - and returning them as a vector.</p>

<p>As we&#8217;ve seen before the result is itself in a vector alongside the new state.</p>

<p>This is where the State Monad and the validation problem meet:</p>

<p>In <a href="http://github.com/leonardoborges/bouncer">bouncer</a>, each validation function is designed to be compatible with the State Monad, just like <code>pure-rand</code> above:</p>

<p>It receives an initial state - at first, the map to be validated - and returns a vector with the map of errors and the new state: the original map augmented with any errors from previous validators.</p>

<p>The end result, should one or more validations fail, is a map with all errors that might have happened, plus our new state.</p>

<p>Now if you head to the <a href="http://github.com/leonardoborges/bouncer">github repository</a> and read the examples by keeping the State Monad and the above explanation in mind, the similarities should be obvious.</p>

<h2>Wrapping up</h2>

<p>As I mentioned in the beginning of the article, there are <a href="https://github.com/r0man/validation-clj">other</a> validation <a href="https://github.com/michaelklishin/validateur">libraries</a> for Clojure and at the time of this writing they have more features than <a href="http://github.com/leonardoborges/bouncer">bouncer</a> - by all means have a look at them.</p>

<p>However I will keep maintaining <a href="http://github.com/leonardoborges/bouncer">bouncer</a> for a couple of reasons:</p>

<ul>
<li>That&#8217;s what I&#8217;m using in my current side project</li>
<li>It takes a fundamentally different implementation approach that is in itself worthy of exploration</li>
<li>If nothing else, this is yet another example of where Monads can be useful.</li>
</ul>


<h4>Acknowledgments</h4>

<p>Thanks to <a href="https://twitter.com/stevebuik">Steve</a> and <a href="https://twitter.com/juliansgamble">Julian</a> for reviewing early drafts of this post as well as <a href="https://twitter.com/nick_s_drew">Nick</a> for being such a PITA :) - our discussions led to a considerably nicer design.</p>

<p>As usual, let me know your thoughts.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monads in small bites - Part IV - Monads]]></title>
    <link href="http://www.leonardoborges.com/writings/2012/12/08/monads-in-small-bites-part-iv-monads/"/>
    <updated>2012-12-08T17:36:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2012/12/08/monads-in-small-bites-part-iv-monads</id>
    <content type="html"><![CDATA[<p>This is Part IV of my Monads tutorial. Make sure you read the previous parts:</p>

<ul>
<li><p><a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Part I   - Functors</a></p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Part II  - Applicative Functors</a></p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/05/monads-in-small-bites-part-iii-monoids/">Part III - Monoids</a></p></li>
<li><p>Part IV  - Monads (this post)</p></li>
</ul>


<h3>A quick recap</h3>

<p>In <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Part I</a> we learned about <em>Functors</em>, which are things that can be mapped over using a normal function - <code>fmap</code> is used for that.</p>

<p><a href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Part II</a> tought us that when our Functors themselves contain functions and we want them applied to the values contained in other Functors, <em>Applicatives</em> come to the rescue - and bring theirs friends <code>pure</code> and <code>&lt;*&gt;</code>.</p>

<p><a href="http://www.leonardoborges.com/writings/2012/12/05/monads-in-small-bites-part-iii-monoids/">Part III</a> introduced Monoids which model a special type of relationship involving binary functions and their identity values.</p>

<p>Now it&#8217;s time for what I hope is the post you have all been waiting for :)</p>

<h3>Monads</h3>

<h4>A word on context</h4>

<p>So far I&#8217;ve said things such as <em>wrapping</em> stuff in Functors, <em>unwrapping</em> functions from Applicatives and putting results into minimal Functors. All this really means is that [Applicative]Functors - and Monads - have associated contexts that model some sort of computation.</p>

<p>For lists, for example, this means they represent computations that can have several results - non-determinism.</p>

<p>These computations can have much greater implications though - they can represent failure (or not!), do IO and even launch nuclear missiles. The point is: when we combine Functors/Applicatives/Monads, we carry their context with us to the end - they are essentially <em>sequenced</em> together.</p>

<p>This will become clearer with an example. For once I won&#8217;t start with lists - w00t! - so get ready for it!</p>

<h3>The Maybe Monad</h3>

<p>The Maybe monad models computations that can fail. Let&#8217;s have a look at an example.</p>

<p>Say you have an e-commerce system. When placing an order, a few things need to get done:</p>

<ul>
<li>gather information about the order;</li>
<li>calculate shipping rates;</li>
<li>apply discount codes, if any, and;</li>
<li>finally place the order.</li>
</ul>


<p>The code below shows the supporting functions that will be orchestrated in order to achieve this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">calculate-shipping-rate</span> <span class="p">[</span><span class="nv">address</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">:country</span> <span class="nv">address</span><span class="p">)</span> <span class="s">&quot;Australia&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="mf">10.0</span>
</span><span class='line'>        <span class="nv">nil</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">apply-shipping-costs</span> <span class="p">[</span><span class="nv">order</span> <span class="nv">shipping-rate</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">assoc </span><span class="nv">order</span> <span class="nv">:total</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">:total</span> <span class="nv">order</span><span class="p">)</span> <span class="nv">shipping-rate</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">lookup-discount-code</span> <span class="p">[</span><span class="nv">code</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">code</span> <span class="s">&quot;XMAS2012&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="mf">5.0</span>
</span><span class='line'>        <span class="nv">nil</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">apply-discount-code</span> <span class="p">[</span><span class="nv">order</span> <span class="nv">discount</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">assoc </span><span class="nv">order</span> <span class="nv">:total</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">:total</span> <span class="nv">order</span><span class="p">)</span> <span class="nv">discount</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">place</span> <span class="p">[</span><span class="nv">order</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Off you go! Order total: $&quot;</span> <span class="p">(</span><span class="nf">:total</span> <span class="nv">order</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that based on the code above, we can <em>only</em> ship to Australia and there is <em>only one</em> active discount code. Keep this in mind - you&#8217;ll see why later on.</p>

<p>Now let&#8217;s place an order for some Jalapeño sauce:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">order</span> <span class="p">{</span>
</span><span class='line'>    <span class="nv">:items</span> <span class="p">[{</span><span class="nv">:name</span> <span class="s">&quot;Jalapeño sauce&quot;</span> <span class="nv">:price</span> <span class="mf">20.0</span><span class="p">}]</span>
</span><span class='line'>    <span class="nv">:address</span> <span class="p">{</span><span class="nv">:country</span> <span class="s">&quot;Australia&quot;</span><span class="p">}</span>
</span><span class='line'>    <span class="nv">:discount-code</span> <span class="s">&quot;XMAS2012&quot;</span>
</span><span class='line'>    <span class="nv">:total</span> <span class="mf">20.0</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">shipping-rate</span> <span class="p">(</span><span class="nf">calculate-shipping-rate</span> <span class="p">(</span><span class="nf">:address</span> <span class="nv">order</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">discount</span> <span class="p">(</span><span class="nf">lookup-discount-code</span> <span class="p">(</span><span class="nf">:discount-code</span> <span class="nv">order</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">order</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">apply-shipping-costs</span> <span class="nv">shipping-rate</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">apply-discount-code</span> <span class="nv">discount</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">place</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; &quot;Off you go! Order total: $25.0&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Great! Soon I&#8217;ll be receiving some hot sauce to go with my burritos!</p>

<p>But wait, what if I had mistakenly set my address to somewhere other than Australia? How would this code behave?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">another-order</span> <span class="p">{</span>
</span><span class='line'>    <span class="nv">:items</span> <span class="p">[{</span><span class="nv">:name</span> <span class="s">&quot;Jalapeño sauce&quot;</span> <span class="nv">:price</span> <span class="mf">20.0</span><span class="p">}]</span>
</span><span class='line'>    <span class="nv">:address</span> <span class="p">{</span><span class="nv">:country</span> <span class="s">&quot;Brazil&quot;</span><span class="p">}</span>
</span><span class='line'>    <span class="nv">:discount-code</span> <span class="s">&quot;HACKERZ&quot;</span>
</span><span class='line'>    <span class="nv">:total</span> <span class="mf">20.0</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">shipping-rate</span> <span class="p">(</span><span class="nf">calculate-shipping-rate</span> <span class="p">(</span><span class="nf">:address</span> <span class="nv">another-order</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">discount</span> <span class="p">(</span><span class="nf">lookup-discount-code</span> <span class="p">(</span><span class="nf">:discount-code</span> <span class="nv">another-order</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">another-order</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">apply-shipping-costs</span> <span class="nv">shipping-rate</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">apply-discount-code</span> <span class="nv">discount</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">place</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; NullPointerException   [trace missing]</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Oops</strong>! Your e-commerce system just crashed! Not cool. But hey, this is easy to fix, right? We could just change our <em>apply-shipping-costs</em> function to something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">apply-shipping-costs</span> <span class="p">[</span><span class="nv">order</span> <span class="nv">shipping-rate</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="nv">shipping-rate</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">assoc </span><span class="nv">order</span> <span class="nv">:total</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">:total</span> <span class="nv">order</span><span class="p">)</span> <span class="nv">shipping-rate</span><span class="p">))</span>
</span><span class='line'>        <span class="nv">order</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">;;Remember we only support one discount code so the same problem could happen again</span>
</span><span class='line'><span class="c1">;;We need to change the apply-discount-code function as well</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">apply-discount-code</span> <span class="p">[</span><span class="nv">order</span> <span class="nv">discount</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="nv">discount</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">assoc </span><span class="nv">order</span> <span class="nv">:total</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">:total</span> <span class="nv">order</span><span class="p">)</span> <span class="nv">discount</span><span class="p">))</span>
</span><span class='line'>        <span class="nv">order</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now let&#8217;s see what happens:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">shipping-rate</span> <span class="p">(</span><span class="nf">calculate-shipping-rate</span> <span class="p">(</span><span class="nf">:address</span> <span class="nv">another-order</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">discount</span> <span class="p">(</span><span class="nf">lookup-discount-code</span> <span class="p">(</span><span class="nf">:discount-code</span> <span class="nv">another-order</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">another-order</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">apply-shipping-costs</span> <span class="nv">shipping-rate</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">apply-discount-code</span> <span class="nv">discount</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">place</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; &quot;Off you go! Order total: $15.0&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Well, it doesn&#8217;t <em>crash</em> but we can&#8217;t ship to Brazil anyway! So the code is <em>still</em> incorrect! What we really want is a way to halt the whole computation - placing an order - if any of those steps fail.</p>

<p>Of course we could fix it with a couple more <em>if</em> forms before trying to call the <em>place</em> function but you see where this is going.</p>

<p>Essentially our nice little functions became burdened with <em>context</em>: each of them is now aware that they can fail and need to cater for it.</p>

<h3>Enter the Monad</h3>

<p>I&#8217;ll jump straight to how the code could look like if we had monads - it won&#8217;t work now because we haven&#8217;t actually implemented the monad yet, but this should whet your appetite.</p>

<p>Also, assume we reversed the changes from before - the functions don&#8217;t have the <em>if</em> forms checking its arguments any longer, just like in the original version. Here&#8217;s the code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">domonad</span> <span class="nv">maybe-monad</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">order</span> <span class="nv">order</span>
</span><span class='line'>     <span class="nv">shipping-rate</span> <span class="p">(</span><span class="nf">calculate-shipping-rate</span> <span class="p">(</span><span class="nf">:address</span> <span class="nv">order</span><span class="p">))</span>
</span><span class='line'>     <span class="nv">discount</span> <span class="p">(</span><span class="nf">lookup-discount-code</span> <span class="p">(</span><span class="nf">:discount-code</span> <span class="nv">order</span><span class="p">))]</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">order</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply-shipping-costs</span> <span class="nv">shipping-rate</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply-discount-code</span> <span class="nv">discount</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">place</span><span class="p">)))</span>
</span><span class='line'><span class="c1">;;&quot;Off you go! Order total: $25.0&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">domonad</span> <span class="nv">maybe-monad</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">order</span> <span class="nv">another-order</span>
</span><span class='line'>     <span class="nv">shipping-rate</span> <span class="p">(</span><span class="nf">calculate-shipping-rate</span> <span class="p">(</span><span class="nf">:address</span> <span class="nv">order</span><span class="p">))</span>
</span><span class='line'>     <span class="nv">discount</span> <span class="p">(</span><span class="nf">lookup-discount-code</span> <span class="p">(</span><span class="nf">:discount-code</span> <span class="nv">order</span><span class="p">))]</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">order</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply-shipping-costs</span> <span class="nv">shipping-rate</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply-discount-code</span> <span class="nv">discount</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">place</span><span class="p">)))</span>
</span><span class='line'><span class="c1">;; nil</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>domonad</code> receives the monad you want to operate on, a vector of bindings and an expression that&#8217;s the final result of the whole thing.</p>

<p>Is your mind blown yet? :) Somehow the whole operation fails and yields <code>nil</code> in the second call to <em>domonad</em> above - without any <em>if</em> forms and without crashing! To see why that is, I&#8217;ll now explain the monad type class from Haskell.</p>

<h3>The Monad Type Class</h3>

<p>Here&#8217;s the Haskell definition of the Monad type class (I left the <code>fail</code> function out so we can focus on the core of it):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">y</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&#8217;s distill those bad ass type signatures:</p>

<blockquote><p><strong>return</strong> - much like <code>pure</code> from <a href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Applicative Functors</a>, <code>return</code> is responsible for wrapping a value of type <code>a</code> into a minimum context Monad that yields a value of type <code>a</code> - referred to as a <em>monadic value</em>.</p>

<p><strong>(>>=)</strong> - often called <code>bind</code> - is a function of two arguments. The first is a <em>monadic value</em> of type <code>a</code> and the second is a function that receives a value of type <code>a</code> and returns a monadic value of type <code>m b</code> which is also the overall result of the function.</p>

<p>In other words: <code>bind</code> <em>runs</em> the monad <code>m a</code>, feeding the yielded <code>a</code> value into the function it received as an argument - any context carried by that monad will be taken into account.</p>

<p><strong>(>>)</strong> - often called <code>then</code> - This function receives two monads, <code>m a</code> and <code>m b</code>, and returns a monad of type <code>m b</code>. It is generally used when you&#8217;re interested in the side effects - the context - carried out by the monad <code>m a</code> but doesn&#8217;t care about the value <code>a</code> it yields.  It&#8217;s rarely implemented in specific monads because the type class provides a default implementation:</p>

<p>It applies <code>bind</code> to the monad <code>x</code> and a function that ignores its argument (<code>\_ -&gt; y</code>) - which by convention is represented by an <em>underscore</em> - and simply yields the monad <code>y</code>: that&#8217;s the final result of the computation.</p></blockquote>

<p>I won&#8217;t be implementing <code>then</code> in Clojure though - I&#8217;ll focus on <code>return</code> and <code>bind</code>, since <code>then</code> is essentially a helper function you could write yourself.</p>

<h4>The Maybe Monad - Clojure edition</h4>

<p>With definitions out of the way, let&#8217;s implement the Clojure version of the Maybe monad.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">maybe-monad</span> <span class="p">{</span>
</span><span class='line'>    <span class="nv">:return</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v</span><span class="p">]</span> <span class="nv">v</span><span class="p">)</span>
</span><span class='line'>    <span class="nv">:bind</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mv</span> <span class="nv">f</span><span class="p">]</span>
</span><span class='line'>            <span class="p">(</span><span class="k">if </span><span class="nv">mv</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">f</span> <span class="nv">mv</span><span class="p">)</span>
</span><span class='line'>                <span class="nv">nil</span><span class="p">))})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yup. That&#8217;s <em>it</em>.</p>

<p>For the maybe monad, all its context needs to represent is a single value or the absence of value. We do this inside <code>bind</code> by checking if the monadic value <code>mv</code> is <code>nil</code>. If it isn&#8217;t, we apply <code>f</code> to it, which will yield another monadic value. If, on the other hand, <code>mv</code> IS <code>nil</code>, we just return <code>nil</code>, bypassing the function application entirely.</p>

<p><code>return</code>, as we saw, wraps a value into a minimal monad. In this case this is the value itself, so we just return it untouched.</p>

<p>This is how one may go about using it:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">another-order</span>
</span><span class='line'>    <span class="p">((</span><span class="nf">:bind</span> <span class="nv">maybe-monad</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">order</span><span class="p">]</span>
</span><span class='line'>       <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">calculate-shipping-rate</span> <span class="p">(</span><span class="nf">:address</span> <span class="nv">order</span><span class="p">))</span>
</span><span class='line'>           <span class="p">((</span><span class="nf">:bind</span> <span class="nv">maybe-monad</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">shipping-rate</span><span class="p">]</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">lookup-discount-code</span> <span class="p">(</span><span class="nf">:discount-code</span> <span class="nv">order</span><span class="p">))</span>
</span><span class='line'>                  <span class="p">((</span><span class="nf">:bind</span> <span class="nv">maybe-monad</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">discount</span><span class="p">]</span>
</span><span class='line'>                     <span class="p">((</span><span class="nf">:return</span> <span class="nv">maybe-monad</span><span class="p">)</span>
</span><span class='line'>                      <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">order</span>
</span><span class='line'>                        <span class="p">(</span><span class="nf">apply-shipping-costs</span> <span class="nv">shipping-rate</span><span class="p">)</span> <span class="p">(</span>
</span><span class='line'>                        <span class="nv">apply-discount-code</span> <span class="nv">discount</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">(</span><span class="nf">place</span><span class="p">))))))))))))</span>
</span><span class='line'><span class="c1">;; nil</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>WOW!</em> That is awful! And I won&#8217;t blame you for not wanting to read through this aberration. But trust me, it does the job.</p>

<p>However, you&#8217;re probably thinking: that looks <em>nothing</em> like the nice little <code>domonad</code> notation we saw earlier!</p>

<p>Well, you&#8217;re right. That&#8217;s because <code>domonad</code> is a <a href="http://clojure.org/macros">macro</a> - it gives us some syntactic sugar that expands into the real code shown above. In order to be able to use the <code>domonad</code> notation, paste the following into your REPL:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">monad-steps</span>
</span><span class='line'>    <span class="p">([</span><span class="nv">monad</span> <span class="nv">steps</span> <span class="nv">expr</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">seq </span><span class="nv">steps</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">fst</span> <span class="p">(</span><span class="nb">first </span><span class="nv">steps</span><span class="p">)</span>
</span><span class='line'>                  <span class="nv">snd</span> <span class="p">(</span><span class="nb">second </span><span class="nv">steps</span><span class="p">)]</span>
</span><span class='line'>                  <span class="o">`</span><span class="p">((</span><span class="nf">:bind</span> <span class="nv">~monad</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">~</span><span class="p">(</span><span class="nb">symbol </span><span class="nv">fst</span><span class="p">)]</span>
</span><span class='line'>                        <span class="p">(</span><span class="nb">-&gt; </span> <span class="nv">~snd</span> <span class="nv">~</span><span class="p">(</span><span class="nf">monad-steps</span> <span class="nv">monad</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">steps</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">expr</span><span class="p">)))))</span>
</span><span class='line'>            <span class="nv">expr</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">defmacro </span><span class="nv">domonad</span> <span class="p">[</span><span class="nv">monad</span> <span class="nv">steps</span> <span class="nv">expr</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">args</span> <span class="p">(</span><span class="nb">map </span><span class="nv">first</span> <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="nv">steps</span><span class="p">))</span>
</span><span class='line'>          <span class="nv">forms</span> <span class="p">(</span><span class="nb">map </span><span class="nv">second</span> <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="nv">steps</span><span class="p">))</span>
</span><span class='line'>          <span class="nv">new-steps</span> <span class="p">(</span><span class="nb">subvec </span><span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">interleave </span><span class="p">(</span><span class="nb">cons </span><span class="nv">nil</span> <span class="nv">args</span><span class="p">)</span> <span class="nv">forms</span><span class="p">))</span> <span class="mi">2</span><span class="p">)]</span>
</span><span class='line'>          <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m</span><span class="o">#</span> <span class="nv">~monad</span><span class="p">]</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">~</span><span class="p">(</span><span class="nb">second </span><span class="nv">steps</span><span class="p">)</span>
</span><span class='line'>                <span class="nv">~</span><span class="p">(</span><span class="nf">monad-steps</span> <span class="nv">monad</span> <span class="nv">new-steps</span>
</span><span class='line'>                    <span class="o">`</span><span class="p">((</span><span class="nf">:bind</span> <span class="nv">~monad</span><span class="p">)</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">~</span><span class="p">(</span><span class="nb">symbol </span><span class="p">(</span><span class="nb">last </span><span class="nv">args</span><span class="p">))]</span> <span class="p">((</span><span class="nf">:return</span> <span class="nv">~monad</span><span class="p">)</span> <span class="nv">~expr</span><span class="p">))))))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>All set! Now you should be able to run the examples that use <code>domonad</code> without any hiccups. Give it a shot:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">domonad</span> <span class="nv">maybe-monad</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">order</span> <span class="nv">another-order</span>
</span><span class='line'>     <span class="nv">shipping-rate</span> <span class="p">(</span><span class="nf">calculate-shipping-rate</span> <span class="p">(</span><span class="nf">:address</span> <span class="nv">order</span><span class="p">))</span>
</span><span class='line'>     <span class="nv">discount</span> <span class="p">(</span><span class="nf">lookup-discount-code</span> <span class="p">(</span><span class="nf">:discount-code</span> <span class="nv">order</span><span class="p">))]</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">order</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply-shipping-costs</span> <span class="nv">shipping-rate</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">apply-discount-code</span> <span class="nv">discount</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">place</span><span class="p">)))</span>
</span><span class='line'><span class="c1">;; nil</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>Note:</strong> macros can be daunting at times so don&#8217;t worry too much about its implementation. It&#8217;s way more important to me that you understand the end result than it is to be able to implement the macro yourself - but by all means dissect this implementation if you feel inclined to do so :)</p></blockquote>

<p>Now that&#8217;s way better. The <em>maybe</em> monad abstracted away the logic behind computations that can fail so you don&#8217;t have to worry about it in your functions  - you can just focus on writing them.</p>

<p>In the end I also believe it aids readability once you get used to it.</p>

<h3>Don&#8217;t break the law</h3>

<p>Monads have laws of their own too! Let&#8217;s have a look at them.</p>

<h4>Right unit</h4>

<blockquote><p>Binding a monadic value <code>m</code> to <code>return</code> should be equal to <code>m</code> itself</p></blockquote>

<p>In Haskell speak:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="ow">=</span>  <span class="n">m</span>
</span></code></pre></td></tr></table></div></figure>


<p>The proof in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">m</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">&gt;&gt;=</span> <span class="p">(</span><span class="nf">:bind</span> <span class="nv">maybe-monad</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">return</span> <span class="p">(</span><span class="nf">:return</span> <span class="nv">maybe-monad</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nf">&gt;&gt;=</span> <span class="nv">m</span> <span class="nv">return</span><span class="p">)</span> <span class="c1">;; 10</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;;is the same as</span>
</span><span class='line'><span class="nv">m</span> <span class="c1">;; 10</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Left unit</h4>

<blockquote><p>Applying <code>return</code> to <code>x</code> and then applying <code>&gt;&gt;=</code> to the resulting value and <code>f</code>should be the same as applying <code>f</code> directly to <code>x</code></p></blockquote>

<p>In Haskell speak:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span>  <span class="n">f</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>The proof in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">&gt;&gt;=</span> <span class="p">(</span><span class="nf">:bind</span> <span class="nv">maybe-monad</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">return</span> <span class="p">(</span><span class="nf">:return</span> <span class="nv">maybe-monad</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="nv">v</span> <span class="mi">2</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">return</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">&gt;&gt;=</span> <span class="nv">f</span><span class="p">))</span> <span class="c1">;; 20</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;;is the same as</span>
</span><span class='line'><span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">;; 20</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Associativity</h4>

<blockquote><p>Binding <code>m</code> to <code>f</code> and then applying <code>&gt;&gt;=</code> to the result and <code>g</code> should be the same as applying <code>&gt;&gt;=</code> to <code>m</code> and a function of argument <code>x</code> that first applies <code>f</code> to <code>x</code> and then binds it to <code>g</code>.</p></blockquote>

<p>Phew&#8230;another mouthful, huh? Code should make it clearer. As usual, Haskell comes first:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>  <span class="ow">=</span>  <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>And now let&#8217;s prove it in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">&gt;&gt;=</span> <span class="p">(</span><span class="nf">:bind</span> <span class="nv">maybe-monad</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">return</span> <span class="p">(</span><span class="nf">:return</span> <span class="nv">maybe-monad</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">m</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="nv">v</span> <span class="mi">2</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">g</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">v</span> <span class="mi">10</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">&gt;&gt;=</span> <span class="nv">m</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nf">&gt;&gt;=</span> <span class="nv">g</span><span class="p">))</span> <span class="c1">;; 30</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;;is the same as</span>
</span><span class='line'><span class="p">(</span><span class="nf">&gt;&gt;=</span> <span class="nv">m</span>
</span><span class='line'>     <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">&gt;&gt;=</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">g</span><span class="p">)))</span> <span class="c1">;; 30</span>
</span></code></pre></td></tr></table></div></figure>


<p>Alright, we&#8217;re getting to the end now! Hold on just a little longer!</p>

<h3>One last thing - The List Monad</h3>

<p>Yeah, I&#8217;m sure you saw this coming. Lists are monads too! I&#8217;ll make this quick and show its implementation and usage in Clojure - bear with me one last time.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">list-monad</span> <span class="p">{</span>
</span><span class='line'>    <span class="nv">:return</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v</span><span class="p">]</span> <span class="p">[</span><span class="nv">v</span><span class="p">])</span>
</span><span class='line'>    <span class="nv">:bind</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mv</span> <span class="nv">f</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">seq </span><span class="nv">mv</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">apply </span><span class="nv">concat</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="nv">mv</span><span class="p">))</span>
</span><span class='line'>            <span class="p">[]))</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;;let&#39;s play with it</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">domonad</span> <span class="nv">list-monad</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
</span><span class='line'>     <span class="nv">b</span> <span class="p">[</span><span class="nv">a,</span> <span class="p">(</span><span class="nb">- </span><span class="nv">a</span><span class="p">)]]</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="nv">b</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; (3 -3 6 -6)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">domonad</span> <span class="nv">list-monad</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
</span><span class='line'>     <span class="nv">b</span> <span class="p">[]]</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="nv">b</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; () - an empty list. </span>
</span></code></pre></td></tr></table></div></figure>


<p>This should look familiar if you&#8217;ve used <a href="http://clojuredocs.org/clojure_core/clojure.core/for">list comprehensions</a> in Clojure or other languages such as Python:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">for </span><span class="p">[</span><span class="nv">a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
</span><span class='line'>     <span class="nv">b</span> <span class="p">[</span><span class="nv">a,</span> <span class="p">(</span><span class="nb">- </span><span class="nv">a</span><span class="p">)]]</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="nv">b</span><span class="p">))</span>
</span><span class='line'><span class="c1">;; (3 -3 6 -6)</span>
</span></code></pre></td></tr></table></div></figure>


<p>See? You&#8217;ve been using monads all along and didn&#8217;t even know it! How awesome is that?</p>

<p>Also note that we didn&#8217;t need to re-implement <code>domonad</code> for the list monad. It&#8217;s a generic macro that will work with any monads you throw at it!</p>

<p>It&#8217;s interesting to see how the list and the maybe monads differ. This time, <code>return</code> puts the value <code>v</code> inside a list and returns it because for lists, a minimum monad is a list with a single element.</p>

<p><code>bind</code> is a bit more interesting. It first checks to see if <code>mv</code> is empty, in which case it returns an empty list, causing the whole computation to stop. If, however, <code>mv</code> is NOT empty, it maps <code>f</code> over every element in <code>mv</code>.</p>

<p>The resulting list is potentially a list of lists, since functions fed to monads - such as <code>f</code> in this case - have to return monadic values. That&#8217;s why we then apply <code>concat</code> to the resulting list, effectively flattening it.</p>

<h3>Final words</h3>

<p>Hopefully you now have a much better understanding of Monads and should start seeing in your code use cases and/or opportunities for the monads shown here.</p>

<p>You&#8217;ll notice that this Clojure implementation of monads used only normal functions - that was by design since I wanted this implementation to be as close as possible to Clojure&#8217;s <a href="https://github.com/clojure/algo.monads">core.algo.monads</a> library. You should have a look at it.</p>

<p>Also, bear in mind that this tutorial is by no means exhaustive - there&#8217;s <strong>a lot</strong> more about monads that I could possibly cover in a blog - it was hard enough ending it here! But if you want to study more about them, I&#8217;d recommend starting with these resources:</p>

<ul>
<li><p><a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good</a> - this book is an excellent intro to Haskell and it was the approach found there that made me grok monads - highly recommended and freely available online.</p></li>
<li><p><a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads">The Monads Section on the Haskell wikibook</a> - another free online resource</p></li>
</ul>


<p>That&#8217;s it from me. I hope you enjoyed the read and if you made it until here, a big <em>thank you</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monads in small bites - Part III - Monoids]]></title>
    <link href="http://www.leonardoborges.com/writings/2012/12/05/monads-in-small-bites-part-iii-monoids/"/>
    <updated>2012-12-05T09:25:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2012/12/05/monads-in-small-bites-part-iii-monoids</id>
    <content type="html"><![CDATA[<p>This is Part III of my Monads tutorial. Make sure you read the previous parts:</p>

<ul>
<li><p><a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Part I   - Functors</a></p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Part II  - Applicative Functors</a></p></li>
<li><p>Part III - Monoids (this post)</p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/08/monads-in-small-bites-part-iv-monads/">Part IV  - Monads</a></p></li>
</ul>


<h3>Monoids</h3>

<p>Simply put, Monoids describe types containing a <a href="http://en.wikipedia.org/wiki/Binary_function">binary function</a> and an identity value.</p>

<p>When applied to the identity value and a random value <code>x</code>, said function leaves its argument <code>x</code> <em>untouched</em>, returning it as a result.</p>

<p>This short description should be enough to get the conversation started.</p>

<p>Here&#8217;s how Haskell defines a Monoid:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">class</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">mempty</span> <span class="ow">::</span> <span class="n">m</span>
</span><span class='line'>    <span class="n">mappend</span> <span class="ow">::</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span>
</span><span class='line'>    <span class="n">mconcat</span> <span class="ow">::</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span>
</span><span class='line'>    <span class="n">mconcat</span> <span class="n">ms</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">mappend</span> <span class="n">mempty</span> <span class="n">ms</span>
</span></code></pre></td></tr></table></div></figure>


<p>This type introduces three new functions so let&#8217;s walk through each one of them:</p>

<blockquote><p><strong>mempty</strong> - I started with a lie since <code>mempty</code> isn&#8217;t actually a function. You can think of it as a constant of the same type of the Monoid <code>m</code>. It is this monoid&#8217;s identity value.</p>

<p><strong>mappend</strong> - A poorly named function, <code>mappend</code> is the binary function I mentioned earlier. It receives two arguments of type <code>m</code> and returns a value of type <code>m</code></p>

<p><strong>mconcat</strong> - It receives a list of Monoids <code>m</code> and reduces them to a single Monoid of type <code>m</code>. What&#8217;s interesting about this snippet is that the Monoid type class provides a default implementation for <code>mconcat</code>: it simply calls <em><a href="http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl" title="">foldr</a></em> with the binary function <code>mappend</code>, a starting value of <code>mempty</code> and the list of Monoid values <code>ms</code></p></blockquote>

<p>Enough Haskell! Let&#8217;s have a look at a few examples.</p>

<p>Did you know that, in Clojure,  the functions <code>*</code> and <code>+</code> are monoids? Yup. But don&#8217;t take my word for it. Let me prove it to you:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span> <span class="nv">mempty</span> <span class="p">(</span><span class="nf">+</span><span class="p">))</span> <span class="c1">;; 0</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span> <span class="nv">mappend</span> <span class="nv">+</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">mconcat</span> <span class="p">[</span><span class="nv">ms</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">reduce </span><span class="nv">mappend</span> <span class="nv">mempty</span> <span class="nv">ms</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">mappend</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; 7</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">mconcat</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">;; 9</span>
</span></code></pre></td></tr></table></div></figure>


<p>Whoa!  What happened here? Am I just making this stuff up?</p>

<p>Not really. I only defined the same haskell names to their Clojure counterparts for clarity. Totally overkill. The code above is the same as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">+</span><span class="p">)</span> <span class="c1">;; 0</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; 7</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">;; 9</span>
</span></code></pre></td></tr></table></div></figure>


<p>Did you notice that on the second call to <code>reduce</code> we did not provide an initial value? That&#8217;s because <code>reduce</code> will attempt to get its initial accumulator by calling the reducing function without arguments - hence <code>mempty == (+)</code>.</p>

<p>So that means we don&#8217;t even need an <code>mconcat</code> function since in Clojure,  <code>reduce</code> works with monoids as well!</p>

<blockquote><p><strong>Update</strong>: this isn&#8217;t entirely true. When I wrote this post I had in mind the version of <code>reduce</code> provided by the Clojure (1.5+) reducers library. The <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L71">source code</a> shows how that is the case.</p>

<p>The implementation of <code>reduce</code> in <code>clojure.core</code> however uses the first element of the collection being reduced over as its seed.</p></blockquote>

<p>But how the hell do you create a monoid in Clojure then? I&#8217;m glad you asked. Let&#8217;s create our own <em>plus-monoid</em>!</p>

<h4>Your first monoid</h4>

<p>In <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Part I</a> I implemented Functors using <a href="http://clojure.org/protocols">protocols</a> and <a href="http://clojuredocs.org/clojure_core/clojure.core/defrecord">records</a>. In <a href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Part II</a> I showed how Applicative Functors could be implemented using <a href="http://clojure.org/multimethods">multimethods</a>.</p>

<p>This time around I won&#8217;t be using any of these. I&#8217;ll implement Monoids using pure functions:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">plus-monoid</span>
</span><span class='line'>    <span class="p">([]</span>
</span><span class='line'>        <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">([</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">plus-monoid</span><span class="p">)</span> <span class="c1">;; 0 - same as mempty</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">plus-monoid</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; 7 - same as mappend</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">reduce </span><span class="nv">plus-monoid</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">;; 9 - when working with monoids, reduce is the same as mconcat</span>
</span></code></pre></td></tr></table></div></figure>


<p>We start by defining a function with multiple arities. The first body receives no arguments, so we just return the identity value for summation, which is <em>0 (zero)</em>. The second body receives two arguments so we can just add them up. Multiplication can be implemented in a similar fashion but obviously with the identity value of <em>one</em>.</p>

<p>Easy, huh?</p>

<p>Oh, by the way, lists are Monoids too! Who&#8217;d have thought?</p>

<p>Here&#8217;s its Clojure implementation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">list-monoid</span>
</span><span class='line'>    <span class="p">([]</span>
</span><span class='line'>        <span class="o">&#39;</span><span class="p">())</span>
</span><span class='line'>    <span class="p">([</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">concat </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">list-monoid</span><span class="p">)</span> <span class="c1">;; () - remember, same as mempty</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">list-monoid</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span> <span class="c1">;; (1 2 3 4 5 6) - remember, same as mappend</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">reduce </span><span class="nv">list-monoid</span> <span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]])</span> <span class="c1">;; (1 2 3 4 5 6 7 8 9) - mconcat in action</span>
</span></code></pre></td></tr></table></div></figure>


<p>Same rules apply but for lists <code>mappend</code> is achieved by using <code>concat</code> inside our monoid function.</p>

<p>Also, since our binary function concatenates two lists together it makes sense that <code>mempty</code> is <code>()</code> (the empty list). Remember <code>mempty</code> is supposed to be an identity value so if we stitch <code>()</code> and <code>[1 2 3]</code> together, we&#8217;re left with <code>[1 2 3]</code> which is exactly what we&#8217;d expect.</p>

<blockquote><p>You can see now why I said <code>mappend</code> was poorly named. While it makes sense when you think about lists, <code>mappend</code> doesn&#8217;t do any appending in our <em>plus-monoid</em> and in fact most monoids don&#8217;t append anything. Just keep this in mind if you see any haskell code using it: <code>mappend</code> is just a binary function.</p></blockquote>

<h3>Don&#8217;t break the law</h3>

<p>You saw this coming, huh? Monoids also come with a couple of laws. You know the drill. Let&#8217;s prove they both hold.</p>

<h4>Identity</h4>

<blockquote><p>Applying <code>mappend</code> to <code>mempty</code> and a monoid <code>x</code> should be the same as the original <code>x</code> monoid.</p></blockquote>

<p>In Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">mappend</span> <span class="n">mempty</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</span><span class='line'><span class="nf">mappend</span> <span class="n">x</span> <span class="n">mempty</span> <span class="ow">=</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>And the proof in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; first, the plus-monoid</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">mempty</span> <span class="p">(</span><span class="nf">plus-monoid</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; This...</span>
</span><span class='line'><span class="p">(</span><span class="nf">plus-monoid</span> <span class="nv">mempty</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">;; 10</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nf">plus-monoid</span> <span class="nv">x</span> <span class="nv">mempty</span><span class="p">)</span> <span class="c1">;; 10</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;;now, the list-monoid</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">mempty</span> <span class="p">(</span><span class="nf">list-monoid</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; This...</span>
</span><span class='line'><span class="p">(</span><span class="nf">list-monoid</span> <span class="nv">mempty</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">;; (1 2 3)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nf">list-monoid</span> <span class="nv">x</span> <span class="nv">mempty</span><span class="p">)</span> <span class="c1">;; (1 2 3)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Associativity</h4>

<blockquote><p>Applying <code>mappend</code> to a monoid <code>x</code> and the result of applying <code>mappend</code> to the monoids <code>y</code> and <code>z</code> should be the same as first applying <code>mappend</code> to the monoids <code>x</code> and <code>y</code> and then applying <code>mappend</code> to the resulting monoid and the monoid <code>z</code></p></blockquote>

<p>In Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">mappend</span> <span class="n">x</span> <span class="p">(</span><span class="n">mappend</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mappend</span> <span class="p">(</span><span class="n">mappend</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">z</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the proof in Clojure - remember that calling the monoid function with two arguments is equivalent to <code>mappend</code> in haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; first, the plus-monoid</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="mi">25</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">z</span> <span class="mi">40</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; This...</span>
</span><span class='line'><span class="p">(</span><span class="nf">plus-monoid</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">plus-monoid</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span> <span class="c1">;; 75</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nf">plus-monoid</span> <span class="p">(</span><span class="nf">plus-monoid</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span> <span class="c1">;; 75</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;;now, the list-monoid</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">[</span><span class="mi">40</span><span class="p">])</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">25</span><span class="p">])</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">z</span> <span class="p">[</span><span class="mi">50</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; This...</span>
</span><span class='line'><span class="p">(</span><span class="nf">list-monoid</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">list-monoid</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span> <span class="c1">;; (40 10 25 50)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nf">list-monoid</span> <span class="p">(</span><span class="nf">list-monoid</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span> <span class="c1">;; (40 10 25 50)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Almost there&#8230;</h3>

<p>This puts an end to Part III. It&#8217;s time to head to the pub.</p>

<p>When you&#8217;re back look for the final post in these series - <a href="http://www.leonardoborges.com/writings/2012/12/08/monads-in-small-bites-part-iv-monads/">Part IV</a> - where we will conclude our journey by finally introducing Monads!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monads in small bites - Part II - Applicative Functors]]></title>
    <link href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/"/>
    <updated>2012-12-02T21:43:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors</id>
    <content type="html"><![CDATA[<p>This is Part II of my Monads tutorial. Make sure you read the previous parts:</p>

<ul>
<li><p><a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Part I   - Functors</a></p></li>
<li><p>Part II  - Applicative Functors (this post)</p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/05/monads-in-small-bites-part-iii-monoids/">Part III - Monoids</a></p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/08/monads-in-small-bites-part-iv-monads/">Part IV  - Monads</a></p></li>
</ul>


<h3>Applicative Functors</h3>

<p>In <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Part I</a> I talked a little about Haskell type signatures and introduced Functors, which provide a way to map standard functions over values which are <em>wrapped</em> inside a Functor - we used <code>fmap</code> for that. You might want to <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">skim through it</a> again as a refresher.</p>

<p>Now suppose you have Functors that <em>wrap</em> functions and that you want to apply those <em>wrapped</em> functions to other Functors, maybe even composing new functions on the way!</p>

<p>What then?</p>

<p>Well you&#8217;re in luck! Applicative Functors do just that! They&#8217;re <strong>Functors on steroids</strong>.</p>

<p>Here&#8217;s how Haskell defines the Applicative data type:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>Based on our previous knowledge of Haskell&#8217;s type signatures, we can infer from this definition that in order for it to be an Applicative Functor, <code>f</code> <em>must</em> already be a Functor.</p>

<p>Let&#8217;s break this down and have a closer look at the two new functions this type introduces:</p>

<blockquote><p><strong>pure</strong> is a function that takes a value <code>a</code> and <em>wraps</em> it into a minimal Functor <code>f</code>.</p>

<p><strong>&lt;*></strong> is a function that takes two arguments: the first is a Functor <code>f</code> that wraps a function of type <code>a -&gt; b</code>. The second argument is a Functor <code>f</code> that wraps a value - which could be a function! - of type <code>a</code>. The final result is a Functor <code>f</code> that wraps some value of type <code>b</code> - which was obtained by somehow applying the function <code>(a -&gt; b)</code> to the Functor <code>f a</code>.</p></blockquote>

<p><code>pure</code> has a straightforward explanation whereas <code>&lt;*&gt;</code> is a bit more involved.</p>

<p>To clear things up, I&#8217;ll show the type signatures again but this time as if they only worked with the List Functor that we&#8217;ve been working on:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">[(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&#8217;s revisit those definitions:</p>

<blockquote><p><strong>pure</strong> is a function that takes a value <code>a</code> and <em>puts</em> it into an empty list, returning the resulting single element list.</p>

<p><strong>&lt;*></strong> is a function that takes two arguments: the first is a list containing one or more functions of type <code>a -&gt; b</code>. The second argument is a list of one or more values - or functions! - of type <code>a</code>. The final result is a list of one or more values of type <code>b</code> - which was obtained by somehow applying the function <code>(a -&gt; b)</code> to the Functor <code>f a</code>.</p></blockquote>

<p>Enough definitions though! Let&#8217;s extend our List Functor and make it an Applicative as well.</p>

<p>While we&#8217;ll still be using the List Functor we implemented in <a href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Part I</a>, this time I&#8217;ll implement its Applicative version using <a href="http://clojure.org/multimethods">multimethods</a> for a change.  Here&#8217;s the code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; it dispatches on the record type since we could have implementations of pure for List, Maybe, Either etc...</span>
</span><span class='line'><span class="p">(</span><span class="k">defmulti </span><span class="nv">pure</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span> <span class="nv">_</span><span class="p">]</span> <span class="nv">f</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">defmethod </span><span class="nv">pure</span> <span class="nv">List</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">v</span><span class="p">]</span>
</span><span class='line'>    <span class="s">&quot;Wraps value v in a list&quot;</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="nv">v</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; it dispatches on the class of the Functor instance passed in the 1st argument</span>
</span><span class='line'><span class="p">(</span><span class="k">defmulti </span><span class="nv">&lt;*&gt;</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">fs</span> <span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nb">class </span><span class="nv">fs</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="k">defmethod </span><span class="nv">&lt;*&gt;</span> <span class="nv">List</span> <span class="p">[</span><span class="nv">fs</span> <span class="nv">xs</span><span class="p">]</span>
</span><span class='line'>    <span class="s">&quot;Unwraps the functions in fs, applies them to the Functors in xs, wrapping the result at the end&quot;</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">(</span><span class="k">for </span><span class="p">[</span><span class="nv">f</span> <span class="p">(</span><span class="nf">:wrapped</span> <span class="nv">fs</span><span class="p">)</span>
</span><span class='line'>                 <span class="nv">x</span> <span class="p">(</span><span class="nf">:wrapped</span> <span class="nv">xs</span><span class="p">)]</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>By focusing on the List as an Applicative Functor we can more easily understand what these functions do. From the code above, <code>pure</code>&#8217;s job is a simple one: all it does is <em>wrap</em> it&#8217;s argument <code>v</code> into a minimal List functor which in our case means a Functor wrapping a one element list.</p>

<p><code>&lt;*&gt;</code> on the other hand is responsible for somehow unwrapping the functions brought in by the Applicatives in <code>fs</code> and applying them to the [Applicative] Functors in <code>xs</code>. It does that by using <a href="http://clojuredocs.org/clojure_core/clojure.core/for">list comprehensions</a> and <em>wraps</em> the result into a new List Functor.</p>

<p>Study this code carefully. It <em>can</em> be tricky.</p>

<blockquote><p><strong>Note</strong>: When I first encountered <strong>&lt;*></strong> I had no idea what this function was called. I asked the twittersphere and it seems it&#8217;s called <code>apply</code>. In the process of figuring this out I was enlightened <a href="https://twitter.com/leonardo_borges/status/267777875367841792">by this conversation</a>. It turns out <code>&lt;*&gt;</code> has several names. Can you guess which one is my favorite? :)</p></blockquote>

<p>With the Applicative functions defined for our List, let&#8217;s take it for a spin:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">fs</span> <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="mi">2</span> <span class="nv">%</span><span class="p">)</span> <span class="o">#</span><span class="p">(</span><span class="nv">+</span> <span class="mi">10</span> <span class="nv">%</span><span class="p">)]))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">fs</span> <span class="nv">xs</span><span class="p">)</span> <span class="c1">;; List{:wrapped (2 4 6 11 12 13)}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">g</span> <span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="mi">50</span> <span class="nv">%</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">g</span> <span class="nv">xs</span><span class="p">)</span> <span class="c1">;; List{:wrapped (50 100 150)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There should have been no surprises here. Read the code again and make sure it&#8217;s all fresh before moving along.</p>

<h3>Don&#8217;t break the law</h3>

<p>Just as Functors, Applicative Functors also need to obey some laws:</p>

<h4>Identity</h4>

<blockquote><p>Feeding a function <code>f</code> to <code>pure</code> and applying the resulting Applicative to the Functor <code>v</code> should be the same as directly mapping <code>f</code> over the Functor <code>v</code></p></blockquote>

<p>In Haskell speak:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">v</span>
</span></code></pre></td></tr></table></div></figure>


<p>And this is the proof, in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="o">#</span><span class="p">(</span><span class="nv">+</span> <span class="mi">2</span> <span class="nv">%</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="mi">10</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">v</span><span class="p">)</span> <span class="c1">;; List{:wrapped (12)}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nf">fmap</span> <span class="nv">v</span> <span class="nv">f</span><span class="p">)</span> <span class="c1">;; List{:wrapped (12)}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Composition</h4>

<blockquote><p>The result of <em>applying</em> an Applicative Functor that yields the <strong>function composition</strong> operator to the Applicative <code>u</code>, then apply the resulting Functor to <code>v</code> and finally applying that result to the final Applicative <code>w</code> should be the same as <em>applying</em> <code>v</code> to <code>w</code> and then <em>applying</em> <code>u</code> to the resulting <em>Applicative</em>.</p></blockquote>

<p>That was a mouthful! Let&#8217;s see how Haskell tells this story:</p>

<p>In Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>I needed to cheat a bit in Clojure to prove this law since functions are not <a href="http://www.haskell.org/haskellwiki/Currying">curried by default like they are in Haskell</a>. But this code should still clearly show how this law holds:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">u</span> <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="mi">2</span> <span class="nv">%</span><span class="p">)]))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="o">#</span><span class="p">(</span><span class="nv">+</span> <span class="mi">10</span> <span class="nv">%</span><span class="p">)]))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">w</span> <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; Given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">comp</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">u</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">v</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">w</span><span class="p">))</span> <span class="c1">;; List{:wrapped (22 24 26)}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">u</span> <span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">v</span> <span class="nv">w</span><span class="p">))</span> <span class="c1">;; List{:wrapped (22 24 26)}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Homomorphism</h4>

<blockquote><p>The result of applying the <code>pure</code> value of <code>f</code> to the <code>pure</code> value of <code>x</code> should be the same as applying <code>f</code> directly to <code>x</code> and then feeding that into <code>pure</code>.</p></blockquote>

<p>In Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>And in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="mi">2</span> <span class="nv">%</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="nv">f</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="nv">x</span><span class="p">)))</span> <span class="c1">;; List{:wrapped (20)}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">;; List{:wrapped (20)}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Interchange</h4>

<blockquote><p>The result of applying an Applicative Functor <code>u</code> to the <code>pure</code> value of <code>y</code> should be the same as taking the Applicative obtained by calling <code>pure</code> with a function that applies its argument to <code>y</code> and then applying that to <code>u</code></p></blockquote>

<p>In Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">u</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span>
</span></code></pre></td></tr></table></div></figure>


<p>This type signature presents new syntax so before proving the law in Clojure, I want to explain what <code>($ y)</code> means.</p>

<p>In Haskell, <code>$</code> is the function application operator. So if we give <code>y</code> a value of <em>10</em>, I can show you that in this law <code>$</code> essentially translates to a single argument function that applies its argument to <em>10</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">let</span> <span class="n">double</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">-- helper function. it doubles its argument</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- given the above, this...</span>
</span><span class='line'><span class="p">((</span><span class="o">$</span> <span class="mi">10</span><span class="p">)</span> <span class="n">double</span><span class="p">)</span> <span class="c1">-- 20</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- ...is the same as:</span>
</span><span class='line'><span class="kr">let</span> <span class="n">dollarTen</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="mi">10</span><span class="p">))</span>  <span class="c1">-- this is Haskell&#39;s lambda syntax. It&#39;s equivalent to ($ 10)</span>
</span><span class='line'><span class="p">((</span><span class="n">dollarTen</span><span class="p">)</span> <span class="n">double</span><span class="p">)</span> <span class="c1">-- 20</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, to the proof in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">u</span> <span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="o">#</span><span class="p">(</span><span class="nv">+</span> <span class="mi">10</span> <span class="nv">%</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="mi">50</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="nv">u</span> <span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; List{:wrapped (60)}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; ...is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">dollar-y</span> <span class="o">#</span><span class="p">(</span><span class="nv">%</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;; it&#39;s called dollar-y to show the correlation with the explanation above</span>
</span><span class='line'><span class="p">(</span><span class="nf">&lt;*&gt;</span> <span class="p">(</span><span class="nf">pure</span> <span class="nv">List</span> <span class="nv">dollar-y</span><span class="p">)</span> <span class="nv">u</span><span class="p">)</span> <span class="c1">;; List{:wrapped (60)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This brings us to the end or Part II. Two down and two to go.</p>

<p>I hope you&#8217;re still with me but go home now.</p>

<p>Or better yet go to the gym lift some weights and think about these Functors on steroids. When you&#8217;re back, look out for <a href="http://www.leonardoborges.com/writings/2012/12/05/monads-in-small-bites-part-iii-monoids/">Part III</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monads in small bites - Part I - Functors]]></title>
    <link href="http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/"/>
    <updated>2012-11-30T01:06:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors</id>
    <content type="html"><![CDATA[<p>Today I join the already bloated group of people who wrote monad tutorials. It&#8217;s a bit of a ritual, really.</p>

<p>Different than most tutorials though I aim to take a different approach. The good news is that I won&#8217;t be comparing monads to burritos :)</p>

<p>People say one needs to have his/her own epiphany in order to understand Monads and reading explanations from others is of little help. My goal is to disprove that.</p>

<p>To that end, this tutorial will be split in four parts:</p>

<ul>
<li><p>Part I   - Functors (this post)</p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Part II  - Applicative Functors</a></p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/05/monads-in-small-bites-part-iii-monoids/">Part III - Monoids</a></p></li>
<li><p><a href="http://www.leonardoborges.com/writings/2012/12/08/monads-in-small-bites-part-iv-monads/">Part IV  - Monads</a></p></li>
</ul>


<p>You might want to bookmark this page - once the other parts are up, I&#8217;ll update the list above with the links to them.</p>

<h3>Before we start</h3>

<p>I know what you&#8217;re thinking: Do I really need to know Applicative Functors just to grasp Monads?</p>

<p>Well, no. However, I found that gradually building your knowledge from Parts I, II and III will allow you to fully grasp monads without the need for burritos or elephants.</p>

<p>You should also be familiar with a functional programming language. Any language should be fine but you&#8217;ll get the most out of this tutorial if you&#8217;re familiar with Haskell and/or Clojure.</p>

<p>If you&#8217;re not familiar with Clojure, fear not - Clojure is a small language and the code snippets should still make sense if you put your mind to it - they&#8217;re all short and sweet. I also encourage you to re-implement the examples in your language of choice to gain a deeper understanding on the subject.</p>

<p>Ready then? Let&#8217;s dive in.</p>

<h2>Just enough Haskell</h2>

<p>This is not a Haskell tutorial but trust me when I tell you that learning just enough about its type signatures will make all the difference in the world in understanding the concepts I&#8217;m about to present.</p>

<p>Although I&#8217;ll be using a little bit of Haskell syntax, I&#8217;ll also provide implementations in Clojure. They are in order so you should be able to paste all code sample in the REPL and follow along if you wish.</p>

<h3>Type signatures</h3>

<p>I&#8217;ll make this quick. Say you have a function called <code>mk-vec</code> that creates a 2D vector with <code>x</code> and <code>y</code> coordinates. Such function could easily be coded in Clojure like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">mk-vec</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:x</span> <span class="nv">x</span> <span class="nv">:y</span> <span class="nv">y</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; using it</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">my-vec</span> <span class="p">(</span><span class="nf">mk-vec</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nf">:x</span> <span class="nv">my-vec</span><span class="p">)</span> <span class="c1">;; 10</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, this function takes two arguments - x and y - and returns a map - or hash if you come from Ruby - that wraps those values in it, providing an easy way to retrieve them.</p>

<p>Now if this function had been implemented in haskell this would be its type signature - read the comments:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span> <span class="c1">-- just giving Data.Map an alias</span>
</span><span class='line'><span class="nf">mkVec</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="n">a</span> <span class="c1">-- this is the type signature</span>
</span><span class='line'>
</span><span class='line'><span class="nf">mkVec</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="c1">-- this is the implementation. You can ignore this part.</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- using it</span>
</span><span class='line'><span class="nf">myVec</span> <span class="ow">=</span> <span class="n">mkVec</span> <span class="mi">10</span> <span class="mi">15</span>
</span><span class='line'><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;x&quot;</span> <span class="n">myVec</span> <span class="c1">-- Just 10 </span>
</span><span class='line'><span class="c1">--</span>
</span><span class='line'><span class="c1">-- ignore the actual value that is returned. Read it as 10 for now.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Whatever comes after the <code>::</code> is part of the function type signature. Read it like this:</p>

<blockquote><p>This is a function that receives two arguments of type <code>a</code> - which means any type - and returns a Map of key/value pairs where the key is of type <code>[Char]</code> - technically a list of <code>Char</code> values but for all effects and purposes just read it as <code>String</code> - and the value is of type <code>a</code> - the same type as its arguments.</p></blockquote>

<p>It might help to see the type signature in this light:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">mkVec</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>It highlights the return value in parenthesis.</p>

<p>Now let&#8217;s have a look at a built in function, <code>*</code>. As you know, it performs multiplication and this is its type signature:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>Can you guess now what it means? I&#8217;m sure you can. There&#8217;s one small difference though: this function has a type constraint - it&#8217;s that <strong>Num a => &#8230;</strong> part of the signature. Read it like this:</p>

<blockquote><p>This is a function that receives two arguments of type <code>a</code> and returns a value of the same type, as long as the type of <code>a</code> is an instance of <code>Num</code></p></blockquote>

<p>And that&#8217;s it for now. Read it again to make sure it&#8217;s fresh in your mind and then continue.</p>

<p>As we encounter more type signatures, I&#8217;ll walk you through each one of them - but if you got it up until now, you&#8217;ll easily grasp the other type signatures.</p>

<h3>Functors</h3>

<p>In a nutshell Functors are things that can be mapped over.</p>

<p>Haskell defines Functors like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
</span><span class='line'>  <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&#8217;s dissect that type signature:</p>

<blockquote><p><strong>fmap</strong> is a function that receives two arguments: the first is a function that receives an argument of type <code>a</code> and returns a value of type <code>b</code> and the second is a Functor that contains a value of type <code>a</code> - represented by <code>f a</code>. The result of calling <code>fmap</code> is a Functor of same type - <code>f</code> - containing a value of type <strong>b</strong>, which is the result of applying the function to <strong>a</strong>.</p></blockquote>

<p>Too much? Let&#8217;s have a look at an example: the <strong>List</strong> Functor.</p>

<p>If we rewrite the <code>fmap</code> type signature as if it only worked on lists, this is what we&#8217;d come up with:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'>  <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This new type signature allows us to rewrite that last definition:</p>

<blockquote><p><strong>fmap</strong> is a function that receives two arguments: the first is a function that receives an argument of type <code>a</code> and returns a value of type <code>b</code> and the second is a List of zero or more values of type <strong>a</strong>. The result of calling <code>fmap</code> is a List of zero or more values of type <strong>b</strong>, each of which is the result of applying the function to each <code>a</code> element.</p></blockquote>

<p>Does this sound familiar to you? It should, because this is essentially what the <code>map</code> function available in most functional-<em>ish</em> languages does! It takes a function and a list, applies the function to every element in the list while putting the results into a new list, finally returning it.</p>

<p>In fact, the <code>fmap</code> implementation of the List Functor from Haskell is implemented in terms of <code>map</code>.</p>

<p>Let&#8217;s see how that could be done in Clojure. I&#8217;ll use <a href="http://clojure.org/protocols">protocols</a> and <a href="http://clojure.org/datatypes">records</a> but they are not strictly required for this.</p>

<p>Here&#8217;s our Functor protocol:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defprotocol</span> <span class="nv">Functor</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">fmap</span> <span class="p">[</span><span class="nv">functor</span> <span class="nv">f</span><span class="p">]</span> <span class="s">&quot;Maps fn over the functor f&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And now our List Functor:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defrecord</span> <span class="nv">List</span> <span class="p">[</span><span class="nv">wrapped</span><span class="p">]</span>
</span><span class='line'>    <span class="nv">Functor</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">fmap</span> <span class="p">[</span><span class="nv">functor</span> <span class="nv">f</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">(</span><span class="nf">:wrapped</span> <span class="nv">functor</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the snippet above all we&#8217;re saying is that the List record must satisfy the Functor protocol, which makes sense. <code>fmap</code> then is responsible for <em>unwrapping</em> the value contained in the list functor and <em>mapping</em> <code>f</code> over it.</p>

<p>Give it a go!</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">my-list-functor</span> <span class="p">(</span><span class="nf">List</span><span class="o">.</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]))</span> <span class="c1">;; List{:wrapped (1 2 3)}</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">fmap</span> <span class="nv">my-list-functor</span> <span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="mi">2</span> <span class="nv">%</span><span class="p">))</span> <span class="c1">;; List{:wrapped (2 4 6)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can now <code>map</code> arbitrary functions over the values <code>wrapped</code> in a Functor! Awesome!</p>

<blockquote><p><strong>Note</strong>: In our Clojure version of the List Functor, it is implemented as a Record that wraps a primitive Clojure list/vector - <code>[]</code>. As I mentioned this is not necessary but I chose to do it here to explicitly show the relationship with the Haskell types.</p></blockquote>

<h3>Don&#8217;t break the law</h3>

<p>Now that we got a feel for what Functors are, it&#8217;s worth noting that they must obey a few laws to be considered full-fledged Functors.</p>

<h4>Identity</h4>

<blockquote><p>Mapping an identity function over a Functor is the same as applying identity to the Functor itself</p></blockquote>

<p>This is how Haskell puts this law:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fmap</span> <span class="n">id</span> <span class="n">functor</span> <span class="ow">=</span> <span class="n">id</span> <span class="n">functor</span>
</span></code></pre></td></tr></table></div></figure>


<p>Translating that to Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;;This...</span>
</span><span class='line'><span class="p">(</span><span class="nf">fmap</span> <span class="nv">my-list-functor</span> <span class="nv">identity</span><span class="p">)</span> <span class="c1">;; List{:wrapped (1 2 3)}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;;is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nb">identity </span><span class="nv">my-list-functor</span><span class="p">)</span> <span class="c1">;; List{:wrapped [1 2 3]}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Composition</h4>

<blockquote><p>If you compose the functions <code>f</code> and <code>g</code> and map the resulting function over the Functor, that is the same as first mapping <code>g</code> over the Functor and <code>then</code> mapping <code>f</code> over the resulting Functor.</p></blockquote>

<p>From the description you can see that this law involves <a href="http://en.wikipedia.org/wiki/Function_composition">function composition</a>. In Clojure, that&#8217;s achieved with the <a href="http://clojuredocs.org/clojure_core/clojure.core/comp">comp</a> function.</p>

<p>Again, let&#8217;s see how this law is defined in Haskell:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">functor</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">g</span> <span class="n">functor</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>Note</strong>: The <code>.</code> operator denotes function composition in Haskell</p></blockquote>

<p>And the proof in Clojure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">f</span> <span class="o">#</span><span class="p">(</span><span class="nv">+</span> <span class="mi">10</span> <span class="nv">%</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">g</span> <span class="o">#</span><span class="p">(</span><span class="nv">*</span> <span class="mi">2</span> <span class="nv">%</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; given the above, this...</span>
</span><span class='line'><span class="p">(</span><span class="nf">fmap</span> <span class="nv">my-list-functor</span> <span class="p">(</span><span class="nb">comp </span> <span class="nv">f</span> <span class="nv">g</span><span class="p">))</span> <span class="c1">;; List{:wrapped (12 14 16)}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; is the same as:</span>
</span><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">my-list-functor</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nv">g</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nv">f</span><span class="p">))</span> <span class="c1">;; List{:wrapped (12 14 16)}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>Note</strong>: make sure you&#8217;re familiar with <a href="http://clojuredocs.org/clojure_core/clojure.core/-%3E">Clojure&#8217;s threading macro: <strong>-></strong> </a>. I&#8217;ll be using it in most code snippets.</p></blockquote>

<p>Nice! All laws hold so we can sleep peacefully in the knowledge that our Functor works as expected.</p>

<p>Now go get a drink and stay tuned for <a href="http://www.leonardoborges.com/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Part II</a>, where I&#8217;ll introduce <em>Applicative Functors</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure, leiningen 2 and Heroku: AOT compilation gotchas]]></title>
    <link href="http://www.leonardoborges.com/writings/2012/09/10/clojure-leiningen-heroku-aot-compilation-gotchas/"/>
    <updated>2012-09-10T10:41:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2012/09/10/clojure-leiningen-heroku-aot-compilation-gotchas</id>
    <content type="html"><![CDATA[<p>Recently I upgraded the <a href="http://clojure.org/">clojure</a> project I&#8217;m working on to <a href="http://leiningen.org/">Leiningen 2</a> in order to start using <a href="https://github.com/clojure/tools.nrepl">nrepl</a> - since <a href="https://github.com/technomancy/swank-clojure">swank-clojure</a> is now <a href="http://technomancy.us/163">deprecated</a>. Little did I know this would lead me to a small debugging adventure.</p>

<h3>Heroku</h3>

<p>I use <a href="http://www.heroku.com/">Heroku</a> as my deployment platform and my project had been running on it for a few weeks without any
issues. I also use Heroku&#8217;s PostgreSQL solution.</p>

<p>However, by upgrading to Leiningen 2, my project started throwing some weird exceptions during deployment -  it couldn&#8217;t connect to my database any longer. Everything was fine on my local environment though.</p>

<p>Upon inspecting the deployment logs on Heroku, I realized that the <a href="https://github.com/heroku/heroku-buildpack-clojure">Heroku Clojure Buildpack</a> tries to perform <a href="http://clojure.org/compilation">Ahead of Time (AOT) compilation</a> if it identifies the project is running Leiningen 2.x</p>

<p>This means that after receiving a git push Heroku runs this command:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>lein with-profile production compile :all
</span></code></pre></td></tr></table></div></figure>


<p>At first this might seem harmless. But step back for a second and think about what this means for code that depends on environment variables.</p>

<h3>Case in point: Lobos</h3>

<p><a href="https://github.com/budu/lobos">Lobos</a> is a clojure library for manipulating database schemas akin <a href="http://api.rubyonrails.org/classes/ActiveRecord/Migration.html">ActiveRecord migrations</a> in Ruby land.</p>

<p>The <a href="https://github.com/budu/lobos#real-world-example">real-world</a> example on their github page recommends this code snippet for configuring a database connection:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">ns</span> <span class="nv">lobos</span><span class="o">.</span><span class="nv">config</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">:use</span> <span class="nv">lobos</span><span class="o">.</span><span class="nv">connectivity</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">db</span>
</span><span class='line'>  <span class="p">{</span><span class="nv">:classname</span> <span class="s">&quot;org.postgresql.Driver&quot;</span>
</span><span class='line'>   <span class="nv">:subprotocol</span> <span class="s">&quot;postgresql&quot;</span>
</span><span class='line'>   <span class="nv">:user</span> <span class="s">&quot;test&quot;</span>
</span><span class='line'>   <span class="nv">:password</span> <span class="s">&quot;test123&quot;</span>
</span><span class='line'>   <span class="nv">:subname</span> <span class="s">&quot;//localhost:5432/test&quot;</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">open-global</span> <span class="nv">db</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>More often than not this isn&#8217;t ideal. You&#8217;ll probably want to customise your database configuration based on environment variables. Something along these lines:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">ns</span> <span class="nv">lobos</span><span class="o">.</span><span class="nv">config</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">:use</span> <span class="nv">lobos</span><span class="o">.</span><span class="nv">connectivity</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">db</span>
</span><span class='line'>     <span class="p">{</span><span class="nv">:classname</span> <span class="s">&quot;org.postgresql.Driver&quot;</span>
</span><span class='line'>      <span class="nv">:subprotocol</span> <span class="s">&quot;postgresql&quot;</span>
</span><span class='line'>      <span class="nv">:user</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&quot;DB_USER&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">:password</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&quot;DB_PASSWORD&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">:subname</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&quot;DATABASE_URL&quot;</span><span class="p">)})</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">open-global</span> <span class="nv">db</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>And you&#8217;re good to go - until Heroku decides to AOT compile your code.</p>

<h3>Compilation</h3>

<p>The Clojure compilation process caught me by surprise. As stated by <a href="https://twitter.com/richhickey">Rich Hickey</a> on <a href="http://clojure-log.n01se.net/date/2008-11-12.html#16:07">this IRC log entry</a>, &#8220;a side effect of compiling Clojure code is loading the namespaces in order to make macros and functions they use available&#8221;.</p>

<p>This means that during compilation, any top level function calls - such as <code>(open-global db)</code> from above - will get executed. The same applies to macros that expand to top-level function calls.</p>

<p>If said function call has no side effects, you&#8217;re probably ok.</p>

<p>The trouble with <em>open-global</em> though is that it effectively attempts a connection to the database!</p>

<p><strong>BAM!</strong></p>

<p>On Heroku the environment variables you rely on - such as <em>DATABASE_URL</em> - aren&#8217;t available on compile time meaning a connection will be attempted to an empty url. <em>All sorts of badness</em>.</p>

<p>After having understood why the compilation process was effectively executing top level function calls, I then wrapped that call to <em>open-global</em> in a function declaration:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">init</span> <span class="p">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">open-global</span> <span class="p">(</span><span class="nf">db</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will prevent eager evaulation during compilation since all <code>defn</code> does is bind the given function body to a <em>var</em>.</p>

<p>Then, in the code that needs migrations to happen - such as in my <a href="https://github.com/marick/Midje">midje</a> tests setup - I initialize the database like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">background</span>
</span><span class='line'> <span class="p">(</span><span class="nf">before</span> <span class="nv">:contents</span> <span class="p">(</span><span class="nf">lobos</span><span class="o">.</span><span class="nv">config/init</span><span class="p">))</span>
</span><span class='line'> <span class="p">(</span><span class="nf">before</span> <span class="nv">:facts</span> <span class="p">(</span><span class="nf">migrate</span><span class="p">)</span>
</span><span class='line'>         <span class="nv">:after</span> <span class="p">(</span><span class="nf">rollback</span> <span class="nv">:all</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>I spent some time in the #clojure IRC channel on freenode and it is accepted that top level function calls should be avoided anyway - especially if you&#8217;re dealing with side effects.</p>

<p>I also applied the same principle to other initialization code I have such as the configuration for <a href="http://sqlkorma.com/">Korma</a>.</p>

<h3>Happy ending?</h3>

<p>Not quite. After having spent quite some time to get to this point, this was the new error that was stealing my sleep:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Caused by: java.lang.NullPointerException
</span><span class='line'>    at java.util.concurrent.ConcurrentHashMap.hash<span class="o">(</span>ConcurrentHashMap.java:332<span class="o">)</span>
</span><span class='line'>    at java.util.concurrent.ConcurrentHashMap.get<span class="o">(</span>ConcurrentHashMap.java:987<span class="o">)</span>
</span><span class='line'>    at clojure.lang.Namespace.find<span class="o">(</span>Namespace.java:188<span class="o">)</span>
</span><span class='line'>    at clojure.core<span class="nv">$find_ns</span>.invoke<span class="o">(</span>core.clj:3659<span class="o">)</span>
</span><span class='line'>    at clojure.core<span class="nv">$the_ns</span>.invoke<span class="o">(</span>core.clj:3691<span class="o">)</span>
</span><span class='line'>    at clojure.core<span class="nv">$ns_name</span>.invoke<span class="o">(</span>core.clj:3698<span class="o">)</span>
</span><span class='line'>    at my_app.env__init.load<span class="o">(</span>Unknown Source<span class="o">)</span>
</span><span class='line'>    at my_app.env__init.&lt;clinit&gt;<span class="o">(</span>Unknown Source<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This isn&#8217;t an unknown error. It basically means you&#8217;re trying to find a namespace that doesn&#8217;t exist. Or does it?</p>

<p>Once again this only happened if the code got compiled Ahead Of Time. Puzzling.</p>

<p>A couple of debugging hours later and I tracked it down to be a problem with <a href="https://github.com/malcolmsparks/clj-logging-config">clj-logging-config</a> - a logging configuration utility for clojure. This is the offending code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">ns</span> <span class="nv">my-app</span><span class="o">.</span><span class="nv">env</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">:use</span>
</span><span class='line'>    <span class="nv">clojure</span><span class="o">.</span><span class="nv">tools</span><span class="o">.</span><span class="nv">logging</span>
</span><span class='line'>    <span class="nv">clj-logging-config</span><span class="o">.</span><span class="nv">log4j</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nf">set-logger!</span><span class="p">)</span> <span class="c1">;; this call causes the exception</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>set-logger!</code> is a macro that makes use of the <strong>*ns*</strong> var. <strong>*ns*</strong> contains the current namespace and, due to what I&#8217;m assuming to be special semantics regarding this particular var, it shouldn&#8217;t be <a href="http://clojuredocs.org/clojure_core/clojure.core/unquote"><em>unquoted</em></a> within a macro - which is why it was failing in AOT mode.</p>

<p>I <a href="https://github.com/malcolmsparks/clj-logging-config/issues/15">opened an issue</a> in the clj-logging-config github page. I eventually forked the project and fixed the issue in <a href="https://github.com/malcolmsparks/clj-logging-config/pull/16">this pull request</a>. That was then <a href="https://github.com/malcolmsparks/clj-logging-config/commit/ec8a08535daad01eb9f23e92771b623b5902c8c9">merged last Friday</a>.</p>

<p>My code now works perfectly - regardless of AOT compilation.</p>

<h3>Final thoughts</h3>

<p>This was a nice little journey and I&#8217;m actually glad I went through it. I have a much better understanding of Clojure&#8217;s compilation process, worked out some quirks on Heroku and even got my first Clojure related open-source contribution accepted. Life is good.</p>

<p>Hopefully this will save other people a lot of time and effort debugging similar issues.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sean Corfield: Clojure and CFML sitting in a tree]]></title>
    <link href="http://www.leonardoborges.com/writings/2012/08/23/sean-corfield-clojure-and-cfml-sitting-in-a-tree/"/>
    <updated>2012-08-23T00:03:00+10:00</updated>
    <id>http://www.leonardoborges.com/writings/2012/08/23/sean-corfield-clojure-and-cfml-sitting-in-a-tree</id>
    <content type="html"><![CDATA[<p>Last night I attended the Adobe User Group here in Sydney. That might strike some of you as a big surprise
given my relationship with Adobe is pretty much limited to fiddling with Photoshop/Lightroom to get my photos looking nice.</p>

<p>However the reason for which I attended the meetup is that <a href="https://twitter.com/seancorfield">Sean Corfield</a> - a prolific member of the Clojure community - gave a presentation on how he introduced and migrated most of his backend code at <a href="http://worldsingles.com/ws2010/index.cfm">World Singles</a> from <a href="http://en.wikipedia.org/wiki/ColdFusion_Markup_Language">CFML</a> to <a href="http://clojure.org/">Clojure</a> - hence my interest.</p>

<p>What follows is a mix of my own notes and what I could remember from the slides:</p>

<h3>Going faster</h3>

<p>The original platform was built in CFML between 2001 and 2008. It was essentially monolithic procedural code. It was rewritten in 2009 - when they introduced OO and a new version of CFML</p>

<h3>Brief Stats</h3>

<ul>
<li>3 million members</li>
<li>1 million emails sent every day</li>
<li>2k concurrent users 24x7, on average</li>
</ul>


<h3>Clojure and WorldSingles</h3>

<ul>
<li>Tried .NET - ran into all sorts of trouble. Didn&#8217;t work well in production.</li>
<li>Tried Scala - Memory leaks in the built-in actor library were a deal breaker. The type system also wasn&#8217;t a good cultural fit.</li>
<li>Evaluated Clojure in 2010 - seemed like a good language to squeeze performance out of lower level components</li>
<li>Clojure version released in production in 2011

<ul>
<li>Rewrote remaining Scala Code</li>
<li>6.3k LOC - 1.5k Tests LOC</li>
<li>equivalent to 4x the CFML LOC</li>
<li>Clojure is essentially used in the model (as in MVC)</li>
</ul>
</li>
</ul>


<h3>Why add Clojure?</h3>

<ul>
<li>It&#8217;s fast - compiles down to JVM bytecode (and it&#8217;s faster than CFML)</li>
<li>Immutability (automatic thread safety)

<ul>
<li>they found several thread safety bugs in the third party ColdFusion libraries being used</li>
</ul>
</li>
<li>Built-in concurrency / parallelism support - <a href="http://clojuredocs.org/clojure_core/clojure.core/future">future</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/pmap">pmap</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/pvalues">pvalues</a> etc.</li>
<li>Lazy sequences - being able to work with potentially ininite collections without bringing your server down.</li>
<li>All high quality, production ready Java libraries easily accessible via <a href="http://clojure.org/java_interop">java interop</a>.</li>
</ul>


<h3>What do they use it for?</h3>

<ul>
<li>Email

<ul>
<li>html generation &amp; sending</li>
<li>tracking &amp; log file analysis</li>
</ul>
</li>
<li>Geolocation (rest/json)</li>
<li>i18n</li>
<li>Reporting (parallel queries) - he showed a bit of this code. Heavy use of <a href="http://clojuredocs.org/clojure_core/clojure.core/future">futures</a> + <a href="http://clojuredocs.org/clojure_core/clojure.core/deref">deref</a></li>
<li>Search engine integration (json/xml)

<ul>
<li>This breaks down to two Clojure components:</li>
<li>One feeds the search engine based on changes to the users profiles</li>
<li>The other then runs against the search engine 24x7 trying to find new matches for users</li>
</ul>
</li>
<li>(lightweight?) Persistence layer

<ul>
<li>no ORM - thin framework over sql instead</li>
<li>Same interface for both Mysql &amp; MongoDB</li>
<li>MongoDB being used after hitting performance issues in Mysql</li>
</ul>
</li>
</ul>


<h3>Clojure ecosystem/community</h3>

<p>Having an active Community is crucial for language adoption and the clojure community got this right:</p>

<ul>
<li>Community

<ul>
<li>6700 developers on the <a href="https://groups.google.com/forum/?fromgroups#!forum/clojure">mailing list</a></li>
<li>~300 developers on IRC 24x7</li>
</ul>
</li>
<li>Active library development

<ul>
<li>#23 language on Github</li>
<li>Over 7k projects on github</li>
<li>Nearly 2k libs on <a href="https://clojars.org/">Clojars</a></li>
</ul>
</li>
</ul>


<h3>The Future</h3>

<ul>
<li>Looking into <a href="https://github.com/nathanmarz/cascalog">Cascalog</a> for big data processing</li>
<li>All new back-end/model code written in Clojure</li>
<li>Views/Controllers will remain in CFML

<ul>
<li>This ties up with Sean&#8217;s answer to &#8216;What would you not use Clojure for?&#8217;</li>
<li>He mentioned HTML rendering as the major reason. You can&#8217;t hand <a href="https://github.com/weavejester/hiccup">hiccup</a> code to a designer.</li>
<li>Similarly, while designers can work on <a href="https://github.com/cgrand/enlive">Enlive</a> templates, updating the dynamic bits in Clojure can be cumbersome.</li>
</ul>
</li>
</ul>


<h3>Summary</h3>

<p>It was great to hear the many good things Sean had to say about Clojure. WorldSingles seem pretty happy with the decision of migration their heavy-lifting code to it and hopefully these slide notes will give you some insight into the sort of things Clojure is good at.</p>

<p><del>Sean is likely to put his slides up somewhere so I&#8217;ll link to it as soon as I have it.</del> <a href="http://corfield.org/articles/WorldSinglesWeb.pdf">Here they are.</a></p>

<p>If you want to know more about Clojure and be involved in the community, you should come to the next <a href="http://www.meetup.com/clj-syd/">clj-syd meetup</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[clj-syd report #0]]></title>
    <link href="http://www.leonardoborges.com/writings/2012/02/22/clj-syd-report-number-0/"/>
    <updated>2012-02-22T21:14:00+11:00</updated>
    <id>http://www.leonardoborges.com/writings/2012/02/22/clj-syd-report-number-0</id>
    <content type="html"><![CDATA[<p>Last night we held the first ever meetup for the <a href="http://groups.google.com/group/clj-syd">Sydney Clojure User Group</a>!</p>

<p>When I decided to start running the meetups I had no idea we&#8217;d end up with <strong>37</strong>
people on the first night! What a great turn out!</p>

<p>As for the content, here&#8217;s what you missed:</p>

<ul>
<li><strong>Running Clojure apps on Heroku</strong> - Lincoln Stoll (<a href="https://twitter.com/#!/lstoll">@lstoll</a>)</li>
</ul>


<p>Linc works for Heroku but ended up not spending a whole lot of time talking about
that - instead he showed us how  to build a simple web application using
<a href="https://github.com/weavejester/compojure/wiki">Compojure</a>, a small Clojure web framework.</p>

<p>He then evolved the example by implementing it using <a href="http://webnoir.org/">Noir</a> - yet another web
framework that builds on top of <a href="https://github.com/weavejester/compojure/wiki">Compojure</a>, adding some helpful macros.</p>

<p>To top it off, the UI was implemented in <a href="https://github.com/clojure/clojurescript">ClojureScript</a> - so that was all Clojure
from end to end!</p>

<ul>
<li><strong>Paredit (in Eclipse) for the IDE junkie</strong> - Matt Quail (<a href="https://twitter.com/#!/spudbean">@spudbean</a>)</li>
</ul>


<p>If you&#8217;re into lisps and use emacs - if not you <strong>should</strong> anyway - you learned to
love <a href="http://www.emacswiki.org/emacs/ParEdit">paredit</a>.</p>

<p>However, not everyone gets to write Clojure for a living and a lot of us end up in
some sort of IDE. If you&#8217;re in Java land, a popular choice is Eclipse and Matt showed
us how you can get the paredit goodness right there using the Eclipse plugin <a href="http://code.google.com/p/counterclockwise/">counterclockwise</a>.</p>

<ul>
<li><strong><a href="http://offbytwo.com/presentations/building-better-repl.pdf">Building a better Clojure REPL</a></strong> - Cosmin Sterejean (<a href="https://twitter.com/#!/offbytwo">@offbytwo</a>)</li>
</ul>


<p>Frustrated with the Clojure REPL? Wish you had more useful shortcuts? Decent line
editing? Saving that nice function you&#8217;ve been working on right from the REPL? Then
make sure you check out both the <a href="http://offbytwo.com/presentations/building-better-repl.pdf">presentation</a> and <a href="https://github.com/cosmin/IClojure">IClojure</a>, Cosmin&#8217;s
project.</p>

<p>Definetly worth a try.</p>

<ul>
<li><strong><a href="https://docs.google.com/open?id=0B-wuNsBziQXAZWZmMzdjMDQtYzM4Zi00NGNjLThhY2ItYTFhOTZkOTQ0OTBh">Where do I put my DependentStrategyTemplateAbstractFactory</a>?</strong> - Bayan Khalili</li>
</ul>


<p>Bayan was in one of our internal meetups. Some people raised the fact that we don&#8217;t
see a lot of the design patterns made popular by the <a href="http://amzn.to/wdq6Lr">GoF book</a> in languages such as Ruby, Python or Clojure
and the overall opinion is that in those languages, some of the problems these
patterns solve in, say, Java, simply don&#8217;t exist.</p>

<p>Bayan decided to dig up a few and show what&#8217;s the alternative in Clojure. Interesting
perspective.</p>

<h2>Want more?</h2>

<p>Join us on <a href="http://groups.google.com/group/clj-syd">Google Groups</a>, submit a talk proposal on the <a href="https://github.com/clj-syd/clj-syd/wiki">wiki</a> and RSVP to
the <a href="http://www.meetup.com/clj-syd/">next meetup</a>!</p>

<p>See you next time!</p>
]]></content>
  </entry>
  
</feed>
