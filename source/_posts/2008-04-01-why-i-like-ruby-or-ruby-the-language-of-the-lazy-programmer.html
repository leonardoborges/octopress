--- 
title: "Why I like ruby #0 (...or Ruby: The language of the lazy programmer)"
excerpt: |-
  This is quite funny. A friend, Perl addicted, is now learning Ruby. He really enjoys the language but made a interesting observation: Ruby is a language for lazy programmers!
  
  Well, I have to agree......
date: 2008/04/01
updated_at: 2008/04/01
comments: true
layout: post
categories: 
- Java
- Ruby
- Why I Like Ruby
---

<p>
This is quite funny. A friend, Perl addicted, is now learning Ruby. He really enjoys the language but made a interesting observation: Ruby is a language for lazy programmers!<br><br>Well, I have to agree... You know, I love saving keystrokes and achieving more by writing less. And this is so true with Ruby.<br><br>Let me give a really simple example, comparing with java - don't get me wrong... I love java, specially the platform, but it fits well here since I've always been a Java guy.<br><br>Imagine you have a Phone class with the attributes number and type, which can indicate whether the phone is a land line or a mobile phone. Then you got an array filled with phone classes and you want to narrow it by creating a new array only with mobile phones.<br><br>In Java, such a class could look very much like this:<br><pre><br>public class Phone {<br>  private String number;<br>  private String type;</code><br><br>  public String getNumber() {<br>    return number;<br>  }<br>  public void setNumber(String number) {<br>    this.number = number;<br>  }<br>  public String getType() {<br>    return type;<br>  }<br>  public void setType(String type) {<br>    this.type = type;<br>  }<br>}<br></pre><br><br>Quite simple, isn't it? But we are telling the compiler many things we actually shouldn't need to. This class is a java bean and as such, among other things, it needs a pair of getters and setters for each of its attributes.<br><br>Now, on with our example, the same class, in ruby, looks like this:<br><br><pre><br>class Phone<br>  attr_accessor :number, :type<br>end<br></pre><br><br>Yeah, I know the feeling. This class has exactly what we need: the two attributes with its own pairs of getters and setters each. But we didn't need to inform it in the verbose way Java has teached us. Cleaner, period.<br><br>Now to the code that actually returns the new array containing only mobile numbers. In java, we can do it in two different ways.<br>Using an ArrayList:<br><br><pre><br>//Create two phone objects, one land line and one mobile<br>...<br>// Add them to an array<br>ArrayList<phone> phones = new ArrayList<phone>();<br>phones.add(land);<br>phones.add(mobile);<br><br>//Return an array only with mobile numbers:<br>private static ArrayList<phone> selectMobilePhones(ArrayList<phone> phones) {<br><br>  ArrayList&lt;Phone&gt; mobiles = new ArrayList&lt;Phone&gt;();<br><br>  for (Phone phone : phones) {<br>    if (phone.getType().equals("mobile")) {<br>      mobiles.add(phone);<br>    }<br>  }<br>  return mobiles;<br>}<br></pre><br><br>Or using ordinary arrays:<br><br><pre><br>// Assume the same phone objects here<br>...<br>//Add them to the array<br>Phone[] phones = new Phone[]{land, mobile};<br><br>//Return an array only with mobile numbers:<br>Phone[] mobiles = new Phone[a.length];<br><br>for (int i = 0; i &lt; a.length; i++) {<br><br>  if (a[i].getType().equals("mobile")) {<br>    mobiles[i] = a[i];<br>  }<br>}<br></pre><br><br>And you're good to go. Actually this code with an ArrayList here only looks good thanks to generics. But this is another matter. Let's take a look at the ruby code that accomplishes de same task:<br><br><pre><br>//Create two phone objects, one land line and one mobile<br>...<br>//Add them to an array<br>phones = [land, mobile]</code><br><br>//Return an array only with mobile numbers:<br>mobiles = phones.select { |phone|<br>   phone.type == "mobile"<br>}<br></pre><br><br>See the difference? Java is a great language but too verbose at times. This is a really simple example but if you take the same principle to a bigger app... yeah, you see where I'm going.<br><br>The bottom line... Ruby may be the language of the lazy programmer, as my friend pointed out. But I don't mind being called lazy as long as I can type less and be more productive. Do you? :)
</p>

