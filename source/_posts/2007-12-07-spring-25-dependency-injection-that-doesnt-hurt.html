--- 
title: "Spring 2.5: Dependency Injection that doesn't hurt"
excerpt: "Dependency injection - DI\xC3\x82\xC2\xA0- \xC3\x82\xC2\xA0is a great thing. Really. The hability to tweak implementations without touching your code is awesome and the DI frameworks, like spring, saves you a lot of coding. No m..."
date: 2007/12/07
updated_at: 2007/12/07
comments: true
layout: post
categories: 
- Architecture
- Java
- Spring
---

<p>
<a href="http://martinfowler.com/articles/injection.html">Dependency injection</a> - <a href="http://martinfowler.com/articles/injection.html">DI</a>Â - Â is a great thing. Really. The hability to tweak implementations without touching your code is awesome and the DI frameworks, like spring, saves you a lot of coding. No more service locators stuff.<br><br>But, and there is always a but, you're left with a bunch of XML configuration. And I hate it. Not that XML files are bad... the thing is that everything nowadays has its own set of XML configurarion files. And <a href="http://www.springframework.org">Spring</a> is not different.<br><br><!--more--><br><br>Let's take a look at a simple example on how dependency injection is handled in Spring.<br><br>Imagine you have a domain object called Invoice that, among other things, is somewhat defined like this:<br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>You have a method to send a certain Invoice through e-mail, probably to some customer. This method would basically do some processing, maybe formatting strings, and then, ideally, delegate the send e-mail task to someone else. Probably a infrastructure service or something similar, that I will call EmailService. This object knows how to do the low level stuff like connecting to the SMTP server and so on. So we need this object, we <em>depend</em> on it.Â  To express this dependency, the Invoice code would change to this:<br><br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br>private EmailService emailService;<br>public void setEmailService(EmailService service) {<br>emailService = service;<br>}<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>This way the Invoice class is prepared to be injected with its only dependency using Spring. Now, what you would have to do is to declaratively express this dependency to the Spring container, so it can settle things for you. This is done through its XML configuration file, often called <em>applicationContext</em>. Below is the snippet of the file relevant to this example:<br><br>[xml]<br><br><bean id="invoice" class="com.leonardoborges.Invoice"><br><property name="emailService">Â  <ref bean="emailService"></ref></property><br></bean><br><br><bean id="emailService" class="com.leonardoborges.EmailService"></bean><br><br>[/xml]And that's it. Upon initialization Spring will use this XML file to discover that the Invoice object depends on the EMailService object and inject it using the setter method we created before.<br><br>The problem is: If we have 50 domain objects that depends on 10 service objects that depends on anything else, we would end up in a XML forrest with at least 60 bean definitions.<br>Of course you can break this creating smaller XML files, but they are stillÂ XML files with bean definitions. Well, with Spring 2.5 we have a better option: We can use annotations!<br>In this new release, Spring use its own set of annotations to resolve object dependencies without XML. Let's see how this thing works.<br><br>Our previous Invoice object would change to this:<br>[java]<br>public class Invoice {<br>//normal attributes and getters/setters<br>@AutoWired<br>@Qualifier("myEmailService")<br>private EmailService emailService;<br>public void setEmailService(EmailService service) {<br>emailService = service;<br>}<br><br>public void sendByEmailTo(String address) {<br>//code to send invoice by e-mail<br>}<br>}<br>[/java]<br><br>Let's explain this change. The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Autowired.html">@AutoWired</a> annotation tells spring that it should automatically wire dependencies based on its type, in our case, EmailService. But we take it a step further and choose which object to inject based not only on its type, but based on its name, with the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Qualifier.html">@Qualifier</a> annotation.<br><br>Â Hmm... you may be asking now - But where did we say theÂ objectÂ name is myEmailService?<br><br>Â Okay, the other leg of the magic is on the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/stereotype/Component.html">@Component</a> annotation:<br><br>[java]<br>@Component("myEmailService")<br>public class EmailService {<br>//methods<br>}<br>[/java]<br><br>With this annotation, you register a new component available for injection within the Spring container. This way, you don't need to put neither the Invoice objects, nor its dependencies in the xml files. Pretty, huh?<br><br>But one question remains: How the hell spring knows about this annotated classes?<br>This is the one-million question and the answer is simple. You <em>do</em> need an XML file, but just to tell spring where to look for annotated classes, this way:<br><br>[xml]<br><annotation-config></annotation-config><br><component-scan base-package="br.com"></component-scan><br>[/xml]<br><br>The first clause sets the container to support annotation based configuration. The second one, component-scan, defines the base package where Spring should look for anotated classes within your project. That's how it will be able to discover who needs who and who is a eligible component for injection.<br><br>You are really left with a small, tiny, piece of XML. Much more clean, elegant and much less XML to type.
</p>

