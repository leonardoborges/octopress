--- 
title: DBUnit and Hibernate
excerpt: I never paid too much attention on testing database stuff. While working with java, the closest I got to something workable was using the test case abstractions provided by the Spring framework. It en...
date: 2008/01/17
updated_at: 2008/01/17
comments: true
layout: post
categories: 
- Java
- Testing
---

<p>
I never paid too much attention on testing database stuff. While working with java, the closest I got to something <em>workable </em>was using the test case abstractions provided by the Spring framework. It ensures that each test method runs in its own transaction that is rolled back after the test's execution.<br><br>Fair enough. I used the <a href="http://junit.sourceforge.net/javadoc/junit/framework/TestCase.html#setUp()">setUp()</a> method on my <a href="http://junit.sourceforge.net/javadoc/junit/framework/TestCase.html">TestCase</a> to configure some records so I could work with them, removing all of them in the <a href="http://junit.sourceforge.net/javadoc/junit/framework/TestCase.html#tearDown()">tearDown()</a> method. It was quite simple and worked.<br><br>But I always felt something strange with this solution. First of all, I had to add another framework just for that. - Actually I was using spring for dependency injection, but if I wasn't, it wouldn't be a nice option. And another thing that bothered me, is that you cannot guarantee that your database is in a known state.<br><br>After I started to work with Ruby - and Rails - I discovered the <a href="http://manuals.rubyonrails.com/read/chapter/26">testing fixtures</a>. It is a really nice way to set up your testing data without having to worry about your database state. - If you don't know what I'm talking about, follow the above link first.<br><br>Then I received a message from a co-worker saying he was having some trouble in using <a href="http://www.dbunit.org/">DBUnit</a> with Hibernate, and asked for some help. I've heard of DBUnit before but never tried it myself. It was a very good opportunity to take a better look into it.<br><br>The basic idea after all is very similar to that of the Rails Fixtures: You have some sort of external file - XML in this case - where you set up the testing data. So the framework takes care of erasing the database, inserting your test data and returning it to its original state.<br><br>So far so good, DBUnit's default Classes works with <a href="http://www.dbunit.org/apidocs/org/dbunit/JdbcBasedDBTestCase.html">JDBC,</a> <a href="http://www.dbunit.org/apidocs/org/dbunit/DataSourceBasedDBTestCase.html">DataSources</a> and <a href="http://www.dbunit.org/apidocs/org/dbunit/JndiBasedDBTestCase.html">JNDIDatasources</a>, but not with Hibernate.  The effort to put them working together is minimal and is documented in their web site.<br><br>I decided to share how this can be done with hibernate and in the end, you would have a test case similar to this one:<br><br><!--more--><br><br>[java]<br>public class DBUnitTest extends TestCase {<br>private Session s;<br>private FileInputStream is;<br>private IDatabaseConnection conn;<br>private IDataSet dataSet;<br><br>public DBUnitTest() {<br>try {<br>s = HibernateUtil.getSession();<br>is = new FileInputStream("task-sample-data.xml");<br>conn = new DatabaseConnection(s.connection());<br>dataSet = new FlatXmlDataSet(is);<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>}<br><br>@Override<br>protected void setUp() throws Exception {<br>super.setUp();<br>try {<br>DatabaseOperation.INSERT.execute(conn, dataSet);<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br><br>}<br><br>public void testTrue() {<br>List<task> tasks = s.createQuery("from Task").list();<br>for (Task task : tasks) {<br>System.out.println(task.getId());<br>System.out.println(task.getDetails());<br>}<br>assertTrue(true);<br>}</task><br><br>@Override<br>protected void tearDown() throws Exception {<br>super.tearDown();<br>try {<br>DatabaseOperation.DELETE_ALL.execute(conn, dataSet);<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>}<br>}<br>[/java]<br><br>Note that you don't need to extend any DBUnit class. You extend only Junit's plain old TestCase. In its constructor I set up everything I need: The session factory (through the HibernateUtil), and use it to get a session's connection, needed for DBUnit.<br><br>This example is quite simple and I decided to keep it like this to show everything working together. But you would more likely make this class abstract with an abstract method, say getDataSet() so your subclasses wouldn't have to worry with DBUnit at all.
</p>

